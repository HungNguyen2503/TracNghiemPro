{
  "users": [
    {
      "id": 1,
      "fullName": "Nguyễn Văn A",
      "email": "vana@example.com",
      "password": "1",
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiJhZG1pbiIsInJvbGUiOiJBRE1JTiIsImlhdCI6MTY2MjgxNjAwMCwiZXhwIjoxNjYyODE5NjAwfQ.N37U_yX7F7g-v8X7Y0X7tG2S9d-n7J8q5wT8S8E4"
    },
    {
      "id": 2,
      "fullName": "Trần Thị B",
      "email": "thib@example.com",
      "password": "1",
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiIyNTY1IiwibmFtZSI6IlZpZXRJdCIsImlhdCI6MTY2MjgxNjAwMCwiZXhwIjoxNjYyOTAyNDAwfQ.S9d-n7J8q5wT8S8E4-N37U_yX7F7g-v8X7Y0X7tG2"
    },
    {
      "id": 3,
      "fullName": "Lê Minh C",
      "email": "minhc@example.com",
      "password": "hashed_password_c",
      "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOiI5OTk5IiwiaWF0IjoxNjYyODE2MDAwfQ.g-v8X7Y0X7tG2S9d-n7J8q5wT8S8E4-N37U_yX7F7"
    }
  ],
  "topics": [
    {
      "id": 1,
      "name": "HTML & Cấu trúc Web"
    },
    {
      "id": 2,
      "name": "CSS & Thiết kế Giao diện"
    },
    {
      "id": 3,
      "name": "JavaScript Cơ bản"
    },
    {
      "id": 4,
      "name": "ReactJS & Xây dựng Component"
    },
    {
      "id": 5,
      "name": "Kiến trúc & Hiệu năng Frontend"
    },
    {
      "id": 6,
      "name": "Công cụ & Môi trường Phát triển"
    },
    {
      "id": 7,
      "name": "Quản lý State & Data Fetching"
    },
    {
      "id": 8,
      "name": "Testing & Debugging Frontend"
    },
    {
      "id": 9,
      "name": "Thiết kế Responsive & UI/UX"
    },
    {
      "id": 10,
      "name": "Kiến thức Mạng & Bảo mật Web"
    }
  ],
  "questions": [
    {
      "id": 1,
      "topicId": 1,
      "question": "HTML là viết tắt của từ gì?",
      "options": [
        "HyperText Markup Language",
        "Hyperlinks and Text Markup Language",
        "Home Tool Markup Language",
        "HyperText Markdown Language"
      ],
      "correctAnswer": 0
    },
    {
      "id": 2,
      "topicId": 1,
      "question": "Thẻ HTML nào được sử dụng để định nghĩa một đoạn văn bản?",
      "options": [
        "<div>",
        "<p>",
        "<span>",
        "<text>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 3,
      "topicId": 1,
      "question": "Thẻ nào được sử dụng để tạo một liên kết (hyperlink) trong HTML?",
      "options": [
        "<link>",
        "<a>",
        "<href>",
        "<url>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 4,
      "topicId": 1,
      "question": "Thuộc tính 'src' trong thẻ `<img>` có ý nghĩa gì?",
      "options": [
        "Kích thước hình ảnh",
        "Đường dẫn đến tệp hình ảnh",
        "Mô tả hình ảnh",
        "Căn chỉnh hình ảnh"
      ],
      "correctAnswer": 1
    },
    {
      "id": 5,
      "topicId": 1,
      "question": "Thẻ nào dùng để tạo một danh sách không có thứ tự (unordered list) trong HTML?",
      "options": [
        "<ol>",
        "<ul>",
        "<li>",
        "<dl>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 6,
      "topicId": 1,
      "question": "Phần tử HTML nào được sử dụng để định nghĩa tiêu đề cấp 1 (heading level 1)?",
      "options": [
        "<h2>",
        "<h1>",
        "<head>",
        "<title>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 7,
      "topicId": 1,
      "question": "Thẻ nào là thẻ trống (empty tag) trong HTML?",
      "options": [
        "<div>",
        "<p>",
        "<img>",
        "<a>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 8,
      "topicId": 1,
      "question": "Để tạo một bảng trong HTML, bạn sẽ sử dụng thẻ nào?",
      "options": [
        "<list>",
        "<table>",
        "<grid>",
        "<tab>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 9,
      "topicId": 1,
      "question": "Trong HTML, thẻ `<head>` chứa thông tin gì?",
      "options": [
        "Nội dung hiển thị trên trang web",
        "Metadata về tài liệu HTML",
        "Các script JavaScript",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 1
    },
    {
      "id": 10,
      "topicId": 1,
      "question": "Thẻ HTML nào được dùng để nhúng một tệp CSS bên ngoài vào tài liệu?",
      "options": [
        "<style>",
        "<script>",
        "<link>",
        "<css>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 11,
      "topicId": 1,
      "question": "Thuộc tính nào của thẻ `<a>` dùng để mở liên kết trong một tab hoặc cửa sổ mới?",
      "options": [
        "src",
        "href",
        "target",
        "link"
      ],
      "correctAnswer": 2
    },
    {
      "id": 12,
      "topicId": 1,
      "question": "Thẻ HTML nào được dùng để định nghĩa một mục trong danh sách (list item)?",
      "options": [
        "<ul>",
        "<ol>",
        "<li>",
        "<item>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 13,
      "topicId": 1,
      "question": "Semantic HTML có ý nghĩa gì?",
      "options": [
        "Sử dụng các thẻ HTML không có ý nghĩa cụ thể",
        "Sử dụng các thẻ HTML có ý nghĩa rõ ràng về nội dung mà chúng chứa",
        "Viết HTML theo cách đẹp mắt",
        "Tối ưu HTML cho tốc độ tải trang"
      ],
      "correctAnswer": 1
    },
    {
      "id": 14,
      "topicId": 1,
      "question": "Thẻ HTML5 mới nào dùng để định nghĩa phần nội dung độc lập (self-contained content) như bài viết blog, bình luận?",
      "options": [
        "<section>",
        "<aside>",
        "<article>",
        "<main>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 15,
      "topicId": 1,
      "question": "Để tạo một trường nhập liệu mật khẩu trong form HTML, bạn sẽ sử dụng thuộc tính `type` nào?",
      "options": [
        "type=\"text\"",
        "type=\"email\"",
        "type=\"password\"",
        "type=\"number\""
      ],
      "correctAnswer": 2
    },
    {
      "id": 16,
      "topicId": 1,
      "question": "Phần tử HTML nào được sử dụng để nhóm các tùy chọn trong một danh sách thả xuống (`<select>`)?",
      "options": [
        "<option>",
        "<optgroup>",
        "<selectlist>",
        "<datalist>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 17,
      "topicId": 1,
      "question": "Thuộc tính `colspan` trong bảng HTML dùng để làm gì?",
      "options": [
        "Nối các hàng lại với nhau",
        "Nối các cột lại với nhau",
        "Thay đổi màu nền của ô",
        "Thiết lập chiều rộng của cột"
      ],
      "correctAnswer": 1
    },
    {
      "id": 18,
      "topicId": 1,
      "question": "Để hiển thị một đoạn mã code inline trong văn bản HTML, bạn nên sử dụng thẻ nào?",
      "options": [
        "<pre>",
        "<code>",
        "<kbd>",
        "<samp>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 19,
      "topicId": 1,
      "question": "Thẻ HTML nào dùng để định nghĩa nội dung chính (main content) của tài liệu?",
      "options": [
        "<header>",
        "<footer>",
        "<main>",
        "<section>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 20,
      "topicId": 1,
      "question": "Thuộc tính `autofocus` trong thẻ input có tác dụng gì?",
      "options": [
        "Tự động gửi form",
        "Tự động tập trung vào trường input khi trang tải",
        "Tự động điền giá trị cho trường input",
        "Tự động kiểm tra tính hợp lệ của input"
      ],
      "correctAnswer": 1
    },
    {
      "id": 21,
      "topicId": 1,
      "question": "Thẻ HTML nào được sử dụng để định nghĩa một chú thích cho hình ảnh hoặc bảng?",
      "options": [
        "<label>",
        "<caption>",
        "<figcaption>",
        "Cả B và C đều đúng"
      ],
      "correctAnswer": 3
    },
    {
      "id": 22,
      "topicId": 1,
      "question": "Sự khác biệt giữa `<div>` và `<span>` là gì?",
      "options": [
        "`<div>` là inline, `<span>` là block.",
        "`<div>` là block, `<span>` là inline.",
        "Không có sự khác biệt đáng kể.",
        "Cả hai đều là thẻ trống."
      ],
      "correctAnswer": 1
    },
    {
      "id": 23,
      "topicId": 1,
      "question": "Thẻ nào dùng để định nghĩa một tập hợp các liên kết điều hướng (navigation links)?",
      "options": [
        "<header>",
        "<footer>",
        "<nav>",
        "<aside>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 24,
      "topicId": 1,
      "question": "Thuộc tính `placeholder` trong thẻ `<input>` có tác dụng gì?",
      "options": [
        "Đặt giá trị mặc định cho input",
        "Hiển thị văn bản gợi ý trong trường input khi nó trống",
        "Chỉ định định dạng dữ liệu được phép nhập",
        "Xác định độ dài tối đa của input"
      ],
      "correctAnswer": 1
    },
    {
      "id": 25,
      "topicId": 1,
      "question": "Làm thế nào để nhúng một video từ YouTube vào trang HTML?",
      "options": [
        "Sử dụng thẻ `<video>` trực tiếp",
        "Sử dụng thẻ `<iframe>` với đường dẫn của video YouTube",
        "Sử dụng thẻ `<embed>`",
        "Tải video về và dùng thẻ `<source>`"
      ],
      "correctAnswer": 1
    },
    {
      "id": 26,
      "topicId": 1,
      "question": "Thẻ HTML nào được dùng để định nghĩa một tiêu đề cho một nhóm các trường trong form?",
      "options": [
        "<label>",
        "<legend>",
        "<fieldset>",
        "<formgroup>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 27,
      "topicId": 1,
      "question": "Thuộc tính `rowspan` trong bảng HTML dùng để làm gì?",
      "options": [
        "Nối các hàng lại với nhau",
        "Nối các cột lại với nhau",
        "Thiết lập chiều cao của hàng",
        "Thay đổi màu nền của ô"
      ],
      "correctAnswer": 0
    },
    {
      "id": 28,
      "topicId": 1,
      "question": "Thẻ nào được dùng để nhúng một tài liệu HTML khác vào trong tài liệu hiện tại?",
      "options": [
        "<link>",
        "<iframe>",
        "<object>",
        "<embed>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 29,
      "topicId": 1,
      "question": "Thẻ nào dùng để định nghĩa một danh sách có thứ tự (ordered list)?",
      "options": [
        "<ul>",
        "<ol>",
        "<li>",
        "<dl>"
      ],
      "correctAnswer": 1
    },
    {
      "id": 30,
      "topicId": 1,
      "question": "Thuộc tính `readonly` trong thẻ input có ý nghĩa gì?",
      "options": [
        "Người dùng không thể nhìn thấy trường input",
        "Người dùng không thể thay đổi giá trị của trường input, nhưng vẫn có thể chọn và sao chép",
        "Người dùng không thể chọn trường input",
        "Trường input bị vô hiệu hóa hoàn toàn"
      ],
      "correctAnswer": 1
    },
    {
      "id": 31,
      "topicId": 1,
      "question": "Thẻ nào được sử dụng để định nghĩa một hình ảnh bản đồ (image map) có các khu vực có thể nhấp được?",
      "options": [
        "<map>",
        "<area>",
        "<imagemap>",
        "<img>"
      ],
      "correctAnswer": 0
    },
    {
      "id": 32,
      "topicId": 1,
      "question": "HTML Comments được viết như thế nào?",
      "options": [
        "// Comment",
        "/* Comment */",
        "",
        "# Comment"
      ],
      "correctAnswer": 2
    },
    {
      "id": 33,
      "topicId": 1,
      "question": "Thẻ nào là cha của tất cả các phần tử hiển thị trên trang web?",
      "options": [
        "<head>",
        "<html>",
        "<body>",
        "<document>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 34,
      "topicId": 1,
      "question": "Để tạo một nút gửi form, bạn sẽ dùng thuộc tính `type` nào cho thẻ `<input>`?",
      "options": [
        "type=\"text\"",
        "type=\"button\"",
        "type=\"submit\"",
        "type=\"send\""
      ],
      "correctAnswer": 2
    },
    {
      "id": 35,
      "topicId": 1,
      "question": "Thẻ HTML nào dùng để định nghĩa phần chân trang (footer) cho tài liệu hoặc một phần nội dung?",
      "options": [
        "<header>",
        "<bottom>",
        "<footer>",
        "<end>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 36,
      "topicId": 1,
      "question": "Thuộc tính `aria-label` dùng để làm gì trong HTML?",
      "options": [
        "Thay đổi màu sắc của phần tử",
        "Cung cấp một nhãn văn bản mô tả cho các phần tử UI cho người dùng sử dụng trình đọc màn hình",
        "Ẩn phần tử khỏi màn hình",
        "Đặt một ID duy nhất cho phần tử"
      ],
      "correctAnswer": 1
    },
    {
      "id": 37,
      "topicId": 1,
      "question": "Thẻ nào được sử dụng để định nghĩa một nhóm các tùy chọn liên quan trong một danh sách (`<datalist>`)?",
      "options": [
        "<group>",
        "<option>",
        "<optgroup>",
        "<label>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 38,
      "topicId": 1,
      "question": "Mục đích của thẻ `<meta charset=\"UTF-8\">` trong HTML là gì?",
      "options": [
        "Thiết lập ngôn ngữ mặc định của trang",
        "Định nghĩa bộ mã hóa ký tự cho tài liệu, hỗ trợ hiển thị tiếng Việt",
        "Chỉ định tác giả của trang",
        "Thiết lập tiêu đề của trang"
      ],
      "correctAnswer": 1
    },
    {
      "id": 39,
      "topicId": 1,
      "question": "Thẻ nào dùng để tạo một danh sách các thuật ngữ và định nghĩa của chúng?",
      "options": [
        "<ul>",
        "<ol>",
        "<dl>",
        "<li>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 40,
      "topicId": 1,
      "question": "Thuộc tính `required` trong form HTML có tác dụng gì?",
      "options": [
        "Bắt buộc người dùng phải điền vào trường đó trước khi gửi form",
        "Hiển thị một thông báo lỗi khi trường đó trống",
        "Đặt giá trị mặc định cho trường",
        "Giới hạn số lượng ký tự nhập vào"
      ],
      "correctAnswer": 0
    },
    {
      "id": 41,
      "topicId": 2,
      "question": "Thuộc tính CSS nào được dùng để thay đổi màu chữ của một phần tử?",
      "options": [
        "background-color",
        "color",
        "font-color",
        "text-color"
      ],
      "correctAnswer": 1
    },
    {
      "id": 42,
      "topicId": 2,
      "question": "Để chọn một phần tử có ID là 'header' trong CSS, bạn sẽ sử dụng cú pháp nào?",
      "options": [
        ".header",
        "header",
        "#header",
        "element#header"
      ],
      "correctAnswer": 2
    },
    {
      "id": 43,
      "topicId": 2,
      "question": "Thuộc tính CSS nào dùng để kiểm soát khoảng cách giữa các chữ cái trong một văn bản?",
      "options": [
        "word-spacing",
        "line-height",
        "letter-spacing",
        "text-indent"
      ],
      "correctAnswer": 2
    },
    {
      "id": 44,
      "topicId": 2,
      "question": "Trong CSS Flexbox, thuộc tính `justify-content` dùng để làm gì?",
      "options": [
        "Căn chỉnh các mục theo trục chính (main axis)",
        "Căn chỉnh các mục theo trục phụ (cross axis)",
        "Kiểm soát hướng của các mục",
        "Thay đổi thứ tự hiển thị của các mục"
      ],
      "correctAnswer": 0
    },
    {
      "id": 45,
      "topicId": 2,
      "question": "Đơn vị nào dưới đây được coi là đơn vị tương đối (relative unit) trong CSS?",
      "options": [
        "px",
        "em",
        "pt",
        "cm"
      ],
      "correctAnswer": 1
    },
    {
      "id": 46,
      "topicId": 2,
      "question": "Để tạo đường viền xung quanh một phần tử trong CSS, bạn dùng thuộc tính nào?",
      "options": [
        "outline",
        "border",
        "margin",
        "padding"
      ],
      "correctAnswer": 1
    },
    {
      "id": 47,
      "topicId": 2,
      "question": "Thuộc tính `display: none;` trong CSS có tác dụng gì?",
      "options": [
        "Ẩn phần tử nhưng vẫn chiếm không gian",
        "Ẩn phần tử và không chiếm không gian",
        "Thay đổi màu sắc của phần tử thành trong suốt",
        "Làm mờ phần tử"
      ],
      "correctAnswer": 1
    },
    {
      "id": 48,
      "topicId": 2,
      "question": "Sự khác biệt giữa `margin` và `padding` trong CSS là gì?",
      "options": [
        "Margin là khoảng trống bên trong phần tử, padding là khoảng trống bên ngoài",
        "Margin là khoảng trống bên ngoài phần tử, padding là khoảng trống bên trong",
        "Cả hai đều là khoảng trống bên trong phần tử",
        "Cả hai đều là khoảng trống bên ngoài phần tử"
      ],
      "correctAnswer": 1
    },
    {
      "id": 49,
      "topicId": 2,
      "question": "Để làm tròn các góc của một phần tử trong CSS, bạn dùng thuộc tính nào?",
      "options": [
        "border-style",
        "border-width",
        "border-radius",
        "border-color"
      ],
      "correctAnswer": 2
    },
    {
      "id": 50,
      "topicId": 2,
      "question": "Trong CSS Grid Layout, thuộc tính `grid-template-columns` dùng để làm gì?",
      "options": [
        "Định nghĩa số lượng và kích thước của các hàng",
        "Định nghĩa số lượng và kích thước của các cột",
        "Kiểm soát khoảng cách giữa các ô",
        "Đặt vị trí của một mục trong lưới"
      ],
      "correctAnswer": 1
    },
    {
      "id": 51,
      "topicId": 2,
      "question": "Cú pháp để chọn tất cả các phần tử `p` nằm trong một phần tử `div` là gì?",
      "options": [
        "div+p",
        "div > p",
        "div p",
        "div.p"
      ],
      "correctAnswer": 2
    },
    {
      "id": 52,
      "topicId": 2,
      "question": "Để thay đổi font chữ của một phần tử, bạn dùng thuộc tính CSS nào?",
      "options": [
        "text-font",
        "font-family",
        "font-style",
        "font-type"
      ],
      "correctAnswer": 1
    },
    {
      "id": 53,
      "topicId": 2,
      "question": "Thuộc tính `position: absolute;` trong CSS có ý nghĩa gì?",
      "options": [
        "Phần tử được định vị theo dòng chảy bình thường của tài liệu",
        "Phần tử được định vị tương đối với phần tử cha gần nhất có `position` khác `static`",
        "Phần tử được định vị tương đối với cửa sổ trình duyệt",
        "Phần tử được định vị cố định trên màn hình"
      ],
      "correctAnswer": 1
    },
    {
      "id": 54,
      "topicId": 2,
      "question": "Để làm cho một phần tử được căn giữa theo chiều ngang trong một khối container, bạn thường sử dụng thuộc tính nào (nếu nó là block-level element)?",
      "options": [
        "text-align: center;",
        "margin: 0 auto;",
        "align-items: center;",
        "float: center;"
      ],
      "correctAnswer": 1
    },
    {
      "id": 55,
      "topicId": 2,
      "question": "Thứ tự ưu tiên (specificity) của CSS selector nào là cao nhất?",
      "options": [
        "Element selector (e.g., p)",
        "Class selector (e.g., .my-class)",
        "ID selector (e.g., #my-id)",
        "Universal selector (e.g., *)"
      ],
      "correctAnswer": 2
    },
    {
      "id": 56,
      "topicId": 2,
      "question": "Thuộc tính CSS nào dùng để thay đổi độ trong suốt (opacity) của một phần tử?",
      "options": [
        "transparent",
        "alpha",
        "opacity",
        "visibility"
      ],
      "correctAnswer": 2
    },
    {
      "id": 57,
      "topicId": 2,
      "question": "Để tạo một hình nền cho một phần tử, bạn sử dụng thuộc tính nào?",
      "options": [
        "background-color",
        "background-image",
        "background-size",
        "background"
      ],
      "correctAnswer": 3
    },
    {
      "id": 58,
      "topicId": 2,
      "question": "Thuộc tính nào dùng để căn chỉnh văn bản trong một phần tử?",
      "options": [
        "font-align",
        "text-align",
        "align-text",
        "text-position"
      ],
      "correctAnswer": 1
    },
    {
      "id": 59,
      "topicId": 2,
      "question": "Pseudo-class `:hover` trong CSS được dùng để làm gì?",
      "options": [
        "Áp dụng kiểu khi phần tử được chọn",
        "Áp dụng kiểu khi con trỏ chuột di chuyển qua phần tử",
        "Áp dụng kiểu khi phần tử bị vô hiệu hóa",
        "Áp dụng kiểu khi phần tử được tập trung"
      ],
      "correctAnswer": 1
    },
    {
      "id": 60,
      "topicId": 2,
      "question": "Trong CSS, thuộc tính `z-index` dùng để làm gì?",
      "options": [
        "Kiểm soát thứ tự xếp chồng của các phần tử định vị (positioned elements)",
        "Kiểm soát độ phóng đại của phần tử",
        "Đặt độ rộng của phần tử",
        "Thiết lập vị trí của phần tử trên trục Z"
      ],
      "correctAnswer": 0
    },
    {
      "id": 61,
      "topicId": 2,
      "question": "Thuộc tính `box-sizing: border-box;` có tác dụng gì?",
      "options": [
        "Tính toán kích thước của phần tử bao gồm padding và border vào trong chiều rộng/cao đã định",
        "Tính toán kích thước của phần tử chỉ bao gồm nội dung",
        "Ẩn phần tử",
        "Thêm một đường viền cho phần tử"
      ],
      "correctAnswer": 0
    },
    {
      "id": 62,
      "topicId": 2,
      "question": "Để tạo hiệu ứng chuyển động mượt mà giữa các trạng thái CSS, bạn sử dụng thuộc tính nào?",
      "options": [
        "animation",
        "transform",
        "transition",
        "timing-function"
      ],
      "correctAnswer": 2
    },
    {
      "id": 63,
      "topicId": 2,
      "question": "Thuộc tính `overflow: hidden;` có tác dụng gì?",
      "options": [
        "Hiển thị thanh cuộn khi nội dung tràn",
        "Cắt bỏ phần nội dung bị tràn và ẩn nó đi",
        "Làm cho phần tử tràn ra ngoài",
        "Thêm khoảng trống xung quanh nội dung"
      ],
      "correctAnswer": 1
    },
    {
      "id": 64,
      "topicId": 2,
      "question": "Để áp dụng kiểu CSS cho tất cả các phần tử, bạn sử dụng selector nào?",
      "options": [
        "div",
        "body",
        "*",
        "html"
      ],
      "correctAnswer": 2
    },
    {
      "id": 65,
      "topicId": 2,
      "question": "Thuộc tính `text-decoration` thường được dùng để làm gì?",
      "options": [
        "Thay đổi font chữ",
        "Thay đổi màu chữ",
        "Thêm hoặc xóa các đường gạch chân, gạch ngang, gạch trên cho văn bản",
        "Căn chỉnh văn bản"
      ],
      "correctAnswer": 2
    },
    {
      "id": 66,
      "topicId": 2,
      "question": "Đơn vị nào sau đây tương đương với kích thước font của phần tử gốc (`<html>`)?",
      "options": [
        "em",
        "rem",
        "px",
        "vw"
      ],
      "correctAnswer": 1
    },
    {
      "id": 67,
      "topicId": 2,
      "question": "Thuộc tính `flex-direction` trong Flexbox dùng để làm gì?",
      "options": [
        "Đặt hướng của trục chính (main axis) cho các mục flex",
        "Đặt hướng của trục phụ (cross axis)",
        "Kiểm soát việc các mục flex có xuống dòng hay không",
        "Điều chỉnh kích thước của các mục flex"
      ],
      "correctAnswer": 0
    },
    {
      "id": 68,
      "topicId": 2,
      "question": "Để làm cho một hình ảnh có thể thay đổi kích thước linh hoạt theo container của nó mà vẫn giữ tỉ lệ, bạn dùng thuộc tính nào?",
      "options": [
        "width: 100%; height: 100%;",
        "max-width: 100%; height: auto;",
        "object-fit: contain;",
        "display: block;"
      ],
      "correctAnswer": 1
    },
    {
      "id": 69,
      "topicId": 2,
      "question": "Sự khác biệt giữa `visibility: hidden;` và `display: none;` là gì?",
      "options": [
        "`visibility: hidden;` ẩn phần tử nhưng vẫn chiếm không gian, `display: none;` ẩn và không chiếm không gian.",
        "`visibility: hidden;` không ẩn phần tử, `display: none;` ẩn phần tử.",
        "Cả hai đều ẩn phần tử và không chiếm không gian.",
        "Cả hai đều ẩn phần tử nhưng vẫn chiếm không gian."
      ],
      "correctAnswer": 0
    },
    {
      "id": 70,
      "topicId": 2,
      "question": "Thuộc tính CSS nào cho phép bạn tạo bóng đổ cho một hộp (box shadow)?",
      "options": [
        "text-shadow",
        "box-shadow",
        "element-shadow",
        "drop-shadow"
      ],
      "correctAnswer": 1
    },
    {
      "id": 71,
      "topicId": 2,
      "question": "Trong CSS, đơn vị `vw` (viewport width) và `vh` (viewport height) có ý nghĩa gì?",
      "options": [
        "Đơn vị tuyệt đối dựa trên kích thước font",
        "Đơn vị tương đối dựa trên kích thước của viewport (khu vực hiển thị của trình duyệt)",
        "Đơn vị tương đối dựa trên kích thước của phần tử cha",
        "Đơn vị chỉ dùng cho hình ảnh"
      ],
      "correctAnswer": 1
    },
    {
      "id": 72,
      "topicId": 2,
      "question": "Để áp dụng một hiệu ứng chuyển đổi (transform) 2D như scale, rotate, translate cho một phần tử, bạn dùng thuộc tính nào?",
      "options": [
        "transition",
        "animation",
        "transform",
        "effect"
      ],
      "correctAnswer": 2
    },
    {
      "id": 73,
      "topicId": 2,
      "question": "Thuộc tính `line-height` trong CSS dùng để làm gì?",
      "options": [
        "Điều chỉnh chiều cao của một dòng văn bản",
        "Điều chỉnh chiều cao của một phần tử",
        "Điều chỉnh khoảng cách giữa các chữ cái",
        "Điều chỉnh độ dày của đường viền"
      ],
      "correctAnswer": 0
    },
    {
      "id": 74,
      "topicId": 2,
      "question": "Trong Flexbox, thuộc tính `align-items` dùng để làm gì?",
      "options": [
        "Căn chỉnh các mục theo trục chính (main axis)",
        "Căn chỉnh các mục theo trục phụ (cross axis)",
        "Kiểm soát hướng của các mục",
        "Thay đổi thứ tự hiển thị của các mục"
      ],
      "correctAnswer": 1
    },
    {
      "id": 75,
      "topicId": 2,
      "question": "Để tạo kiểu cho phần tử đầu tiên của một loại nhất định, bạn sử dụng pseudo-class nào?",
      "options": [
        ":first-child",
        ":first-of-type",
        ":nth-child(1)",
        ":root"
      ],
      "correctAnswer": 1
    },
    {
      "id": 76,
      "topicId": 2,
      "question": "Thuộc tính CSS nào cho phép bạn thêm một hình ảnh nhỏ (favicon) vào thanh địa chỉ của trình duyệt?",
      "options": [
        "background-image",
        "icon",
        "link rel=\"icon\"",
        "image-src"
      ],
      "correctAnswer": 2
    },
    {
      "id": 77,
      "topicId": 2,
      "question": "Trong CSS Grid Layout, thuộc tính `grid-gap` (hoặc `gap`) dùng để làm gì?",
      "options": [
        "Tạo khoảng trống bên trong các ô grid",
        "Tạo khoảng cách giữa các hàng và cột trong lưới",
        "Đặt vị trí của một mục trong lưới",
        "Thay đổi kích thước của lưới"
      ],
      "correctAnswer": 1
    },
    {
      "id": 78,
      "topicId": 2,
      "question": "Thuộc tính `float` trong CSS dùng để làm gì?",
      "options": [
        "Căn chỉnh phần tử theo chiều dọc",
        "Đẩy phần tử sang trái hoặc phải, cho phép văn bản hoặc các phần tử khác bao quanh nó",
        "Làm cho phần tử nổi lên trên các phần tử khác",
        "Ẩn phần tử"
      ],
      "correctAnswer": 1
    },
    {
      "id": 79,
      "topicId": 2,
      "question": "Pseudo-element `::before` và `::after` trong CSS được dùng để làm gì?",
      "options": [
        "Thay đổi font chữ của phần tử",
        "Chèn nội dung ảo trước hoặc sau nội dung thực của phần tử",
        "Thêm khoảng trống xung quanh phần tử",
        "Tạo các đường viền động"
      ],
      "correctAnswer": 1
    },
    {
      "id": 80,
      "topicId": 2,
      "question": "Cú pháp để nhúng CSS trực tiếp vào thẻ HTML (inline CSS) là gì?",
      "options": [
        "<p class='my-style'>",
        "<p id='my-style'>",
        "<p style='color: blue;'>",
        "<p data-style='color: blue;'>"
      ],
      "correctAnswer": 2
    },
    {
      "id": 81,
      "topicId": 3,
      "question": "Hàm JavaScript nào được dùng để in ra console của trình duyệt?",
      "options": [
        "print()",
        "log()",
        "console.log()",
        "display()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 82,
      "topicId": 3,
      "question": "Từ khóa nào dùng để khai báo một biến có thể gán lại giá trị trong JavaScript (ES6 trở lên)?",
      "options": [
        "const",
        "var",
        "let",
        "static"
      ],
      "correctAnswer": 2
    },
    {
      "id": 83,
      "topicId": 3,
      "question": "Trong JavaScript, `typeof null` sẽ trả về giá trị gì?",
      "options": [
        "'null'",
        "'undefined'",
        "'object'",
        "'number'"
      ],
      "correctAnswer": 2
    },
    {
      "id": 84,
      "topicId": 3,
      "question": "Cú pháp nào sau đây là đúng để khai báo một hàm mũi tên (arrow function) trong JavaScript?",
      "options": [
        "function myFunc() {}",
        "const myFunc = function() {};",
        "const myFunc = () => {};",
        "myFunc: function() {}"
      ],
      "correctAnswer": 2
    },
    {
      "id": 85,
      "topicId": 3,
      "question": "Phương thức nào của Array được dùng để thêm một phần tử vào cuối mảng?",
      "options": [
        "shift()",
        "unshift()",
        "push()",
        "pop()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 86,
      "topicId": 3,
      "question": "Giá trị `NaN` trong JavaScript là viết tắt của từ gì?",
      "options": [
        "Not a Number",
        "No and Nothing",
        "New At Null",
        "Negative Any Number"
      ],
      "correctAnswer": 0
    },
    {
      "id": 87,
      "topicId": 3,
      "question": "Làm thế nào để kiểm tra kiểu dữ liệu của một biến trong JavaScript?",
      "options": [
        "typeof",
        "typeOf",
        "checkType",
        "getType"
      ],
      "correctAnswer": 0
    },
    {
      "id": 88,
      "topicId": 3,
      "question": "Toán tử `===` trong JavaScript có ý nghĩa gì?",
      "options": [
        "So sánh giá trị",
        "So sánh giá trị và kiểu dữ liệu",
        "Gán giá trị",
        "Tăng giá trị lên 3"
      ],
      "correctAnswer": 1
    },
    {
      "id": 89,
      "topicId": 3,
      "question": "Phương thức nào được dùng để loại bỏ khoảng trắng ở đầu và cuối một chuỗi trong JavaScript?",
      "options": [
        "slice()",
        "trim()",
        "substring()",
        "replace()"
      ],
      "correctAnswer": 1
    },
    {
      "id": 90,
      "topicId": 3,
      "question": "Đâu là cách đúng để thêm một sự kiện lắng nghe (event listener) cho một phần tử HTML?",
      "options": [
        "element.on('click', handler);",
        "element.addEvent('click', handler);",
        "element.addEventListener('click', handler);",
        "element.attachEvent('click', handler);"
      ],
      "correctAnswer": 2
    },
    {
      "id": 91,
      "topicId": 3,
      "question": "Promise trong JavaScript được dùng để xử lý cái gì?",
      "options": [
        "Đồng bộ hóa mã",
        "Các tác vụ bất đồng bộ",
        "Vòng lặp",
        "Các đối tượng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 92,
      "topicId": 3,
      "question": "Kết quả của biểu thức `1 + '2' + 3` trong JavaScript là gì?",
      "options": [
        "6",
        "'123'",
        "'33'",
        "'12' + 3"
      ],
      "correctAnswer": 1
    },
    {
      "id": 93,
      "topicId": 3,
      "question": "Vòng lặp nào được dùng để lặp qua các thuộc tính của một đối tượng trong JavaScript?",
      "options": [
        "for (let i of array)",
        "for (let i in object)",
        "while (condition)",
        "do...while (condition)"
      ],
      "correctAnswer": 1
    },
    {
      "id": 94,
      "topicId": 3,
      "question": "Để truy cập phần tử HTML có ID là 'myElement' trong JavaScript, bạn dùng phương thức nào?",
      "options": [
        "document.getElementById('myElement')",
        "document.querySelector('#myElement')",
        "document.getElementsByClassName('myElement')",
        "Cả A và B đều đúng"
      ],
      "correctAnswer": 3
    },
    {
      "id": 95,
      "topicId": 3,
      "question": "ES6 giới thiệu tính năng nào để đơn giản hóa việc trích xuất giá trị từ mảng hoặc đối tượng?",
      "options": [
        "Promises",
        "Arrow functions",
        "Destructuring assignment",
        "Classes"
      ],
      "correctAnswer": 2
    },
    {
      "id": 96,
      "topicId": 3,
      "question": "Phương thức nào của String trong JavaScript dùng để tìm kiếm một chuỗi con và trả về vị trí đầu tiên tìm thấy?",
      "options": [
        "slice()",
        "search()",
        "indexOf()",
        "match()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 97,
      "topicId": 3,
      "question": "Cách nào sau đây là đúng để tạo một mảng rỗng trong JavaScript?",
      "options": [
        "var arr = {};",
        "var arr = [];",
        "var arr = new Array();",
        "Cả B và C đều đúng"
      ],
      "correctAnswer": 3
    },
    {
      "id": 98,
      "topicId": 3,
      "question": "Sự khác biệt giữa `==` và `===` trong JavaScript là gì?",
      "options": [
        "`==` so sánh giá trị và kiểu, `===` chỉ so sánh giá trị.",
        "`==` chỉ so sánh giá trị, `===` so sánh cả giá trị và kiểu.",
        "Không có sự khác biệt.",
        "Một cái dùng cho số, một cái dùng cho chuỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 99,
      "topicId": 3,
      "question": "Callback function trong JavaScript là gì?",
      "options": [
        "Một hàm được gọi tự động khi trình duyệt khởi động.",
        "Một hàm được truyền dưới dạng đối số cho một hàm khác và được gọi lại sau khi hàm đó hoàn thành.",
        "Một hàm chỉ có thể gọi một lần.",
        "Một hàm dùng để xử lý lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 100,
      "topicId": 3,
      "question": "Để tạm dừng việc thực thi code trong JavaScript trong một khoảng thời gian nhất định, bạn dùng hàm nào?",
      "options": [
        "setTimeout()",
        "setInterval()",
        "delay()",
        "wait()"
      ],
      "correctAnswer": 0
    },
    {
      "id": 101,
      "topicId": 3,
      "question": "Phương thức nào của Array dùng để tạo một mảng mới bằng cách áp dụng một hàm cho từng phần tử của mảng gốc?",
      "options": [
        "forEach()",
        "filter()",
        "map()",
        "reduce()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 102,
      "topicId": 3,
      "question": "Truthy và Falsy values trong JavaScript là gì?",
      "options": [
        "Các giá trị luôn luôn đúng hoặc sai.",
        "Các giá trị được coi là `true` hoặc `false` trong ngữ cảnh boolean, mặc dù không phải là boolean thực sự.",
        "Chỉ có `true` và `false`.",
        "Các giá trị chỉ dùng trong phép toán số học."
      ],
      "correctAnswer": 1
    },
    {
      "id": 103,
      "topicId": 3,
      "question": "Để xóa phần tử cuối cùng ra khỏi mảng trong JavaScript, bạn dùng phương thức nào?",
      "options": [
        "shift()",
        "unshift()",
        "push()",
        "pop()"
      ],
      "correctAnswer": 3
    },
    {
      "id": 104,
      "topicId": 3,
      "question": "Cú pháp `try...catch` trong JavaScript dùng để làm gì?",
      "options": [
        "Khai báo một khối code mới.",
        "Xử lý lỗi (exceptions) trong quá trình thực thi mã.",
        "Tạo một vòng lặp không ngừng.",
        "Định nghĩa một lớp (class)."
      ],
      "correctAnswer": 1
    },
    {
      "id": 105,
      "topicId": 3,
      "question": "Strict Mode trong JavaScript (`'use strict';`) có tác dụng gì?",
      "options": [
        "Buộc mã chạy nhanh hơn.",
        "Áp dụng các quy tắc nghiêm ngặt hơn cho JavaScript, giúp phát hiện lỗi phổ biến và tránh các hành vi 'silent fail'.",
        "Chỉ cho phép sử dụng các tính năng ES6 mới nhất.",
        "Bảo mật mã nguồn."
      ],
      "correctAnswer": 1
    },
    {
      "id": 106,
      "topicId": 3,
      "question": "Để chuyển đổi một chuỗi thành số nguyên trong JavaScript, bạn dùng hàm nào?",
      "options": [
        "parseFloat()",
        "parseInt()",
        "toNumber()",
        "stringToNumber()"
      ],
      "correctAnswer": 1
    },
    {
      "id": 107,
      "topicId": 3,
      "question": "Closures trong JavaScript là gì?",
      "options": [
        "Một hàm bên trong một hàm khác có thể truy cập các biến của hàm cha ngay cả sau khi hàm cha đã kết thúc thực thi.",
        "Một cách để đóng một hàm.",
        "Một loại lỗi trong JavaScript.",
        "Một cách để tạo các đối tượng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 108,
      "topicId": 3,
      "question": "Để tạo một đối tượng mới trong JavaScript, bạn dùng cú pháp nào?",
      "options": [
        "var obj = [];",
        "var obj = {};",
        "var obj = new Object();",
        "Cả B và C đều đúng"
      ],
      "correctAnswer": 3
    },
    {
      "id": 109,
      "topicId": 3,
      "question": "Phương thức nào của Array dùng để lọc các phần tử của mảng dựa trên một điều kiện nhất định và trả về một mảng mới?",
      "options": [
        "map()",
        "forEach()",
        "filter()",
        "some()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 110,
      "topicId": 3,
      "question": "Sự kiện nào xảy ra khi trang web hoàn tất việc tải tất cả các tài nguyên (bao gồm hình ảnh, CSS, JS)?",
      "options": [
        "DOMContentLoaded",
        "load",
        "ready",
        "onload"
      ],
      "correctAnswer": 1
    },
    {
      "id": 111,
      "topicId": 3,
      "question": "Prototype-based inheritance là gì trong JavaScript?",
      "options": [
        "Một mô hình kế thừa dựa trên các class",
        "Một mô hình kế thừa mà các đối tượng kế thừa các thuộc tính và phương thức từ các đối tượng khác thông qua thuộc tính prototype",
        "Một mô hình kế thừa chỉ dùng cho số",
        "Một cách để sao chép đối tượng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 112,
      "topicId": 3,
      "question": "Để lấy giá trị từ một trường input HTML, bạn sử dụng thuộc tính nào của đối tượng phần tử DOM?",
      "options": [
        ".text",
        ".html",
        ".value",
        ".content"
      ],
      "correctAnswer": 2
    },
    {
      "id": 113,
      "topicId": 3,
      "question": "Giao thức nào thường được dùng để gửi yêu cầu bất đồng bộ (AJAX) từ trình duyệt đến server?",
      "options": [
        "FTP",
        "SMTP",
        "HTTP/HTTPS",
        "TCP"
      ],
      "correctAnswer": 2
    },
    {
      "id": 114,
      "topicId": 3,
      "question": "Sự khác biệt giữa `null` và `undefined` trong JavaScript là gì?",
      "options": [
        "`null` là một giá trị không xác định, `undefined` là một giá trị rỗng được gán rõ ràng.",
        "`null` là một giá trị rỗng được gán rõ ràng, `undefined` là một giá trị không xác định.",
        "Không có sự khác biệt.",
        "Cả hai đều là lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 115,
      "topicId": 3,
      "question": "`this` keyword trong JavaScript đề cập đến cái gì?",
      "options": [
        "Luôn luôn là đối tượng window",
        "Đối tượng mà phương thức đang được gọi trên đó (ngữ cảnh thực thi)",
        "Đối tượng cha",
        "Một biến toàn cục"
      ],
      "correctAnswer": 1
    },
    {
      "id": 116,
      "topicId": 3,
      "question": "Sử dụng `async/await` trong JavaScript giúp xử lý các tác vụ bất đồng bộ như thế nào?",
      "options": [
        "Biến các tác vụ bất đồng bộ thành đồng bộ hoàn toàn.",
        "Làm cho mã bất đồng bộ trông giống như mã đồng bộ, dễ đọc và quản lý hơn.",
        "Chỉ dùng cho các hàm toán học.",
        "Chỉ hoạt động trong môi trường Node.js."
      ],
      "correctAnswer": 1
    },
    {
      "id": 117,
      "topicId": 3,
      "question": "Phương thức nào của Array dùng để kiểm tra xem ít nhất một phần tử trong mảng có thỏa mãn điều kiện được cung cấp không?",
      "options": [
        "every()",
        "filter()",
        "some()",
        "find()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 118,
      "topicId": 3,
      "question": "Spread operator (`...`) trong JavaScript dùng để làm gì?",
      "options": [
        "Chỉ dùng để nối chuỗi.",
        "Cho phép một iterable (như mảng hoặc chuỗi) được mở rộng thành các phần tử riêng lẻ, hoặc sao chép đối tượng/mảng.",
        "Giảm kích thước của mảng.",
        "Thêm một phần tử vào đầu mảng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 119,
      "topicId": 3,
      "question": "Global Scope trong JavaScript là gì?",
      "options": [
        "Phạm vi biến chỉ có thể truy cập bên trong một hàm.",
        "Phạm vi biến có thể truy cập từ bất kỳ đâu trong code.",
        "Phạm vi biến chỉ có thể truy cập trong một block code.",
        "Không tồn tại trong JavaScript."
      ],
      "correctAnswer": 1
    },
    {
      "id": 120,
      "topicId": 3,
      "question": "Để chuyển đổi một đối tượng JavaScript thành một chuỗi JSON, bạn dùng phương thức nào?",
      "options": [
        "JSON.parse()",
        "JSON.stringify()",
        "Object.toString()",
        "String.fromObject()"
      ],
      "correctAnswer": 1
    },
    {
      "id": 121,
      "topicId": 4,
      "question": "Trong React, JSX là viết tắt của từ gì?",
      "options": [
        "JavaScript XML",
        "JSON Xtension",
        "JavaScript eXtension",
        "Joint XML"
      ],
      "correctAnswer": 0
    },
    {
      "id": 122,
      "topicId": 4,
      "question": "Hook nào được dùng để quản lý state trong một component function của React?",
      "options": [
        "useEffect",
        "useContext",
        "useState",
        "useReducer"
      ],
      "correctAnswer": 2
    },
    {
      "id": 123,
      "topicId": 4,
      "question": "Trong React, để truyền dữ liệu từ component cha xuống component con, bạn sử dụng gì?",
      "options": [
        "State",
        "Context",
        "Props",
        "Refs"
      ],
      "correctAnswer": 2
    },
    {
      "id": 124,
      "topicId": 4,
      "question": "Phương thức vòng đời nào trong React Class Component được gọi sau khi component được render lần đầu tiên ra DOM?",
      "options": [
        "componentWillMount()",
        "componentDidMount()",
        "render()",
        "componentDidUpdate()"
      ],
      "correctAnswer": 1
    },
    {
      "id": 125,
      "topicId": 4,
      "question": "Để tối ưu hiệu năng render trong React khi state hoặc props thay đổi, bạn có thể sử dụng hook nào?",
      "options": [
        "useCallback",
        "useMemo",
        "useRef",
        "Cả A và B"
      ],
      "correctAnswer": 3
    },
    {
      "id": 126,
      "topicId": 4,
      "question": "Sự khác biệt cơ bản giữa Class Component và Function Component trong React là gì?",
      "options": [
        "Class Component không thể có state, Function Component thì có.",
        "Function Component nhanh hơn Class Component luôn luôn.",
        "Class Component dùng `this.state`, Function Component dùng hooks như `useState`.",
        "Class Component chỉ dùng được JSX, Function Component thì không."
      ],
      "correctAnswer": 2
    },
    {
      "id": 127,
      "topicId": 4,
      "question": "Khi nào bạn nên sử dụng `useEffect` hook với mảng dependency rỗng (`[]`)?",
      "options": [
        "Khi muốn chạy effect mỗi khi component render lại.",
        "Khi muốn chạy effect một lần duy nhất sau render đầu tiên, giống như `componentDidMount`.",
        "Khi muốn chạy effect khi bất kỳ state hoặc props nào thay đổi.",
        "Khi muốn dọn dẹp (cleanup) effect."
      ],
      "correctAnswer": 1
    },
    {
      "id": 128,
      "topicId": 4,
      "question": "Virtual DOM trong React có vai trò gì?",
      "options": [
        "Là một bản sao trực tiếp của DOM thật, được React sử dụng để so sánh và cập nhật hiệu quả.",
        "Là một cách để lưu trữ state của ứng dụng.",
        "Là nơi để viết mã HTML trong React.",
        "Là một công cụ debug cho React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 129,
      "topicId": 4,
      "question": "Props trong React là gì?",
      "options": [
        "Dữ liệu có thể thay đổi trong component.",
        "Dữ liệu được truyền từ component con lên component cha.",
        "Dữ liệu được truyền từ component cha xuống component con, không thể thay đổi bởi component con.",
        "Các hàm xử lý sự kiện trong component."
      ],
      "correctAnswer": 2
    },
    {
      "id": 130,
      "topicId": 4,
      "question": "Sự kiện nào được sử dụng để xử lý khi một người dùng nhấp vào một nút trong React?",
      "options": [
        "onclick",
        "onClick",
        "onMouseClick",
        "click"
      ],
      "correctAnswer": 1
    },
    {
      "id": 131,
      "topicId": 4,
      "question": "Trong React, `key` prop được dùng cho mục đích gì khi render danh sách các phần tử?",
      "options": [
        "Để style các phần tử",
        "Để React có thể nhận diện duy nhất và cập nhật hiệu quả các phần tử trong danh sách",
        "Để thêm các sự kiện lắng nghe",
        "Để truyền dữ liệu từ component cha"
      ],
      "correctAnswer": 1
    },
    {
      "id": 132,
      "topicId": 4,
      "question": "Cách nào sau đây là đúng để khai báo một component function trong React?",
      "options": [
        "function MyComponent extends React.Component {}",
        "class MyComponent extends Component {}",
        "const MyComponent = () => { return <div>Hello</div>; }",
        "var MyComponent = React.createClass();"
      ],
      "correctAnswer": 2
    },
    {
      "id": 133,
      "topicId": 4,
      "question": "Để thay đổi state trong một Class Component của React, bạn sử dụng phương thức nào?",
      "options": [
        "this.state.myValue = 'new value';",
        "this.setState({ myValue: 'new value' });",
        "setState({ myValue: 'new value' });",
        "this.updateState({ myValue: 'new value' });"
      ],
      "correctAnswer": 1
    },
    {
      "id": 134,
      "topicId": 4,
      "question": "Context API trong React được dùng để giải quyết vấn đề gì?",
      "options": [
        "Quản lý side effects",
        "Truyền props qua nhiều cấp độ component mà không cần truyền thủ công từng cấp",
        "Tối ưu hiệu năng render",
        "Xử lý các biểu mẫu"
      ],
      "correctAnswer": 1
    },
    {
      "id": 135,
      "topicId": 4,
      "question": "Fragments trong React (`<></>`) có tác dụng gì?",
      "options": [
        "Tạo ra một phần tử DOM mới",
        "Cho phép nhóm nhiều phần tử mà không thêm node DOM thừa vào cây DOM",
        "Định nghĩa các component con",
        "Phân chia code thành các gói nhỏ hơn"
      ],
      "correctAnswer": 1
    },
    {
      "id": 136,
      "topicId": 4,
      "question": "Làm thế nào để tạo một tham chiếu (ref) đến một phần tử DOM hoặc component trong React Function Component?",
      "options": [
        "this.refs.myElement",
        "React.createRef()",
        "useRef()",
        "ref={myElement}"
      ],
      "correctAnswer": 2
    },
    {
      "id": 137,
      "topicId": 4,
      "question": "Cơ chế 'reconciliation' trong React có ý nghĩa gì?",
      "options": [
        "Quá trình React so sánh Virtual DOM cũ và mới để xác định những thay đổi cần cập nhật lên DOM thật.",
        "Quá trình gọi API để lấy dữ liệu.",
        "Quá trình quản lý state của component.",
        "Quá trình biên dịch JSX thành JavaScript thuần."
      ],
      "correctAnswer": 0
    },
    {
      "id": 138,
      "topicId": 4,
      "question": "Higher-Order Components (HOCs) trong React là gì?",
      "options": [
        "Các component chỉ render các component con.",
        "Một hàm nhận vào một component và trả về một component mới với logic hoặc props bổ sung.",
        "Các component có nhiều state hơn các component khác.",
        "Component được render ở đầu ứng dụng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 139,
      "topicId": 4,
      "question": "Prop `children` trong React có vai trò gì?",
      "options": [
        "Là một đối tượng chứa tất cả các props khác.",
        "Là nội dung được truyền giữa các thẻ mở và đóng của một component.",
        "Là một hàm callback được gọi khi component render.",
        "Là một mảng các component con."
      ],
      "correctAnswer": 1
    },
    {
      "id": 140,
      "topicId": 4,
      "question": "Sử dụng `React.memo` cho Function Component có tác dụng gì?",
      "options": [
        "Buộc component phải render lại mỗi khi state thay đổi.",
        "Ngăn chặn component render lại nếu props của nó không thay đổi.",
        "Giúp component truy cập vào context.",
        "Thay đổi state bên trong component."
      ],
      "correctAnswer": 1
    },
    {
      "id": 141,
      "topicId": 4,
      "question": "ReactDOM.render() dùng để làm gì?",
      "options": [
        "Tạo một component mới.",
        "Render một React element vào một node DOM trong HTML.",
        "Cập nhật state của component.",
        "Xử lý các sự kiện."
      ],
      "correctAnswer": 1
    },
    {
      "id": 142,
      "topicId": 4,
      "question": "Để xử lý sự kiện form submit trong React, bạn nên làm gì để ngăn chặn hành vi mặc định của trình duyệt?",
      "options": [
        "Gọi `event.stopPropagation()`",
        "Gọi `event.preventDefault()`",
        "Đặt `return false;` trong hàm xử lý",
        "Xóa thuộc tính `action` khỏi form"
      ],
      "correctAnswer": 1
    },
    {
      "id": 143,
      "topicId": 4,
      "question": "Thư viện nào được sử dụng để định tuyến (routing) trong ứng dụng React (ví dụ: chuyển đổi giữa các trang)?",
      "options": [
        "Redux",
        "Axios",
        "React Router",
        "Styled Components"
      ],
      "correctAnswer": 2
    },
    {
      "id": 144,
      "topicId": 4,
      "question": "Ý nghĩa của State trong React là gì?",
      "options": [
        "Dữ liệu tĩnh không thay đổi.",
        "Dữ liệu có thể thay đổi theo thời gian và gây ra việc re-render component.",
        "Dữ liệu được truyền từ component cha.",
        "Một hàm được gọi khi component bị hủy."
      ],
      "correctAnswer": 1
    },
    {
      "id": 145,
      "topicId": 4,
      "question": "Làm thế nào để tạo một component trong React mà không có JSX?",
      "options": [
        "Không thể tạo được.",
        "Sử dụng `React.createElement()`.",
        "Sử dụng thẻ `<component>`.",
        "Chỉ với Class Components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 146,
      "topicId": 4,
      "question": "Hook `useReducer` trong React thường được dùng trong trường hợp nào?",
      "options": [
        "Để quản lý state đơn giản.",
        "Để quản lý state phức tạp hơn hoặc khi state logic phụ thuộc vào state trước đó.",
        "Để thực hiện các side effects.",
        "Để tối ưu hiệu năng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 147,
      "topicId": 4,
      "question": "Sự khác biệt giữa Controlled Components và Uncontrolled Components trong React là gì?",
      "options": [
        "Controlled Components quản lý state form thông qua React state, Uncontrolled Components thông qua DOM.",
        "Controlled Components không có state, Uncontrolled Components thì có.",
        "Controlled Components nhanh hơn Uncontrolled Components.",
        "Uncontrolled Components dễ debug hơn Controlled Components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 148,
      "topicId": 4,
      "question": "Server-Side Rendering (SSR) với React thường được thực hiện bằng cách nào?",
      "options": [
        "Chỉ sử dụng React Router.",
        "Sử dụng thư viện như Next.js hoặc Gatsby.js để render component React trên server.",
        "Chỉ dùng Webpack.",
        "Bằng cách sử dụng CDN."
      ],
      "correctAnswer": 1
    },
    {
      "id": 149,
      "topicId": 4,
      "question": "Để tối ưu hóa việc truyền props xuống sâu trong cây component, bạn có thể sử dụng giải pháp nào?",
      "options": [
        "props drilling",
        "Context API hoặc thư viện quản lý state toàn cục",
        "Chỉ dùng Class Components",
        "Không làm gì cả"
      ],
      "correctAnswer": 1
    },
    {
      "id": 150,
      "topicId": 4,
      "question": "Khi bạn thay đổi state trong React, điều gì xảy ra?",
      "options": [
        "Component sẽ bị hủy và tạo lại từ đầu.",
        "React sẽ so sánh state mới với state cũ và cập nhật DOM nếu có thay đổi (reconciliation).",
        "Trang web sẽ tự động tải lại.",
        "Dữ liệu được gửi đến server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 151,
      "topicId": 4,
      "question": "Synthetic Events trong React là gì?",
      "options": [
        "Các sự kiện DOM trực tiếp.",
        "Một trình bao bọc (wrapper) đa trình duyệt xung quanh các sự kiện gốc của trình duyệt.",
        "Các sự kiện tùy chỉnh được tạo bởi người dùng.",
        "Các sự kiện chỉ hoạt động trên thiết bị di động."
      ],
      "correctAnswer": 1
    },
    {
      "id": 152,
      "topicId": 4,
      "question": "Thư viện nào được sử dụng để tạo kiểu (styling) các component React bằng cách viết CSS trong JavaScript?",
      "options": [
        "Sass",
        "Styled Components",
        "Bootstrap",
        "Tailwind CSS"
      ],
      "correctAnswer": 1
    },
    {
      "id": 153,
      "topicId": 4,
      "question": "Portals trong React được dùng để làm gì?",
      "options": [
        "Để tạo các component có thể tái sử dụng.",
        "Để render children vào một node DOM không nằm trong hệ thống phân cấp DOM của component cha.",
        "Để quản lý state toàn cục.",
        "Để tạo các tuyến đường (routes)."
      ],
      "correctAnswer": 1
    },
    {
      "id": 154,
      "topicId": 4,
      "question": "Khi nào bạn nên sử dụng `useCallback` hook?",
      "options": [
        "Khi bạn muốn component render lại nhanh hơn.",
        "Khi bạn muốn ghi nhớ một hàm để ngăn nó tạo lại mỗi khi component re-render, giúp tối ưu hóa props cho component con.",
        "Khi bạn muốn thực hiện các side effects.",
        "Khi bạn muốn quản lý state phức tạp."
      ],
      "correctAnswer": 1
    },
    {
      "id": 155,
      "topicId": 4,
      "question": "Error Boundaries trong React được dùng để làm gì?",
      "options": [
        "Bắt lỗi JavaScript ở bất kỳ đâu trong ứng dụng.",
        "Bắt lỗi JavaScript trong cây component con của chúng và hiển thị giao diện người dùng dự phòng.",
        "Ngăn chặn lỗi xảy ra.",
        "Ghi log tất cả các lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 156,
      "topicId": 4,
      "question": "Render Props là một kỹ thuật nào trong React?",
      "options": [
        "Truyền một component làm prop.",
        "Truyền một hàm làm prop để component con quyết định những gì cần render.",
        "Chỉ render các props.",
        "Một cách để render các component từ server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 157,
      "topicId": 4,
      "question": "Pure Components (Class Component) và `React.memo` (Function Component) hoạt động dựa trên nguyên tắc nào để tối ưu hiệu năng?",
      "options": [
        "Luôn re-render.",
        "Chỉ re-render khi state hoặc props thay đổi nông (shallow comparison).",
        "Không bao giờ re-render.",
        "Kiểm tra sâu (deep comparison) mọi props."
      ],
      "correctAnswer": 1
    },
    {
      "id": 158,
      "topicId": 4,
      "question": "Trong React, 'Component Lifecycle' đề cập đến điều gì?",
      "options": [
        "Quá trình một component được tạo ra, cập nhật và bị hủy bỏ trong suốt vòng đời của nó.",
        "Cách một component tương tác với API.",
        "Cách component được style.",
        "Cách component quản lý state."
      ],
      "correctAnswer": 0
    },
    {
      "id": 159,
      "topicId": 4,
      "question": "Custom Hooks trong React là gì?",
      "options": [
        "Các hook được React cung cấp sẵn.",
        "Các hàm JavaScript thông thường sử dụng các hook React để đóng gói logic có thể tái sử dụng.",
        "Các hook chỉ dùng cho Class Components.",
        "Các hook chỉ dùng để render UI."
      ],
      "correctAnswer": 1
    },
    {
      "id": 160,
      "topicId": 4,
      "question": "Để điều hướng chương trình (programmatic navigation) trong React Router, bạn sử dụng hook nào?",
      "options": [
        "useParams",
        "useLocation",
        "useHistory (trước React Router v6) hoặc useNavigate (React Router v6+)",
        "useRouteMatch"
      ],
      "correctAnswer": 2
    },
    {
      "id": 161,
      "topicId": 5,
      "question": "Kỹ thuật nào giúp giảm thiểu kích thước tệp JavaScript và CSS để tăng tốc độ tải trang?",
      "options": [
        "Obfuscation",
        "Minification",
        "Transpilation",
        "Polyfilling"
      ],
      "correctAnswer": 1
    },
    {
      "id": 162,
      "topicId": 5,
      "question": "Khái niệm 'Lazy Loading' trong phát triển frontend có ý nghĩa gì?",
      "options": [
        "Tải toàn bộ tài nguyên khi trang web được mở",
        "Chỉ tải các tài nguyên khi chúng thực sự cần thiết (ví dụ: hình ảnh khi cuộn tới)",
        "Tải tài nguyên theo thứ tự abc",
        "Tải tài nguyên dựa trên tốc độ mạng của người dùng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 163,
      "topicId": 5,
      "question": "CDN (Content Delivery Network) được sử dụng để làm gì trong kiến trúc frontend?",
      "options": [
        "Quản lý cơ sở dữ liệu backend",
        "Phân phối nội dung tĩnh (như hình ảnh, CSS, JS) từ các máy chủ gần người dùng nhất",
        "Xác thực người dùng",
        "Chạy code JavaScript phía server"
      ],
      "correctAnswer": 1
    },
    {
      "id": 164,
      "topicId": 5,
      "question": "Kỹ thuật nào giúp tránh render lại các component không cần thiết trong React để cải thiện hiệu năng?",
      "options": [
        "Server-Side Rendering (SSR)",
        "Static Site Generation (SSG)",
        "Memoization (ví dụ: React.memo, useMemo)",
        "Code Splitting"
      ],
      "correctAnswer": 2
    },
    {
      "id": 165,
      "topicId": 5,
      "question": "Web Workers trong JavaScript được dùng để làm gì?",
      "options": [
        "Thực hiện các tác vụ nặng trên luồng chính (main thread) của trình duyệt",
        "Chạy các tác vụ JavaScript trong một luồng nền (background thread) riêng biệt",
        "Xử lý các yêu cầu HTTP",
        "Quản lý DOM"
      ],
      "correctAnswer": 1
    },
    {
      "id": 166,
      "topicId": 5,
      "question": "SSR (Server-Side Rendering) có lợi ích chính gì cho frontend?",
      "options": [
        "Tăng tốc độ tương tác sau khi tải trang",
        "Cải thiện SEO và thời gian hiển thị nội dung đầu tiên",
        "Giảm kích thước bundle JavaScript",
        "Cho phép ứng dụng hoạt động offline"
      ],
      "correctAnswer": 1
    },
    {
      "id": 167,
      "topicId": 5,
      "question": "Code Splitting là gì trong context tối ưu hiệu năng frontend?",
      "options": [
        "Chia code thành nhiều file nhỏ để dễ quản lý",
        "Phân chia code thành các gói nhỏ hơn để tải theo yêu cầu, giảm thời gian tải ban đầu",
        "Loại bỏ các dòng code không sử dụng",
        "Mã hóa code để bảo mật"
      ],
      "correctAnswer": 1
    },
    {
      "id": 168,
      "topicId": 5,
      "question": "Caching (Bộ nhớ đệm) trên trình duyệt có vai trò gì trong việc cải thiện hiệu năng tải trang?",
      "options": [
        "Lưu trữ tạm thời các tài nguyên (như CSS, JS, hình ảnh) để không phải tải lại chúng ở các lần truy cập sau",
        "Giúp xử lý các yêu cầu backend nhanh hơn",
        "Mã hóa dữ liệu truyền tải",
        "Tối ưu hóa các truy vấn cơ sở dữ liệu"
      ],
      "correctAnswer": 0
    },
    {
      "id": 169,
      "topicId": 5,
      "question": "Sự khác biệt giữa SSR và CSR (Client-Side Rendering) là gì?",
      "options": [
        "SSR render trên trình duyệt, CSR render trên server.",
        "SSR render trên server, CSR render trên trình duyệt.",
        "SSR chỉ dành cho ứng dụng nhỏ, CSR cho ứng dụng lớn.",
        "SSR chỉ dùng JavaScript, CSR dùng HTML/CSS."
      ],
      "correctAnswer": 1
    },
    {
      "id": 170,
      "topicId": 5,
      "question": "Metrics nào sau đây được sử dụng để đo lường thời gian từ khi trang bắt đầu tải cho đến khi nội dung chính hiển thị (thường là một phần của Core Web Vitals)?",
      "options": [
        "Time to Interactive (TTI)",
        "First Contentful Paint (FCP)",
        "Largest Contentful Paint (LCP)",
        "Cumulative Layout Shift (CLS)"
      ],
      "correctAnswer": 2
    },
    {
      "id": 171,
      "topicId": 5,
      "question": "Progressive Web Apps (PWAs) là gì?",
      "options": [
        "Ứng dụng web được xây dựng bằng công nghệ flash",
        "Ứng dụng web có thể cài đặt và hoạt động offline như ứng dụng native",
        "Ứng dụng web chỉ dành cho lập trình viên",
        "Ứng dụng web chỉ hoạt động trên một loại trình duyệt cụ thể"
      ],
      "correctAnswer": 1
    },
    {
      "id": 172,
      "topicId": 5,
      "question": "Service Workers trong PWA được sử dụng cho mục đích chính là gì?",
      "options": [
        "Đồng bộ hóa dữ liệu với backend",
        "Quản lý push notifications và caching tài nguyên để hoạt động offline",
        "Tạo hiệu ứng động trên giao diện",
        "Phân tích dữ liệu người dùng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 173,
      "topicId": 5,
      "question": "Kỹ thuật 'tree shaking' trong JavaScript có ý nghĩa gì đối với hiệu năng?",
      "options": [
        "Giảm kích thước DOM tree",
        "Loại bỏ code không sử dụng (dead code) khỏi bundle cuối cùng",
        "Sắp xếp lại cấu trúc thư mục dự án",
        "Tối ưu hóa các truy vấn API"
      ],
      "correctAnswer": 1
    },
    {
      "id": 174,
      "topicId": 5,
      "question": "Preloading và Prefetching là các kỹ thuật nhằm mục đích gì?",
      "options": [
        "Làm chậm quá trình tải trang",
        "Tải trước các tài nguyên cần thiết cho trang hiện tại hoặc các trang sắp tới",
        "Tăng cường bảo mật cho trang web",
        "Chỉ dành cho hình ảnh và video"
      ],
      "correctAnswer": 1
    },
    {
      "id": 175,
      "topicId": 5,
      "question": "WebAssembly (Wasm) được sử dụng để làm gì trong frontend?",
      "options": [
        "Viết code CSS hiệu quả hơn",
        "Cho phép chạy mã hiệu suất cao (ví dụ: từ C++, Rust) trong trình duyệt web",
        "Tạo các hiệu ứng 3D phức tạp",
        "Quản lý state của ứng dụng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 176,
      "topicId": 5,
      "question": "Kỹ thuật nào dùng để tối ưu hóa việc tải hình ảnh bằng cách chỉ tải phần hình ảnh hiển thị trên màn hình hiện tại?",
      "options": [
        "Eager loading",
        "Progressive loading",
        "Lazy loading",
        "Inline loading"
      ],
      "correctAnswer": 2
    },
    {
      "id": 177,
      "topicId": 5,
      "question": "Critical CSS là gì?",
      "options": [
        "Toàn bộ CSS của trang web",
        "CSS cần thiết để render nội dung ở 'above the fold' (phần đầu trang hiển thị mà không cần cuộn)",
        "CSS dành riêng cho thiết bị di động",
        "CSS chứa các lỗi quan trọng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 178,
      "topicId": 5,
      "question": "Web Vitals là một sáng kiến của Google nhằm mục đích gì?",
      "options": [
        "Cung cấp các metrics thống nhất để đo lường trải nghiệm người dùng trên web",
        "Phát triển các công cụ biên dịch JavaScript",
        "Xây dựng các framework frontend mới",
        "Thiết lập các tiêu chuẩn bảo mật web"
      ],
      "correctAnswer": 0
    },
    {
      "id": 179,
      "topicId": 5,
      "question": "Sự khác biệt giữa render blocking resources và non-render blocking resources là gì?",
      "options": [
        "Render blocking resources chặn quá trình render trang, non-render blocking resources không chặn.",
        "Render blocking resources chỉ dùng cho JavaScript, non-render blocking resources chỉ dùng cho CSS.",
        "Render blocking resources luôn tải nhanh hơn.",
        "Không có sự khác biệt về hiệu suất."
      ],
      "correctAnswer": 0
    },
    {
      "id": 180,
      "topicId": 5,
      "question": "Thẻ `<link rel='preload'>` được dùng để làm gì?",
      "options": [
        "Để tải tài nguyên sau khi trang đã render.",
        "Để tải trước tài nguyên quan trọng cho trang hiện tại càng sớm càng tốt.",
        "Để ngăn chặn tài nguyên tải về.",
        "Để tải tài nguyên chỉ trên các thiết bị di động."
      ],
      "correctAnswer": 1
    },
    {
      "id": 181,
      "topicId": 5,
      "question": "Mục đích của bộ nhớ đệm (cache) trong trình duyệt là gì?",
      "options": [
        "Lưu trữ dữ liệu nhạy cảm của người dùng.",
        "Giảm số lượng yêu cầu đến server bằng cách lưu trữ các bản sao tài nguyên cục bộ.",
        "Mã hóa các yêu cầu HTTP.",
        "Thực hiện tính toán phức tạp."
      ],
      "correctAnswer": 1
    },
    {
      "id": 182,
      "topicId": 5,
      "question": "Kỹ thuật 'image optimization' (tối ưu hóa hình ảnh) bao gồm những gì?",
      "options": [
        "Tăng kích thước tệp hình ảnh.",
        "Giảm kích thước tệp, chọn định dạng phù hợp, và nén hình ảnh mà không làm giảm đáng kể chất lượng.",
        "Chỉ sử dụng hình ảnh vector.",
        "Tạo ra hình ảnh động."
      ],
      "correctAnswer": 1
    },
    {
      "id": 183,
      "topicId": 5,
      "question": "Làm thế nào để đo lường hiệu năng của một trang web?",
      "options": [
        "Chỉ bằng cách nhìn vào trang web.",
        "Sử dụng các công cụ như Lighthouse, PageSpeed Insights, WebPageTest.",
        "Chỉ bằng cách đếm số dòng code.",
        "Không thể đo lường được."
      ],
      "correctAnswer": 1
    },
    {
      "id": 184,
      "topicId": 5,
      "question": "Kỹ thuật 'Long-Term Caching' (bộ nhớ đệm dài hạn) thường được thực hiện như thế nào trong frontend?",
      "options": [
        "Sử dụng expires header ngắn.",
        "Sử dụng cache-control headers với thời gian sống dài và đặt tên tệp dựa trên hash nội dung (content hashing).",
        "Không sử dụng cache.",
        "Chỉ cache các tệp HTML."
      ],
      "correctAnswer": 1
    },
    {
      "id": 185,
      "topicId": 5,
      "question": "Kỹ thuật 'Tree Shaking' đặc biệt hữu ích cho các dự án sử dụng:",
      "options": [
        "JQuery",
        "React",
        "TypeScript",
        "ES Modules (ESM)"
      ],
      "correctAnswer": 3
    },
    {
      "id": 186,
      "topicId": 5,
      "question": "Mục đích của Webpack Code Splitting là gì?",
      "options": [
        "Giảm tổng kích thước của JavaScript bundle",
        "Chia nhỏ bundle JavaScript thành các chunk nhỏ hơn để tải theo yêu cầu, cải thiện thời gian tải ban đầu",
        "Mã hóa các tệp JavaScript",
        "Tối ưu hóa hình ảnh"
      ],
      "correctAnswer": 1
    },
    {
      "id": 187,
      "topicId": 5,
      "question": "Progressive Rendering là gì?",
      "options": [
        "Render toàn bộ trang cùng một lúc.",
        "Hiển thị nội dung trang theo từng giai đoạn, ưu tiên phần hiển thị đầu tiên.",
        "Chỉ render các phần tử động.",
        "Chỉ render trên server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 188,
      "topicId": 5,
      "question": "Sự khác biệt giữa First Contentful Paint (FCP) và Largest Contentful Paint (LCP) là gì?",
      "options": [
        "FCP là thời gian hiển thị văn bản đầu tiên, LCP là thời gian tương tác đầu tiên.",
        "FCP là thời gian hiển thị nội dung đầu tiên, LCP là thời gian hiển thị phần tử nội dung lớn nhất trên màn hình.",
        "FCP chỉ đo lường CSS, LCP đo lường JavaScript.",
        "Không có sự khác biệt đáng kể."
      ],
      "correctAnswer": 1
    },
    {
      "id": 189,
      "topicId": 5,
      "question": "Kỹ thuật 'Resource Hints' (e.g., `dns-prefetch`, `preconnect`) dùng để làm gì?",
      "options": [
        "Tăng cường bảo mật cho kết nối.",
        "Cung cấp gợi ý cho trình duyệt để tối ưu hóa việc tải tài nguyên trong tương lai.",
        "Buộc trình duyệt tải tất cả tài nguyên ngay lập tức.",
        "Giảm dung lượng dữ liệu."
      ],
      "correctAnswer": 1
    },
    {
      "id": 190,
      "topicId": 5,
      "question": "WebP là định dạng hình ảnh được khuyến nghị cho web vì lý do gì?",
      "options": [
        "Dễ dàng chỉnh sửa.",
        "Kích thước tệp nhỏ hơn mà vẫn giữ chất lượng tốt hơn JPEG/PNG.",
        "Hỗ trợ hoạt ảnh động.",
        "Là định dạng duy nhất được tất cả trình duyệt hỗ trợ."
      ],
      "correctAnswer": 1
    },
    {
      "id": 191,
      "topicId": 5,
      "question": "Cumulative Layout Shift (CLS) trong Core Web Vitals đo lường điều gì?",
      "options": [
        "Thời gian tải JavaScript.",
        "Mức độ ổn định của bố cục trang khi tải (tránh các dịch chuyển đột ngột của nội dung).",
        "Số lượng phần tử trên trang.",
        "Thời gian phản hồi của server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 192,
      "topicId": 5,
      "question": "Kỹ thuật 'font optimization' (tối ưu hóa font) bao gồm những gì?",
      "options": [
        "Sử dụng nhiều font chữ nhất có thể.",
        "Giảm kích thước tệp font, tải font không đồng bộ, và sử dụng `font-display`.",
        "Chỉ sử dụng font chữ mặc định của hệ thống.",
        "Mã hóa các tệp font."
      ],
      "correctAnswer": 1
    },
    {
      "id": 193,
      "topicId": 5,
      "question": "Critical Request Chain (Chuỗi yêu cầu quan trọng) là gì?",
      "options": [
        "Danh sách tất cả các yêu cầu mạng.",
        "Một chuỗi các tài nguyên có phụ thuộc làm ảnh hưởng đến thời gian tải và hiển thị trang.",
        "Các yêu cầu API quan trọng nhất.",
        "Chuỗi các sự kiện người dùng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 194,
      "topicId": 5,
      "question": "Làm thế nào để giảm thiểu số lượng HTTP requests trong frontend?",
      "options": [
        "Sử dụng nhiều tệp CSS và JS riêng lẻ.",
        "Kết hợp các tệp CSS/JS thành một, sử dụng sprites cho hình ảnh, và inline các tài nguyên nhỏ.",
        "Không sử dụng hình ảnh.",
        "Luôn tải lại trang."
      ],
      "correctAnswer": 1
    },
    {
      "id": 195,
      "topicId": 5,
      "question": "Kỹ thuật 'Service-Side Rendering' (SSR) có thể giúp cải thiện SEO như thế nào?",
      "options": [
        "Bằng cách làm cho trang tải chậm hơn.",
        "Bằng cách cung cấp nội dung đã render HTML hoàn chỉnh cho các bot của công cụ tìm kiếm.",
        "Bằng cách chỉ sử dụng JavaScript.",
        "Bằng cách ngăn chặn các bot truy cập trang."
      ],
      "correctAnswer": 1
    },
    {
      "id": 196,
      "topicId": 5,
      "question": "Mục đích của việc sử dụng các công cụ phân tích bundle (bundle analyzer) là gì?",
      "options": [
        "Để nén các tệp JavaScript.",
        "Để trực quan hóa kích thước và nội dung của JavaScript bundle, giúp xác định các phần có thể tối ưu.",
        "Để biên dịch mã.",
        "Để chạy các bài kiểm thử."
      ],
      "correctAnswer": 1
    },
    {
      "id": 197,
      "topicId": 5,
      "question": "Làm thế nào để giảm 'First Input Delay' (FID) trong Core Web Vitals?",
      "options": [
        "Giảm thiểu công việc trên luồng chính của trình duyệt trong quá trình khởi tạo.",
        "Tăng số lượng yêu cầu API.",
        "Thêm nhiều hình ảnh động.",
        "Sử dụng nhiều font chữ tùy chỉnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 198,
      "topicId": 5,
      "question": "Kỹ thuật 'throttling' và 'debouncing' thường được dùng để làm gì trong frontend?",
      "options": [
        "Tăng tần suất gọi hàm.",
        "Giảm tần suất gọi hàm xử lý sự kiện để cải thiện hiệu suất.",
        "Kiểm tra lỗi mã.",
        "Làm chậm tốc độ tải trang."
      ],
      "correctAnswer": 1
    },
    {
      "id": 199,
      "topicId": 5,
      "question": "Performance Budget (Ngân sách hiệu năng) là gì?",
      "options": [
        "Số tiền được phân bổ cho việc tối ưu hiệu năng.",
        "Một tập hợp các giới hạn về hiệu năng (ví dụ: kích thước JavaScript, thời gian tải) mà dự án phải tuân thủ.",
        "Thời gian tối đa để hoàn thành một tác vụ.",
        "Lợi nhuận từ việc cải thiện hiệu năng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 200,
      "topicId": 5,
      "question": "Sự khác biệt giữa 'Optimistic UI' và 'Pessimistic UI' trong quản lý state khi gọi API?",
      "options": [
        "Optimistic UI cập nhật UI trước khi nhận phản hồi từ server, Pessimistic UI đợi phản hồi rồi mới cập nhật.",
        "Optimistic UI chậm hơn Pessimistic UI.",
        "Optimistic UI chỉ dùng cho GET requests.",
        "Pessimistic UI không xử lý lỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 201,
      "topicId": 6,
      "question": "Công cụ nào thường được dùng để quản lý các gói thư viện (packages) cho dự án Node.js và frontend?",
      "options": [
        "Git",
        "Webpack",
        "npm (Node Package Manager)",
        "Babel"
      ],
      "correctAnswer": 2
    },
    {
      "id": 202,
      "topicId": 6,
      "question": "Webpack được sử dụng phổ biến trong frontend với mục đích chính là gì?",
      "options": [
        "Kiểm soát phiên bản code",
        "Gộp và đóng gói các tệp module (module bundler)",
        "Quản lý cơ sở dữ liệu",
        "Chạy thử nghiệm tự động"
      ],
      "correctAnswer": 1
    },
    {
      "id": 203,
      "topicId": 6,
      "question": "Babel là một công cụ giúp các nhà phát triển JavaScript làm gì?",
      "options": [
        "Nén mã JavaScript",
        "Chuyển đổi mã JavaScript hiện đại (ES6+) sang phiên bản tương thích với các trình duyệt cũ hơn",
        "Kiểm tra lỗi cú pháp",
        "Quản lý phụ thuộc"
      ],
      "correctAnswer": 1
    },
    {
      "id": 204,
      "topicId": 6,
      "question": "Công cụ nào sau đây thường được dùng để quản lý phiên bản mã nguồn (version control)?",
      "options": [
        "Docker",
        "Jira",
        "Git",
        "Slack"
      ],
      "correctAnswer": 2
    },
    {
      "id": 205,
      "topicId": 6,
      "question": "ESLint là một công cụ phổ biến trong frontend dùng để làm gì?",
      "options": [
        "Biên dịch mã CSS",
        "Phân tích tĩnh mã JavaScript để tìm lỗi và enforce quy tắc viết code (linting)",
        "Quản lý trạng thái ứng dụng",
        "Thực hiện các tác vụ tự động hóa xây dựng dự án"
      ],
      "correctAnswer": 1
    },
    {
      "id": 206,
      "topicId": 6,
      "question": "Tạo môi trường phát triển nhất quán và cô lập cho các ứng dụng bằng công cụ nào?",
      "options": [
        "Nginx",
        "Docker",
        "Ansible",
        "Kubernetes"
      ],
      "correctAnswer": 1
    },
    {
      "id": 207,
      "topicId": 6,
      "question": "Prettier là một công cụ phổ biến dùng để làm gì trong phát triển frontend?",
      "options": [
        "Tối ưu hóa hình ảnh",
        "Định dạng code tự động để đảm bảo nhất quán về phong cách",
        "Kiểm tra lỗi cú pháp JavaScript",
        "Tạo tài liệu API tự động"
      ],
      "correctAnswer": 1
    },
    {
      "id": 208,
      "topicId": 6,
      "question": "TypeScript là gì?",
      "options": [
        "Một ngôn ngữ lập trình chỉ dùng cho backend",
        "Một superset của JavaScript thêm tính năng static typing (kiểu tĩnh)",
        "Một thư viện UI cho React",
        "Một công cụ để nén mã JavaScript"
      ],
      "correctAnswer": 1
    },
    {
      "id": 209,
      "topicId": 6,
      "question": "CI/CD trong quy trình phát triển phần mềm có ý nghĩa gì?",
      "options": [
        "Chỉ Continuous Integration (Tích hợp liên tục)",
        "Continuous Integration (Tích hợp liên tục) và Continuous Delivery/Deployment (Phân phối/Triển khai liên tục)",
        "Code Inspection / Code Debugging",
        "Client-side Integration / Server-side Deployment"
      ],
      "correctAnswer": 1
    },
    {
      "id": 210,
      "topicId": 6,
      "question": "Công cụ nào sau đây là một task runner phổ biến dùng để tự động hóa các tác vụ lặp đi lặp lại trong quá trình phát triển (ví dụ: nén file, biên dịch Sass)?",
      "options": [
        "npm",
        "Yarn",
        "Gulp",
        "Webpack"
      ],
      "correctAnswer": 2
    },
    {
      "id": 211,
      "topicId": 6,
      "question": "Làm thế nào để khởi tạo một dự án Node.js mới với `npm`?",
      "options": [
        "npm create",
        "npm start",
        "npm init",
        "npm build"
      ],
      "correctAnswer": 2
    },
    {
      "id": 212,
      "topicId": 6,
      "question": "Vite là một build tool frontend mới nổi, điểm mạnh của nó so với Webpack là gì?",
      "options": [
        "Chỉ hỗ trợ React",
        "Sử dụng Native ES Modules để khởi động máy chủ phát triển nhanh hơn",
        "Yêu cầu cấu hình phức tạp hơn",
        "Không hỗ trợ hot-module replacement"
      ],
      "correctAnswer": 1
    },
    {
      "id": 213,
      "topicId": 6,
      "question": "PostCSS là một công cụ dùng để làm gì trong CSS?",
      "options": [
        "Giảm kích thước tệp CSS",
        "Chuyển đổi CSS hiện đại thành CSS tương thích với các trình duyệt cũ hơn bằng cách sử dụng các plugin",
        "Tạo animation trong CSS",
        "Quản lý các biến CSS"
      ],
      "correctAnswer": 1
    },
    {
      "id": 214,
      "topicId": 6,
      "question": "Yarn là một thay thế cho công cụ nào để quản lý các gói JavaScript?",
      "options": [
        "Git",
        "Webpack",
        "npm",
        "Babel"
      ],
      "correctAnswer": 2
    },
    {
      "id": 215,
      "topicId": 6,
      "question": "Công cụ nào sau đây cho phép bạn viết CSS với các tính năng mở rộng như biến, mixin, và các hàm logic?",
      "options": [
        "LESS",
        "Sass",
        "Stylus",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 3
    },
    {
      "id": 216,
      "topicId": 6,
      "question": "Code Sandbox hoặc CodePen là gì?",
      "options": [
        "Các công cụ để quản lý cơ sở dữ liệu.",
        "Các môi trường phát triển trực tuyến cho phép viết, chạy và chia sẻ code frontend nhanh chóng.",
        "Các thư viện JavaScript để tạo animation.",
        "Các công cụ để kiểm tra bảo mật website."
      ],
      "correctAnswer": 1
    },
    {
      "id": 217,
      "topicId": 6,
      "question": "NPM scripts trong file `package.json` dùng để làm gì?",
      "options": [
        "Chỉ để cài đặt dependencies.",
        "Để định nghĩa và chạy các lệnh tùy chỉnh trong dự án.",
        "Để cấu hình server backend.",
        "Để tạo ra các báo cáo lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 218,
      "topicId": 6,
      "question": "Thư viện nào phổ biến cho việc tạo ra các giao diện người dùng (UI components) đẹp và dễ tùy chỉnh trong React?",
      "options": [
        "Lodash",
        "Axios",
        "Material-UI (MUI)",
        "React Router"
      ],
      "correctAnswer": 2
    },
    {
      "id": 219,
      "topicId": 6,
      "question": "Git `rebase` khác gì so với `merge`?",
      "options": [
        "`rebase` tạo một commit mới cho mỗi lần hợp nhất, `merge` thì không.",
        "`rebase` di chuyển hoặc kết hợp các commit để tạo lịch sử tuyến tính, `merge` tạo một commit hợp nhất.",
        "`rebase` chỉ dùng cho branch chính, `merge` dùng cho branch phụ.",
        "Cả hai đều làm điều tương tự nhưng tên khác nhau."
      ],
      "correctAnswer": 1
    },
    {
      "id": 220,
      "topicId": 6,
      "question": "Linter là gì trong bối cảnh phát triển phần mềm?",
      "options": [
        "Công cụ để nén mã nguồn.",
        "Công cụ phân tích tĩnh mã để tìm lỗi cú pháp, lỗi phong cách và các vấn đề tiềm ẩn.",
        "Công cụ để triển khai ứng dụng.",
        "Công cụ để quản lý dự án."
      ],
      "correctAnswer": 1
    },
    {
      "id": 221,
      "topicId": 6,
      "question": "Bundler (ví dụ: Webpack, Rollup) trong frontend có nhiệm vụ chính là gì?",
      "options": [
        "Quản lý database.",
        "Gộp các module và tài nguyên thành các tệp tối ưu để phân phối cho trình duyệt.",
        "Kiểm tra lỗi ngữ pháp.",
        "Thiết kế giao diện người dùng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 222,
      "topicId": 6,
      "question": "Husky là một công cụ Git hook thường được sử dụng để làm gì?",
      "options": [
        "Gửi email tự động.",
        "Chạy các script (ví dụ: lint, test) trước khi commit hoặc push code.",
        "Tạo ra các branch mới.",
        "Phục hồi các thay đổi đã mất."
      ],
      "correctAnswer": 1
    },
    {
      "id": 223,
      "topicId": 6,
      "question": "Package manager nào của Node.js sử dụng file `yarn.lock`?",
      "options": [
        "npm",
        "pnpm",
        "yarn",
        "bower"
      ],
      "correctAnswer": 2
    },
    {
      "id": 224,
      "topicId": 6,
      "question": "Cấu hình `tsconfig.json` được sử dụng cho công cụ nào?",
      "options": [
        "Webpack",
        "Babel",
        "TypeScript",
        "ESLint"
      ],
      "correctAnswer": 2
    },
    {
      "id": 225,
      "topicId": 6,
      "question": "Code formatter (ví dụ: Prettier) giúp gì cho quá trình phát triển nhóm?",
      "options": [
        "Giảm thời gian tải trang.",
        "Đảm bảo mã nguồn có phong cách nhất quán giữa các thành viên, giảm xung đột khi hợp nhất code.",
        "Tìm và sửa lỗi logic.",
        "Tạo ra tài liệu tự động."
      ],
      "correctAnswer": 1
    },
    {
      "id": 226,
      "topicId": 6,
      "question": "VS Code Extensions nào phổ biến giúp tăng năng suất cho lập trình viên frontend?",
      "options": [
        "Prettier, ESLint, Live Server, Auto Rename Tag",
        "Microsoft Word, Excel",
        "Photoshop, GIMP",
        "Unity, Unreal Engine"
      ],
      "correctAnswer": 0
    },
    {
      "id": 227,
      "topicId": 6,
      "question": "Nodemon là một công cụ Node.js được dùng để làm gì?",
      "options": [
        "Chỉ chạy server production.",
        "Tự động khởi động lại ứng dụng Node.js khi phát hiện thay đổi trong tệp mã nguồn.",
        "Gói các module Node.js.",
        "Kiểm tra tính bảo mật của ứng dụng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 228,
      "topicId": 6,
      "question": "Tạo một bản dựng (build) production của ứng dụng frontend thường bao gồm các bước nào?",
      "options": [
        "Chỉ sao chép các tệp mã nguồn.",
        "Minification, uglification, code splitting, tree shaking, và tối ưu hóa tài nguyên.",
        "Chỉ cài đặt dependencies.",
        "Chạy server phát triển."
      ],
      "correctAnswer": 1
    },
    {
      "id": 229,
      "topicId": 6,
      "question": "Sass và Less là gì?",
      "options": [
        "Các framework JavaScript.",
        "Các preprocessor CSS, cho phép viết CSS với các tính năng nâng cao (biến, mixin, lồng ghép).",
        "Các công cụ kiểm thử.",
        "Các thư viện quản lý state."
      ],
      "correctAnswer": 1
    },
    {
      "id": 230,
      "topicId": 6,
      "question": "Terminal/Command Line Interface (CLI) là gì?",
      "options": [
        "Một công cụ để thiết kế giao diện đồ họa.",
        "Một giao diện dựa trên văn bản để tương tác với hệ điều hành bằng các lệnh.",
        "Một ngôn ngữ lập trình.",
        "Một trình duyệt web."
      ],
      "correctAnswer": 1
    },
    {
      "id": 231,
      "topicId": 6,
      "question": "File `package-lock.json` (hoặc `yarn.lock`) có vai trò gì trong dự án Node.js?",
      "options": [
        "Chỉ định phiên bản JavaScript được sử dụng.",
        "Khóa các phiên bản dependency đã được cài đặt để đảm bảo tính nhất quán giữa các môi trường.",
        "Lưu trữ mã nguồn dự án.",
        "Cấu hình server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 232,
      "topicId": 6,
      "question": "NPM `devDependencies` là gì?",
      "options": [
        "Các gói thư viện cần thiết cho ứng dụng khi chạy trong môi trường production.",
        "Các gói thư viện chỉ cần thiết trong quá trình phát triển và kiểm thử.",
        "Các gói thư viện do người dùng phát triển.",
        "Các gói thư viện có lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 233,
      "topicId": 6,
      "question": "Công cụ nào trong Git dùng để hủy bỏ các thay đổi cục bộ chưa được commit?",
      "options": [
        "git commit",
        "git push",
        "git pull",
        "git reset --hard / git clean"
      ],
      "correctAnswer": 3
    },
    {
      "id": 234,
      "topicId": 6,
      "question": "BrowserSync là một công cụ giúp gì cho quá trình phát triển frontend?",
      "options": [
        "Đồng bộ hóa các thay đổi trình duyệt với server.",
        "Tự động làm mới trình duyệt và đồng bộ hóa các tương tác (cuộn, click) trên nhiều thiết bị.",
        "Kiểm tra lỗi CSS.",
        "Tạo ra các báo cáo hiệu suất."
      ],
      "correctAnswer": 1
    },
    {
      "id": 235,
      "topicId": 6,
      "question": "Headless browser (ví dụ: Puppeteer, Playwright) được dùng cho mục đích gì?",
      "options": [
        "Để duyệt web mà không có giao diện người dùng.",
        "Để chạy các bài kiểm thử tự động, crawl dữ liệu hoặc tạo PDF.",
        "Để thiết kế giao diện đồ họa.",
        "Chỉ dùng cho backend."
      ],
      "correctAnswer": 1
    },
    {
      "id": 236,
      "topicId": 6,
      "question": "Công cụ nào giúp quản lý nhiều phiên bản Node.js khác nhau trên cùng một máy?",
      "options": [
        "npm",
        "Yarn",
        "nvm (Node Version Manager)",
        "Webpack"
      ],
      "correctAnswer": 2
    },
    {
      "id": 237,
      "topicId": 6,
      "question": "Gulp.js là một thư viện JavaScript dùng để làm gì?",
      "options": [
        "Xây dựng API RESTful.",
        "Tự động hóa các tác vụ phát triển như biên dịch, nén, kiểm thử.",
        "Quản lý cơ sở dữ liệu.",
        "Thiết kế giao diện người dùng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 238,
      "topicId": 6,
      "question": "Cấu hình `.gitignore` trong Git có vai trò gì?",
      "options": [
        "Chỉ định các tệp và thư mục cần được theo dõi bởi Git.",
        "Chỉ định các tệp và thư mục mà Git nên bỏ qua (không theo dõi).",
        "Lưu trữ thông tin xác thực Git.",
        "Cấu hình các branch của Git."
      ],
      "correctAnswer": 1
    },
    {
      "id": 239,
      "topicId": 6,
      "question": "ES Modules (ESM) là gì?",
      "options": [
        "Một hệ thống module cũ của JavaScript.",
        "Hệ thống module chuẩn của JavaScript, cho phép import/export module bằng cú pháp `import`/`export`.",
        "Một thư viện JavaScript để quản lý DOM.",
        "Một công cụ để nén mã."
      ],
      "correctAnswer": 1
    },
    {
      "id": 240,
      "topicId": 6,
      "question": "IDE (Integrated Development Environment) là gì?",
      "options": [
        "Một công cụ để triển khai ứng dụng.",
        "Một môi trường phần mềm cung cấp các tiện ích toàn diện cho lập trình viên (editor, debugger, compiler, v.v.).",
        "Một công cụ để quản lý phiên bản code.",
        "Một ngôn ngữ lập trình."
      ],
      "correctAnswer": 1
    },
    {
      "id": 241,
      "topicId": 7,
      "question": "Trong React, khái niệm 'lifting state up' có nghĩa là gì?",
      "options": [
        "Chuyển state từ component con lên component cha gần nhất có chung nhu cầu",
        "Chuyển state từ component cha xuống component con",
        "Lưu trữ state vào bộ nhớ cục bộ (local storage)",
        "Xóa bỏ state không cần thiết"
      ],
      "correctAnswer": 0
    },
    {
      "id": 242,
      "topicId": 7,
      "question": "Thư viện nào thường được sử dụng để quản lý state toàn cục (global state) trong ứng dụng React lớn?",
      "options": [
        "Axios",
        "React Router",
        "Redux",
        "Lodash"
      ],
      "correctAnswer": 2
    },
    {
      "id": 243,
      "topicId": 7,
      "question": "Để gửi một yêu cầu GET đến API trong JavaScript thuần, bạn có thể sử dụng đối tượng nào?",
      "options": [
        "localStorage",
        "sessionStorage",
        "XMLHttpRequest",
        "console"
      ],
      "correctAnswer": 2
    },
    {
      "id": 244,
      "topicId": 7,
      "question": "Thư viện nào phổ biến để gửi các yêu cầu HTTP (API calls) trong JavaScript/React?",
      "options": [
        "jQuery",
        "Moment.js",
        "Axios",
        "Lodash"
      ],
      "correctAnswer": 2
    },
    {
      "id": 245,
      "topicId": 7,
      "question": "Trong Redux, 'reducer' có trách nhiệm chính là gì?",
      "options": [
        "Gửi các action",
        "Lưu trữ state của ứng dụng",
        "Mô tả cách state của ứng dụng thay đổi để phản ứng với một action",
        "Thực hiện các tác vụ bất đồng bộ"
      ],
      "correctAnswer": 2
    },
    {
      "id": 246,
      "topicId": 7,
      "question": "Hook nào trong React thường được sử dụng để đồng bộ hóa một component với một hệ thống bên ngoài, ví dụ như fetching dữ liệu?",
      "options": [
        "useState",
        "useContext",
        "useEffect",
        "useRef"
      ],
      "correctAnswer": 2
    },
    {
      "id": 247,
      "topicId": 7,
      "question": "Sự khác biệt chính giữa `localStorage` và `sessionStorage` là gì?",
      "options": [
        "`localStorage` không có giới hạn dung lượng, `sessionStorage` thì có.",
        "`localStorage` dữ liệu sẽ mất khi đóng tab, `sessionStorage` dữ liệu tồn tại mãi mãi.",
        "`localStorage` dữ liệu tồn tại ngay cả khi đóng trình duyệt, `sessionStorage` chỉ tồn tại trong phiên làm việc của tab đó.",
        "Không có sự khác biệt."
      ],
      "correctAnswer": 2
    },
    {
      "id": 248,
      "topicId": 7,
      "question": "Thư viện nào cung cấp một cách tiếp cận dựa trên Context API của React để quản lý state toàn cục một cách nhẹ nhàng hơn Redux?",
      "options": [
        "MobX",
        "Recoil",
        "Zustand",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 3
    },
    {
      "id": 249,
      "topicId": 7,
      "question": "Trong cơ chế Redux, 'action' có vai trò gì?",
      "options": [
        "Lưu trữ state của ứng dụng",
        "Mô tả điều gì đã xảy ra (một sự kiện)",
        "Thay đổi state trực tiếp",
        "Kết nối với API"
      ],
      "correctAnswer": 1
    },
    {
      "id": 250,
      "topicId": 7,
      "question": "Middleware trong Redux được sử dụng để làm gì?",
      "options": [
        "Chỉ để log các action",
        "Thực hiện các tác vụ bất đồng bộ hoặc logic phức tạp trước khi action đến reducer",
        "Lưu trữ dữ liệu trong cơ sở dữ liệu",
        "Render giao diện người dùng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 251,
      "topicId": 7,
      "question": "GraphQL là gì?",
      "options": [
        "Một ngôn ngữ lập trình cho frontend",
        "Một ngôn ngữ truy vấn và thao tác dữ liệu cho API, cho phép client chỉ định chính xác dữ liệu cần thiết",
        "Một hệ quản trị cơ sở dữ liệu",
        "Một giao thức truyền tải tệp"
      ],
      "correctAnswer": 1
    },
    {
      "id": 252,
      "topicId": 7,
      "question": "Để xử lý lỗi khi gọi API với `fetch` API, bạn nên kiểm tra thuộc tính nào của đối tượng `Response`?",
      "options": [
        "response.json()",
        "response.text()",
        "response.ok",
        "response.statusText"
      ],
      "correctAnswer": 2
    },
    {
      "id": 253,
      "topicId": 7,
      "question": "Thư viện nào sau đây được sử dụng để tối ưu hóa việc fetching, caching và đồng bộ dữ liệu cho React (hoặc framework khác) một cách hiệu quả?",
      "options": [
        "React Router",
        "Formik",
        "React Query (hoặc TanStack Query)",
        "Chakra UI"
      ],
      "correctAnswer": 2
    },
    {
      "id": 254,
      "topicId": 7,
      "question": "Persistent state có nghĩa là gì trong quản lý state?",
      "options": [
        "State chỉ tồn tại trong một phiên làm việc",
        "State không bao giờ thay đổi",
        "State được lưu trữ và duy trì ngay cả khi người dùng đóng và mở lại ứng dụng/trang web",
        "State chỉ tồn tại trên server"
      ],
      "correctAnswer": 2
    },
    {
      "id": 255,
      "topicId": 7,
      "question": "Trong mô hình Flux (hoặc Redux), đâu là luồng dữ liệu chính?",
      "options": [
        "Hai chiều",
        "Một chiều",
        "Vòng lặp vô hạn",
        "Không có luồng cụ thể"
      ],
      "correctAnswer": 1
    },
    {
      "id": 256,
      "topicId": 7,
      "question": "Thunk trong Redux (`redux-thunk`) được sử dụng để làm gì?",
      "options": [
        "Để quản lý các action đồng bộ.",
        "Để cho phép các action gửi đi các hàm thay vì chỉ các đối tượng action thuần túy, thường dùng cho tác vụ bất đồng bộ.",
        "Để lưu trữ state.",
        "Để kiểm tra lỗi trong reducer."
      ],
      "correctAnswer": 1
    },
    {
      "id": 257,
      "topicId": 7,
      "question": "Recoil là một thư viện quản lý state nào?",
      "options": [
        "Chỉ dành cho Class Components.",
        "Một thư viện quản lý state cho React, được phát triển bởi Facebook, cung cấp các 'atom' và 'selector'.",
        "Một thư viện thay thế cho Redux.",
        "Một thư viện để tạo hiệu ứng động."
      ],
      "correctAnswer": 1
    },
    {
      "id": 258,
      "topicId": 7,
      "question": "Để lưu trữ các cặp key-value đơn giản và lớn hơn trong trình duyệt so với `localStorage`, bạn có thể sử dụng API nào?",
      "options": [
        "IndexedDB",
        "Web SQL",
        "Cookies",
        "Session Storage"
      ],
      "correctAnswer": 0
    },
    {
      "id": 259,
      "topicId": 7,
      "question": "Mutation trong ngữ cảnh GraphQL là gì?",
      "options": [
        "Một yêu cầu để lấy dữ liệu.",
        "Một yêu cầu để thay đổi dữ liệu trên server (tạo, cập nhật, xóa).",
        "Một loại lỗi.",
        "Một cách để tạo cache."
      ],
      "correctAnswer": 1
    },
    {
      "id": 260,
      "topicId": 7,
      "question": "Sự khác biệt giữa 'push' và 'pull' trong việc truyền dữ liệu là gì?",
      "options": [
        "Push là server gửi dữ liệu đến client, Pull là client yêu cầu dữ liệu từ server.",
        "Push là client gửi dữ liệu đến server, Pull là server gửi dữ liệu đến client.",
        "Không có sự khác biệt.",
        "Chỉ áp dụng cho WebSockets."
      ],
      "correctAnswer": 0
    },
    {
      "id": 261,
      "topicId": 7,
      "question": "RTK Query (Redux Toolkit Query) giúp đơn giản hóa việc gì trong Redux?",
      "options": [
        "Chỉ quản lý state cục bộ.",
        "Quản lý state phức tạp.",
        "Quản lý việc fetching, caching, và cập nhật dữ liệu từ API một cách tự động.",
        "Tạo các UI component."
      ],
      "correctAnswer": 2
    },
    {
      "id": 262,
      "topicId": 7,
      "question": "Proxy trong JavaScript (ES6) dùng để làm gì trong quản lý state?",
      "options": [
        "Chỉ tạo bản sao của đối tượng.",
        "Cho phép bạn định nghĩa các hành vi tùy chỉnh cho các hoạt động cơ bản trên đối tượng (ví dụ: get, set).",
        "Để mã hóa dữ liệu.",
        "Để gửi yêu cầu mạng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 263,
      "topicId": 7,
      "question": "Thư viện SWR (Stale-while-revalidate) được dùng để làm gì?",
      "options": [
        "Chỉ để validation form.",
        "Để fetching dữ liệu, tối ưu hóa bằng cách hiển thị dữ liệu cũ (stale) ngay lập tức và sau đó tái xác thực (revalidate) để lấy dữ liệu mới.",
        "Để quản lý các animation.",
        "Để định tuyến."
      ],
      "correctAnswer": 1
    },
    {
      "id": 264,
      "topicId": 7,
      "question": "Atomic state management là gì?",
      "options": [
        "Quản lý state chỉ trong một component.",
        "Chia state thành các đơn vị độc lập và có thể tái sử dụng (atom), mỗi atom có thể được cập nhật và đăng ký độc lập.",
        "Quản lý state theo một khối lớn.",
        "Quản lý state chỉ trên server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 265,
      "topicId": 7,
      "question": "Thư viện nào cung cấp giải pháp cho việc quản lý state theo dạng đồ thị (graph-like state)?",
      "options": [
        "Redux",
        "XState (Statecharts)",
        "Zustand",
        "Jotai"
      ],
      "correctAnswer": 1
    },
    {
      "id": 266,
      "topicId": 7,
      "question": "WebSockets được sử dụng cho mục đích gì trong giao tiếp mạng?",
      "options": [
        "Chỉ gửi yêu cầu một lần.",
        "Tạo kết nối hai chiều, liên tục giữa client và server cho giao tiếp thời gian thực.",
        "Chỉ dùng để tải file tĩnh.",
        "Chỉ dùng cho các ứng dụng offline."
      ],
      "correctAnswer": 1
    },
    {
      "id": 267,
      "topicId": 7,
      "question": "Thư viện React Hook Form được sử dụng chủ yếu để làm gì?",
      "options": [
        "Quản lý state toàn cục.",
        "Xây dựng và quản lý các form hiệu quả trong React, với hiệu suất tối ưu và ít re-render.",
        "Fetching dữ liệu.",
        "Tạo component chung."
      ],
      "correctAnswer": 1
    },
    {
      "id": 268,
      "topicId": 7,
      "question": "JSON Web Token (JWT) thường được dùng trong quá trình nào khi fetching dữ liệu?",
      "options": [
        "Để mã hóa dữ liệu.",
        "Để nén dữ liệu.",
        "Để xác thực và ủy quyền (authentication and authorization) các yêu cầu API.",
        "Để lưu trữ hình ảnh."
      ],
      "correctAnswer": 2
    },
    {
      "id": 269,
      "topicId": 7,
      "question": "HTTP method nào là 'idempotent' (có thể gọi nhiều lần mà không thay đổi kết quả cuối cùng)?",
      "options": [
        "POST",
        "PUT",
        "PATCH",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 1
    },
    {
      "id": 270,
      "topicId": 7,
      "question": "Sự khác biệt giữa `useState` và `useRef` trong React?",
      "options": [
        "`useState` tạo ra một tham chiếu có thể thay đổi mà không kích hoạt re-render, `useRef` quản lý state và kích hoạt re-render.",
        "`useState` quản lý state và kích hoạt re-render, `useRef` tạo ra một tham chiếu có thể thay đổi mà không kích hoạt re-render.",
        "Cả hai đều dùng để quản lý state.",
        "Cả hai đều không kích hoạt re-render."
      ],
      "correctAnswer": 1
    },
    {
      "id": 271,
      "topicId": 7,
      "question": "Web Storage API cung cấp các đối tượng nào để lưu trữ dữ liệu cục bộ trong trình duyệt?",
      "options": [
        "Cookies",
        "localStorage và sessionStorage",
        "IndexedDB và Web SQL",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 1
    },
    {
      "id": 272,
      "topicId": 7,
      "question": "Thư viện nào dùng để tạo các Schema validation cho form hoặc dữ liệu API trong JavaScript/TypeScript?",
      "options": [
        "Axios",
        "Yarn",
        "Zod (hoặc Yup)",
        "Redux"
      ],
      "correctAnswer": 2
    },
    {
      "id": 273,
      "topicId": 7,
      "question": "Khi sử dụng `fetch` API, để đọc dữ liệu JSON từ phản hồi server, bạn gọi phương thức nào trên đối tượng `Response`?",
      "options": [
        "response.text()",
        "response.blob()",
        "response.json()",
        "response.arrayBuffer()"
      ],
      "correctAnswer": 2
    },
    {
      "id": 274,
      "topicId": 7,
      "question": "Server-Sent Events (SSE) là gì?",
      "options": [
        "Giao tiếp hai chiều như WebSockets.",
        "Một công nghệ cho phép server gửi các cập nhật một chiều đến trình duyệt qua kết nối HTTP.",
        "Một loại lỗi server.",
        "Chỉ dùng để gửi dữ liệu từ client lên server."
      ],
      "correctAnswer": 1
    },
    {
      "id": 275,
      "topicId": 7,
      "question": "State machine trong phát triển frontend giúp ích gì?",
      "options": [
        "Chỉ để lưu trữ dữ liệu đơn giản.",
        "Để quản lý các trạng thái phức tạp và chuyển đổi giữa chúng một cách rõ ràng và có cấu trúc.",
        "Để làm cho giao diện đẹp hơn.",
        "Để tăng tốc độ ứng dụng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 276,
      "topicId": 7,
      "question": "Thư viện Zustand được biết đến với đặc điểm nào trong quản lý state?",
      "options": [
        "Yêu cầu boilerplate code rất nhiều.",
        "Đơn giản, nhẹ, và không yêu cầu Context API để sử dụng.",
        "Chỉ dùng cho Class Components.",
        "Không hỗ trợ bất đồng bộ."
      ],
      "correctAnswer": 1
    },
    {
      "id": 277,
      "topicId": 7,
      "question": "Reselect trong Redux được dùng để làm gì?",
      "options": [
        "Chọn dữ liệu từ API.",
        "Tạo các selector có khả năng ghi nhớ (memoized selectors) để tính toán lại dữ liệu chỉ khi các dependencies thay đổi, tối ưu hiệu năng.",
        "Gửi các action bất đồng bộ.",
        "Thiết lập reducer."
      ],
      "correctAnswer": 1
    },
    {
      "id": 278,
      "topicId": 7,
      "question": "Thư viện nào dùng để mô phỏng (mock) các yêu cầu API trong quá trình phát triển và kiểm thử?",
      "options": [
        "Axios",
        "React Testing Library",
        "MSW (Mock Service Worker)",
        "Redux"
      ],
      "correctAnswer": 2
    },
    {
      "id": 279,
      "topicId": 7,
      "question": "Immutability (Bất biến) trong quản lý state có nghĩa là gì?",
      "options": [
        "State không bao giờ thay đổi.",
        "State không được thay đổi trực tiếp mà phải tạo ra một bản sao mới với các thay đổi.",
        "State chỉ có thể thay đổi một lần.",
        "State được lưu trữ trong bộ nhớ chỉ đọc."
      ],
      "correctAnswer": 1
    },
    {
      "id": 280,
      "topicId": 7,
      "question": "HTTP method nào được dùng để cập nhật một phần của tài nguyên hiện có trên server?",
      "options": [
        "PUT",
        "POST",
        "PATCH",
        "GET"
      ],
      "correctAnswer": 2
    },
    {
      "id": 281,
      "topicId": 8,
      "question": "Kiểu kiểm thử nào tập trung vào việc kiểm tra từng đơn vị code nhỏ (ví dụ: một hàm, một component) một cách độc lập?",
      "options": [
        "Integration testing",
        "End-to-end testing",
        "Unit testing",
        "Acceptance testing"
      ],
      "correctAnswer": 2
    },
    {
      "id": 282,
      "topicId": 8,
      "question": "Framework phổ biến nào trong JavaScript được sử dụng cho unit testing?",
      "options": [
        "Cypress",
        "Selenium",
        "Jest",
        "Playwright"
      ],
      "correctAnswer": 2
    },
    {
      "id": 283,
      "topicId": 8,
      "question": "Để gỡ lỗi (debug) mã JavaScript trong trình duyệt, công cụ nào thường được sử dụng?",
      "options": [
        "Node.js debugger",
        "DevTools của trình duyệt (ví dụ: Chrome DevTools)",
        "Text editor",
        "Command Prompt"
      ],
      "correctAnswer": 1
    },
    {
      "id": 284,
      "topicId": 8,
      "question": "Assertion library nào thường được dùng kết hợp với Jest để viết các khẳng định trong test?",
      "options": [
        "Chai",
        "Sinon",
        "Enzyme",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 0
    },
    {
      "id": 285,
      "topicId": 8,
      "question": "Mục đích của kiểm thử tích hợp (Integration testing) là gì?",
      "options": [
        "Kiểm tra chức năng của một module riêng lẻ",
        "Kiểm tra sự tương tác giữa các module hoặc component khác nhau",
        "Kiểm tra toàn bộ luồng người dùng từ đầu đến cuối",
        "Đảm bảo giao diện người dùng trông đúng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 286,
      "topicId": 8,
      "question": "E2E testing (End-to-End testing) là gì?",
      "options": [
        "Kiểm thử từng dòng code một",
        "Kiểm thử toàn bộ hệ thống từ góc nhìn của người dùng cuối, mô phỏng các tương tác thực tế",
        "Kiểm thử các API endpoint",
        "Kiểm thử hiệu năng của ứng dụng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 287,
      "topicId": 8,
      "question": "Thư viện nào trong React được sử dụng để render các component một cách cô lập và kiểm tra hành vi của chúng?",
      "options": [
        "React Router",
        "Redux",
        "React Testing Library",
        "Axios"
      ],
      "correctAnswer": 2
    },
    {
      "id": 288,
      "topicId": 8,
      "question": "Phương pháp `console.log()` trong JavaScript được sử dụng chủ yếu để làm gì khi debug?",
      "options": [
        "Tạo ra lỗi cố ý",
        "Hiển thị giá trị của biến hoặc thông điệp tại các điểm cụ thể trong mã",
        "Đo lường hiệu suất của mã",
        "Chỉ để trang trí"
      ],
      "correctAnswer": 1
    },
    {
      "id": 289,
      "topicId": 8,
      "question": "Debugger của trình duyệt cho phép bạn làm gì khi gỡ lỗi JavaScript?",
      "options": [
        "Thay đổi mã nguồn trực tiếp trên server",
        "Đặt breakpoint, theo dõi giá trị biến, và chạy từng dòng mã một",
        "Chỉ xem lỗi đã xảy ra mà không thể tương tác",
        "Tự động sửa lỗi"
      ],
      "correctAnswer": 1
    },
    {
      "id": 290,
      "topicId": 8,
      "question": "Mocking trong testing có ý nghĩa gì?",
      "options": [
        "Viết code thử nghiệm không đúng",
        "Giả lập các đối tượng phụ thuộc (dependencies) để cô lập đơn vị đang được kiểm thử",
        "Xóa bỏ các test case",
        "Chạy test trên nhiều trình duyệt khác nhau"
      ],
      "correctAnswer": 1
    },
    {
      "id": 291,
      "topicId": 8,
      "question": "Karma là một Test Runner phổ biến, nó được dùng để làm gì?",
      "options": [
        "Viết các bài test mới",
        "Thực thi các bài test trong các môi trường trình duyệt khác nhau",
        "Tạo báo cáo lỗi",
        "Quản lý các test case"
      ],
      "correctAnswer": 1
    },
    {
      "id": 292,
      "topicId": 8,
      "question": "Công cụ nào giúp bạn kiểm tra tính dễ tiếp cận (accessibility) của một trang web?",
      "options": [
        "Lighthouse",
        "ESLint",
        "Prettier",
        "Webpack"
      ],
      "correctAnswer": 0
    },
    {
      "id": 293,
      "topicId": 8,
      "question": "Snapshot testing (chụp nhanh) trong Jest được dùng để làm gì?",
      "options": [
        "Kiểm tra logic nghiệp vụ",
        "Kiểm tra giao diện người dùng bằng cách so sánh với một bản chụp trước đó của cấu trúc DOM",
        "Kiểm tra hiệu năng ứng dụng",
        "Kiểm tra các yêu cầu mạng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 294,
      "topicId": 8,
      "question": "Thư viện `msw` (Mock Service Worker) thường được dùng để làm gì trong testing frontend?",
      "options": [
        "Tạo các component React giả",
        "Giả lập các yêu cầu mạng (API requests) ở mức độ network để test các ứng dụng kết nối API",
        "Kiểm tra CSS",
        "Định dạng code"
      ],
      "correctAnswer": 1
    },
    {
      "id": 295,
      "topicId": 8,
      "question": "Phương pháp nào hiệu quả để xác định nguyên nhân gốc rễ của một lỗi phức tạp?",
      "options": [
        "Chỉ nhìn vào thông báo lỗi",
        "Sử dụng `console.log` bừa bãi khắp nơi",
        "Sử dụng debugger để theo dõi luồng thực thi và giá trị biến",
        "Hỏi đồng nghiệp ngay lập tức mà không tự tìm hiểu"
      ],
      "correctAnswer": 2
    },
    {
      "id": 296,
      "topicId": 8,
      "question": "Test coverage (Độ bao phủ test) là gì?",
      "options": [
        "Số lượng lỗi tìm thấy trong code.",
        "Một metric cho biết tỷ lệ phần trăm code đã được thực thi bởi các bài test.",
        "Thời gian cần để chạy tất cả các bài test.",
        "Số lượng test cases được viết."
      ],
      "correctAnswer": 1
    },
    {
      "id": 297,
      "topicId": 8,
      "question": "Stubs và Spies trong testing có ý nghĩa gì?",
      "options": [
        "Chỉ là các loại test cases.",
        "Các đối tượng được tạo ra để thay thế hoặc theo dõi hành vi của các hàm/phương thức trong quá trình test.",
        "Các công cụ để debug.",
        "Các loại lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 298,
      "topicId": 8,
      "question": "Behavior-Driven Development (BDD) là gì?",
      "options": [
        "Một phương pháp phát triển tập trung vào viết test trước khi viết code.",
        "Một phương pháp phát triển tập trung vào việc xác định hành vi mong muốn của hệ thống từ góc nhìn của người dùng.",
        "Một phương pháp chỉ tập trung vào việc gỡ lỗi.",
        "Một phương pháp chỉ áp dụng cho backend."
      ],
      "correctAnswer": 1
    },
    {
      "id": 299,
      "topicId": 8,
      "question": "Tool nào được dùng để thực hiện E2E testing cho các ứng dụng web?",
      "options": [
        "Jest",
        "Enzyme",
        "Cypress",
        "ESLint"
      ],
      "correctAnswer": 2
    },
    {
      "id": 300,
      "topicId": 8,
      "question": "Kiểu lỗi 'ReferenceError' trong JavaScript có nghĩa là gì?",
      "options": [
        "Lỗi cú pháp.",
        "Lỗi khi cố gắng truy cập một biến chưa được khai báo hoặc không tồn tại trong phạm vi.",
        "Lỗi mạng.",
        "Lỗi logic."
      ],
      "correctAnswer": 1
    },
    {
      "id": 301,
      "topicId": 8,
      "question": "Test Pyramid (Kim tự tháp kiểm thử) đề xuất điều gì?",
      "options": [
        "Nên có nhiều E2E tests hơn unit tests.",
        "Nên có nhiều unit tests, ít integration tests, và rất ít E2E tests.",
        "Tất cả các loại test nên có số lượng bằng nhau.",
        "Chỉ nên viết E2E tests."
      ],
      "correctAnswer": 1
    },
    {
      "id": 302,
      "topicId": 8,
      "question": "Debugging trong môi trường production khác gì so với môi trường development?",
      "options": [
        "Dễ dàng hơn trong production.",
        "Khó khăn hơn trong production do thiếu công cụ và thông tin chi tiết, cần dựa vào log và monitoring.",
        "Chỉ có thể debug trong development.",
        "Không có sự khác biệt."
      ],
      "correctAnswer": 1
    },
    {
      "id": 303,
      "topicId": 8,
      "question": "Thư viện nào trong React Testing Library được dùng để kiểm tra các tương tác của người dùng?",
      "options": [
        "@testing-library/react",
        "@testing-library/user-event",
        "@testing-library/dom",
        "Cả A và B đều đúng"
      ],
      "correctAnswer": 3
    },
    {
      "id": 304,
      "topicId": 8,
      "question": "Code review có vai trò gì trong việc tìm lỗi và cải thiện chất lượng code?",
      "options": [
        "Không có vai trò.",
        "Giúp phát hiện lỗi, cải thiện thiết kế, và chia sẻ kiến thức giữa các thành viên trong nhóm.",
        "Chỉ để phê bình code.",
        "Làm chậm quá trình phát triển."
      ],
      "correctAnswer": 1
    },
    {
      "id": 305,
      "topicId": 8,
      "question": "Console API trong JavaScript cung cấp các phương thức debug hữu ích nào ngoài `log`?",
      "options": [
        "`console.warn()`, `console.error()`, `console.info()`, `console.table()`",
        "`console.print()`, `console.display()`",
        "`console.debug()`",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 3
    },
    {
      "id": 306,
      "topicId": 8,
      "question": "Mục đích của việc kiểm thử hồi quy (Regression Testing) là gì?",
      "options": [
        "Kiểm tra các tính năng mới.",
        "Đảm bảo rằng các thay đổi hoặc sửa lỗi gần đây không gây ra lỗi mới hoặc phá vỡ các chức năng hiện có.",
        "Kiểm tra hiệu năng.",
        "Chỉ kiểm tra bảo mật."
      ],
      "correctAnswer": 1
    },
    {
      "id": 307,
      "topicId": 8,
      "question": "Làm thế nào để tạo một breakpoint trong Chrome DevTools?",
      "options": [
        "Chỉ bằng cách thêm `debugger;` vào code.",
        "Nhấp vào số dòng code trong Source tab.",
        "Sử dụng `console.log()`.",
        "Chỉ thông qua command line."
      ],
      "correctAnswer": 1
    },
    {
      "id": 308,
      "topicId": 8,
      "question": "Thư viện nào được dùng để kiểm tra tính dễ tiếp cận của ứng dụng React?",
      "options": [
        "Jest",
        "ESLint",
        "@testing-library/jest-dom/extend-expect",
        "@testing-library/dom-accessibility"
      ],
      "correctAnswer": 3
    },
    {
      "id": 309,
      "topicId": 8,
      "question": "Error handling (Xử lý lỗi) trong JavaScript là gì?",
      "options": [
        "Chỉ để hiển thị thông báo lỗi.",
        "Quá trình dự đoán, phát hiện và phản ứng với các lỗi có thể xảy ra trong chương trình.",
        "Ngăn chặn tất cả các lỗi xảy ra.",
        "Tạo ra các lỗi giả."
      ],
      "correctAnswer": 1
    },
    {
      "id": 310,
      "topicId": 8,
      "question": "Sử dụng `debugger;` statement trong JavaScript có tác dụng gì?",
      "options": [
        "Tự động sửa lỗi.",
        "Kích hoạt debugger của trình duyệt tại điểm đó, tạm dừng thực thi mã.",
        "In ra lỗi vào console.",
        "Tăng tốc độ chạy mã."
      ],
      "correctAnswer": 1
    },
    {
      "id": 311,
      "topicId": 8,
      "question": "Performance testing (Kiểm thử hiệu năng) là gì?",
      "options": [
        "Kiểm tra các lỗi chức năng.",
        "Kiểm tra tốc độ, khả năng phản hồi và tính ổn định của ứng dụng dưới tải trọng khác nhau.",
        "Kiểm tra giao diện người dùng.",
        "Kiểm tra bảo mật."
      ],
      "correctAnswer": 1
    },
    {
      "id": 312,
      "topicId": 8,
      "question": "Mục đích của việc kiểm thử tự động (Automated Testing) là gì?",
      "options": [
        "Chỉ dùng cho các dự án nhỏ.",
        "Giảm thời gian và công sức kiểm thử, tăng độ tin cậy và khả năng lặp lại của quá trình kiểm thử.",
        "Thay thế hoàn toàn kiểm thử thủ công.",
        "Làm tăng số lượng lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 313,
      "topicId": 8,
      "question": "Thư viện nào được sử dụng để kiểm thử hiệu năng cho các API hoặc ứng dụng web?",
      "options": [
        "Jest",
        "K6",
        "Cypress",
        "React Testing Library"
      ],
      "correctAnswer": 1
    },
    {
      "id": 314,
      "topicId": 8,
      "question": "White-box testing là gì?",
      "options": [
        "Kiểm thử mà không biết cấu trúc nội bộ của hệ thống.",
        "Kiểm thử dựa trên kiến thức về cấu trúc nội bộ, thiết kế và triển khai của hệ thống.",
        "Kiểm thử chỉ dựa vào giao diện người dùng.",
        "Kiểm thử chỉ dựa vào các yêu cầu."
      ],
      "correctAnswer": 1
    },
    {
      "id": 315,
      "topicId": 8,
      "question": "Black-box testing là gì?",
      "options": [
        "Kiểm thử mà không biết cấu trúc nội bộ của hệ thống, chỉ dựa vào chức năng bên ngoài.",
        "Kiểm thử dựa trên kiến thức về mã nguồn.",
        "Kiểm thử chỉ dựa vào hiệu năng.",
        "Kiểm thử chỉ dựa vào database."
      ],
      "correctAnswer": 0
    },
    {
      "id": 316,
      "topicId": 8,
      "question": "Mutation testing là một kỹ thuật kiểm thử nâng cao nhằm mục đích gì?",
      "options": [
        "Tạo ra các mutation (thay đổi nhỏ) trong code để kiểm tra xem các bài test có đủ mạnh để phát hiện chúng không.",
        "Kiểm tra các thay đổi trong database.",
        "Kiểm tra các thay đổi trên giao diện người dùng.",
        "Kiểm tra sự tương thích giữa các trình duyệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 317,
      "topicId": 8,
      "question": "Sự khác biệt giữa `throw` và `return` trong xử lý lỗi JavaScript?",
      "options": [
        "`throw` dừng hàm và trả về giá trị, `return` tạo ra một lỗi.",
        "`throw` tạo ra một ngoại lệ và dừng luồng thực thi, `return` trả về giá trị và tiếp tục thực thi hàm.",
        "Cả hai đều làm điều tương tự.",
        "Một cái dùng cho số, một cái dùng cho chuỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 318,
      "topicId": 8,
      "question": "Công cụ nào giúp bạn phân tích các lỗ hổng bảo mật trong mã nguồn frontend?",
      "options": [
        "Webpack",
        "Sonarqube",
        "Prettier",
        "Git"
      ],
      "correctAnswer": 1
    },
    {
      "id": 319,
      "topicId": 8,
      "question": "Debuggers trong IDE (ví dụ: VS Code) cung cấp các tính năng nào để gỡ lỗi?",
      "options": [
        "Chỉ hiển thị lỗi.",
        "Đặt breakpoint, xem giá trị biến, theo dõi call stack, thực thi từng bước code.",
        "Tự động sửa lỗi.",
        "Tạo báo cáo bảo mật."
      ],
      "correctAnswer": 1
    },
    {
      "id": 320,
      "topicId": 8,
      "question": "Test-Driven Development (TDD) là gì?",
      "options": [
        "Viết code trước, sau đó viết test.",
        "Viết test thất bại trước, sau đó viết code để làm cho test pass, và refactor.",
        "Chỉ viết test cho các tính năng mới.",
        "Không bao giờ viết test."
      ],
      "correctAnswer": 1
    },
    {
      "id": 321,
      "topicId": 9,
      "question": "Thuật ngữ 'Responsive Web Design' (RWD) có nghĩa là gì?",
      "options": [
        "Trang web được thiết kế để chỉ hoạt động trên một loại thiết bị duy nhất",
        "Trang web tự động điều chỉnh bố cục và nội dung để phù hợp với các kích thước màn hình khác nhau",
        "Trang web tải nhanh hơn trên các thiết bị di động",
        "Trang web có hiệu ứng động đẹp mắt"
      ],
      "correctAnswer": 1
    },
    {
      "id": 322,
      "topicId": 9,
      "question": "Trong CSS, `@media` query được sử dụng cho mục đích gì?",
      "options": [
        "Định nghĩa các biến toàn cục",
        "Áp dụng các kiểu CSS khác nhau dựa trên điều kiện của thiết bị (ví dụ: kích thước màn hình)",
        "Tạo hoạt ảnh",
        "Nhúng phông chữ tùy chỉnh"
      ],
      "correctAnswer": 1
    },
    {
      "id": 323,
      "topicId": 9,
      "question": "Nguyên tắc 'Mobile-first' trong thiết kế web responsive có nghĩa là gì?",
      "options": [
        "Thiết kế giao diện cho máy tính để bàn trước, sau đó điều chỉnh cho di động",
        "Bắt đầu thiết kế cho thiết bị di động với các tính năng cốt lõi, sau đó mở rộng cho màn hình lớn hơn",
        "Chỉ phát triển ứng dụng cho thiết bị di động",
        "Tạo hai phiên bản trang web riêng biệt cho di động và máy tính"
      ],
      "correctAnswer": 1
    },
    {
      "id": 324,
      "topicId": 9,
      "question": "Thuộc tính `viewport` trong thẻ `<meta>` của HTML có vai trò gì trong thiết kế responsive?",
      "options": [
        "Kiểm soát kích thước font chữ mặc định của trang",
        "Kiểm soát cách trình duyệt hiển thị kích thước và tỉ lệ của trang trên các thiết bị",
        "Thiết lập màu nền cho trang",
        "Định nghĩa khu vực cuộn trên trang"
      ],
      "correctAnswer": 1
    },
    {
      "id": 325,
      "topicId": 9,
      "question": "UX (User Experience) tập trung vào khía cạnh nào của sản phẩm?",
      "options": [
        "Màu sắc và bố cục trực quan",
        "Cách người dùng cảm nhận và tương tác với sản phẩm",
        "Tốc độ tải trang",
        "Số lượng tính năng của sản phẩm"
      ],
      "correctAnswer": 1
    },
    {
      "id": 326,
      "topicId": 9,
      "question": "UI (User Interface) tập trung vào khía cạnh nào của sản phẩm?",
      "options": [
        "Cảm nhận và trải nghiệm người dùng",
        "Khả năng hoạt động của sản phẩm",
        "Giao diện trực quan và tương tác của sản phẩm",
        "Làm sao để sản phẩm được phát triển nhanh nhất"
      ],
      "correctAnswer": 2
    },
    {
      "id": 327,
      "topicId": 9,
      "question": "Sự khác biệt chính giữa pixel (`px`) và `rem` trong CSS khi thiết kế responsive là gì?",
      "options": [
        "`px` là đơn vị tương đối, `rem` là đơn vị tuyệt đối.",
        "`px` phụ thuộc vào kích thước màn hình, `rem` thì không.",
        "`px` là đơn vị tuyệt đối, `rem` là đơn vị tương đối dựa trên kích thước font gốc của tài liệu.",
        "Không có sự khác biệt."
      ],
      "correctAnswer": 2
    },
    {
      "id": 328,
      "topicId": 9,
      "question": "Khung làm việc CSS nào phổ biến nhất cho việc xây dựng giao diện responsive nhanh chóng?",
      "options": [
        "Bootstrap",
        "Tailwind CSS",
        "Bulma",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 3
    },
    {
      "id": 329,
      "topicId": 9,
      "question": "Để đảm bảo một hình ảnh hiển thị đúng tỉ lệ và không bị tràn ra ngoài container trên các kích thước màn hình khác nhau, bạn nên sử dụng thuộc tính CSS nào?",
      "options": [
        "width: 100%; height: 100%;",
        "max-width: 100%; height: auto;",
        "width: auto; height: 100%;",
        "overflow: hidden;"
      ],
      "correctAnswer": 1
    },
    {
      "id": 330,
      "topicId": 9,
      "question": "Accessibility (Khả năng tiếp cận) trong thiết kế web có ý nghĩa gì?",
      "options": [
        "Trang web có thể truy cập được từ bất kỳ đâu trên thế giới",
        "Trang web có thể được sử dụng bởi người dùng có nhiều khả năng khác nhau (bao gồm cả người khuyết tật)",
        "Trang web có thể hoạt động trên mọi trình duyệt",
        "Trang web miễn phí để sử dụng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 331,
      "topicId": 9,
      "question": "Thuộc tính `aria-label` trong HTML có vai trò gì trong Accessibility?",
      "options": [
        "Thay đổi màu sắc của phần tử",
        "Cung cấp một nhãn mô tả cho các phần tử UI mà không làm thay đổi văn bản hiển thị",
        "Ẩn phần tử khỏi màn hình",
        "Thêm một biểu tượng vào phần tử"
      ],
      "correctAnswer": 1
    },
    {
      "id": 332,
      "topicId": 9,
      "question": "Sự khác biệt giữa `min-width` và `max-width` trong `@media` query là gì?",
      "options": [
        "`min-width` áp dụng kiểu khi chiều rộng màn hình lớn hơn hoặc bằng giá trị, `max-width` khi nhỏ hơn hoặc bằng.",
        "`min-width` áp dụng kiểu khi chiều rộng màn hình nhỏ hơn hoặc bằng giá trị, `max-width` khi lớn hơn hoặc bằng.",
        "Cả hai đều làm điều tương tự.",
        "Một cái dùng cho di động, một cái dùng cho máy tính."
      ],
      "correctAnswer": 0
    },
    {
      "id": 333,
      "topicId": 9,
      "question": "Thiết kế 'Atomic Design' trong UI/UX đề xuất cách tiếp cận nào?",
      "options": [
        "Thiết kế từng trang web riêng biệt",
        "Phân chia giao diện thành các thành phần nhỏ nhất (nguyên tử) và xây dựng dần lên thành các cấu trúc lớn hơn",
        "Chỉ tập trung vào mã hóa mà không quan tâm đến thiết kế",
        "Sử dụng các mẫu thiết kế có sẵn"
      ],
      "correctAnswer": 1
    },
    {
      "id": 334,
      "topicId": 9,
      "question": "Để đảm bảo tương phản màu sắc đủ tốt cho người dùng có thị lực kém, bạn nên tuân thủ theo tiêu chuẩn nào?",
      "options": [
        "WCAG (Web Content Accessibility Guidelines)",
        "ISO 9001",
        "HTML5 Standard",
        "W3C CSS Validator"
      ],
      "correctAnswer": 0
    },
    {
      "id": 335,
      "topicId": 9,
      "question": "Nguyên tắc 'F-pattern' trong thiết kế UI/UX nói về điều gì?",
      "options": [
        "Cách người dùng cuộn trang web từ trên xuống dưới",
        "Cách người dùng quét nội dung trên web theo hình chữ 'F'",
        "Cách người dùng tương tác với các biểu mẫu",
        "Cách người dùng nhớ các biểu tượng"
      ],
      "correctAnswer": 1
    },
    {
      "id": 336,
      "topicId": 9,
      "question": "Sự khác biệt giữa `em` và `rem` trong CSS khi thiết lập kích thước font chữ?",
      "options": [
        "`em` là đơn vị tương đối với font size của phần tử gốc, `rem` là đơn vị tương đối với font size của phần tử cha.",
        "`em` là đơn vị tương đối với font size của phần tử cha, `rem` là đơn vị tương đối với font size của phần tử gốc.",
        "Cả hai đều là đơn vị tuyệt đối.",
        "Không có sự khác biệt."
      ],
      "correctAnswer": 1
    },
    {
      "id": 337,
      "topicId": 9,
      "question": "Thiết kế 'Material Design' của Google tập trung vào điều gì?",
      "options": [
        "Sử dụng nhiều hình ảnh động và hiệu ứng phức tạp.",
        "Tạo ra một hệ thống thiết kế tập trung vào sự tối giản và không gian trắng.",
        "Tạo ra một hệ thống thiết kế dựa trên các nguyên tắc thực tế về chuyển động và vật lý.",
        "Thiết kế chỉ dành cho các ứng dụng di động."
      ],
      "correctAnswer": 2
    },
    {
      "id": 338,
      "topicId": 9,
      "question": "Thuộc tính CSS nào cho phép bạn điều chỉnh khoảng cách giữa các hàng trong một đoạn văn bản?",
      "options": [
        "text-spacing",
        "word-spacing",
        "line-height",
        "letter-spacing"
      ],
      "correctAnswer": 2
    },
    {
      "id": 339,
      "topicId": 9,
      "question": "Giao diện người dùng có 'Affordance' tốt là gì?",
      "options": [
        "Giao diện phức tạp và khó sử dụng.",
        "Giao diện mà các đối tượng của nó gợi ý rõ ràng về cách chúng có thể được sử dụng.",
        "Giao diện có nhiều màu sắc.",
        "Giao diện có ít chức năng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 340,
      "topicId": 9,
      "question": "Để ẩn một phần tử khỏi màn hình nhưng vẫn để trình đọc màn hình truy cập được, bạn nên sử dụng thuộc tính CSS nào?",
      "options": [
        "display: none;",
        "visibility: hidden;",
        "opacity: 0;",
        "position: absolute; left: -9999px;"
      ],
      "correctAnswer": 3
    },
    {
      "id": 341,
      "topicId": 9,
      "question": "Đâu là một ví dụ về 'visual hierarchy' (phân cấp trực quan) tốt trong thiết kế UI?",
      "options": [
        "Tất cả các phần tử có cùng kích thước và màu sắc.",
        "Các phần tử quan trọng nhất được làm nổi bật bằng kích thước, màu sắc hoặc vị trí.",
        "Chỉ sử dụng văn bản đơn giản.",
        "Không có bất kỳ sự khác biệt nào giữa các phần tử."
      ],
      "correctAnswer": 1
    },
    {
      "id": 342,
      "topicId": 9,
      "question": "Grid System (Hệ thống lưới) trong thiết kế responsive giúp ích gì?",
      "options": [
        "Chỉ để sắp xếp hình ảnh.",
        "Giúp tổ chức nội dung và phần tử một cách có cấu trúc, dễ dàng điều chỉnh trên các kích thước màn hình khác nhau.",
        "Làm cho trang web tải nhanh hơn.",
        "Kiểm soát màu sắc của trang."
      ],
      "correctAnswer": 1
    },
    {
      "id": 343,
      "topicId": 9,
      "question": "Thuộc tính `object-fit` trong CSS dùng để làm gì với hình ảnh và video?",
      "options": [
        "Thay đổi kích thước của hình ảnh/video dựa trên nội dung của nó.",
        "Điều chỉnh cách hình ảnh/video được điều chỉnh để vừa với vùng chứa của nó.",
        "Thêm khung viền cho hình ảnh/video.",
        "Cắt bỏ phần hình ảnh/video bị tràn."
      ],
      "correctAnswer": 1
    },
    {
      "id": 344,
      "topicId": 9,
      "question": "Sự khác biệt giữa UI Kit và Design System là gì?",
      "options": [
        "UI Kit chỉ là tập hợp các thành phần UI, Design System là tập hợp toàn diện các nguyên tắc, hướng dẫn, và công cụ thiết kế.",
        "UI Kit chỉ dùng cho di động, Design System dùng cho desktop.",
        "Không có sự khác biệt.",
        "Design System chỉ tập trung vào code, UI Kit tập trung vào thiết kế."
      ],
      "correctAnswer": 0
    },
    {
      "id": 345,
      "topicId": 9,
      "question": "Typography (Kiểu chữ) trong thiết kế UI/UX đề cập đến điều gì?",
      "options": [
        "Cách tổ chức hình ảnh trên trang.",
        "Nghệ thuật và kỹ thuật sắp xếp kiểu chữ để làm cho ngôn ngữ viết dễ đọc, dễ hiểu và hấp dẫn.",
        "Sử dụng các biểu tượng.",
        "Cách tạo màu sắc."
      ],
      "correctAnswer": 1
    },
    {
      "id": 346,
      "topicId": 9,
      "question": "Kỹ thuật nào dùng để làm cho các hình ảnh tải về nhanh hơn bằng cách tải các phiên bản có độ phân giải thấp trước, sau đó là phiên bản cao hơn?",
      "options": [
        "Progressive JPEG",
        "Lazy Loading",
        "Adaptive Images",
        "Tất cả các đáp án trên"
      ],
      "correctAnswer": 0
    },
    {
      "id": 347,
      "topicId": 9,
      "question": "Thẻ `<picture>` trong HTML5 được dùng để làm gì?",
      "options": [
        "Để thêm một bức ảnh đơn giản.",
        "Để cung cấp nhiều nguồn hình ảnh khác nhau cho trình duyệt, cho phép nó chọn hình ảnh phù hợp nhất dựa trên các điều kiện (responsive images).",
        "Để tạo một bộ sưu tập ảnh.",
        "Để thêm chú thích cho ảnh."
      ],
      "correctAnswer": 1
    },
    {
      "id": 348,
      "topicId": 9,
      "question": "Figma là một công cụ phổ biến cho mục đích gì trong UI/UX?",
      "options": [
        "Viết code frontend.",
        "Thiết kế giao diện người dùng và tạo prototype.",
        "Quản lý database.",
        "Chạy kiểm thử tự động."
      ],
      "correctAnswer": 1
    },
    {
      "id": 349,
      "topicId": 9,
      "question": "Để đảm bảo một form có thể điều hướng dễ dàng bằng bàn phím (cho accessibility), bạn nên tập trung vào điều gì?",
      "options": [
        "Sử dụng nhiều màu sắc.",
        "Đảm bảo thứ tự tab (`tabindex`) hợp lý và tất cả các trường có thể được tập trung.",
        "Chỉ sử dụng chuột.",
        "Tạo form rất ngắn."
      ],
      "correctAnswer": 1
    },
    {
      "id": 350,
      "topicId": 9,
      "question": "Nguyên tắc Gestalt trong thiết kế UI/UX liên quan đến điều gì?",
      "options": [
        "Cách người dùng tương tác với sản phẩm.",
        "Cách não bộ con người tổ chức và nhận thức các yếu tố thị giác thành một tổng thể có ý nghĩa.",
        "Cách tạo ra các nút nhấn.",
        "Cách chọn màu sắc."
      ],
      "correctAnswer": 1
    },
    {
      "id": 351,
      "topicId": 9,
      "question": "Thẻ `<blockquote>` trong HTML thường được dùng để làm gì trong ngữ cảnh UX/UI?",
      "options": [
        "Tạo một đoạn văn bản nổi bật.",
        "Định nghĩa một đoạn trích dẫn dài từ một nguồn khác, thường được trình duyệt định dạng thụt lề.",
        "Chỉ dùng cho các câu trích dẫn ngắn.",
        "Tạo một khối code."
      ],
      "correctAnswer": 1
    },
    {
      "id": 352,
      "topicId": 9,
      "question": "User Flows (Luồng người dùng) trong thiết kế UI/UX là gì?",
      "options": [
        "Số lượng người dùng truy cập trang web.",
        "Chuỗi các bước mà người dùng thực hiện để hoàn thành một tác vụ cụ thể trên một trang web hoặc ứng dụng.",
        "Cách dữ liệu di chuyển giữa client và server.",
        "Cách các phần tử UI được sắp xếp."
      ],
      "correctAnswer": 1
    },
    {
      "id": 353,
      "topicId": 9,
      "question": "Wireframing trong UI/UX design là gì?",
      "options": [
        "Tạo bản thiết kế cuối cùng với đầy đủ màu sắc và hình ảnh.",
        "Tạo các bản phác thảo cấu trúc và bố cục cơ bản của giao diện, thường không có màu sắc hoặc chi tiết đồ họa.",
        "Viết code HTML/CSS.",
        "Phỏng vấn người dùng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 354,
      "topicId": 9,
      "question": "Prototyping trong UI/UX design là gì?",
      "options": [
        "Tạo ra sản phẩm cuối cùng.",
        "Tạo ra các mô hình tương tác của sản phẩm để kiểm thử ý tưởng và luồng người dùng trước khi phát triển toàn diện.",
        "Chỉ tạo ra các hình ảnh tĩnh.",
        "Viết tài liệu thiết kế."
      ],
      "correctAnswer": 1
    },
    {
      "id": 355,
      "topicId": 9,
      "question": "Persona trong UI/UX design là gì?",
      "options": [
        "Một nhân vật hư cấu, được tạo ra dựa trên nghiên cứu người dùng, đại diện cho một kiểu người dùng mục tiêu.",
        "Một công cụ để tạo ra các icon.",
        "Một phương pháp kiểm thử.",
        "Một loại font chữ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 356,
      "topicId": 9,
      "question": "Information Architecture (Kiến trúc thông tin) trong UI/UX liên quan đến điều gì?",
      "options": [
        "Cách tổ chức mã nguồn của ứng dụng.",
        "Cách tổ chức, cấu trúc và gắn nhãn nội dung trên trang web/ứng dụng để người dùng dễ tìm kiếm và hiểu được thông tin.",
        "Cách thiết kế cơ sở dữ liệu.",
        "Cách quản lý phiên làm việc của người dùng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 357,
      "topicId": 9,
      "question": "Heuristic Evaluation là một phương pháp nào trong UX?",
      "options": [
        "Thu thập phản hồi từ người dùng thực tế.",
        "Đánh giá giao diện người dùng dựa trên một bộ nguyên tắc (heuristics) đã được thiết lập bởi các chuyên gia.",
        "Kiểm tra hiệu suất.",
        "Thiết kế các biểu tượng."
      ],
      "correctAnswer": 1
    },
    {
      "id": 358,
      "topicId": 9,
      "question": "Breadcrumbs trong thiết kế web có tác dụng gì?",
      "options": [
        "Hiển thị các lỗi trên trang.",
        "Giúp người dùng biết vị trí hiện tại của họ trong cấu trúc phân cấp của trang web.",
        "Tạo ra các liên kết ngoài.",
        "Hiển thị các thông báo."
      ],
      "correctAnswer": 1
    },
    {
      "id": 359,
      "topicId": 9,
      "question": "Sử dụng các hình ảnh có định dạng SVG trong thiết kế responsive có lợi ích gì?",
      "options": [
        "Kích thước tệp lớn.",
        "Là đồ họa vector, không bị vỡ hoặc mờ khi phóng to hoặc thu nhỏ.",
        "Không hỗ trợ màu sắc.",
        "Không thể hoạt ảnh."
      ],
      "correctAnswer": 1
    },
    {
      "id": 360,
      "topicId": 9,
      "question": "Mục đích của A/B Testing trong UI/UX là gì?",
      "options": [
        "So sánh hai phiên bản của một giao diện hoặc tính năng để xem phiên bản nào hoạt động tốt hơn dựa trên các metric cụ thể.",
        "Chỉ để kiểm tra lỗi.",
        "Thiết kế hai giao diện khác nhau.",
        "Kiểm thử bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 361,
      "topicId": 10,
      "question": "HTTP là viết tắt của từ gì?",
      "options": [
        "HyperText Transfer Protocol",
        "HyperText Markup Protocol",
        "High Technology Transfer Protocol",
        "Home Tool Transfer Protocol"
      ],
      "correctAnswer": 0
    },
    {
      "id": 362,
      "topicId": 10,
      "question": "Sự khác biệt chính giữa HTTP và HTTPS là gì?",
      "options": [
        "HTTPS nhanh hơn HTTP",
        "HTTPS mã hóa dữ liệu truyền tải, HTTP thì không",
        "HTTP dùng cho web, HTTPS dùng cho ứng dụng di động",
        "HTTP là phiên bản cũ, HTTPS là phiên bản mới nhất"
      ],
      "correctAnswer": 1
    },
    {
      "id": 363,
      "topicId": 10,
      "question": "Cookie trong trình duyệt web được sử dụng cho mục đích gì?",
      "options": [
        "Lưu trữ mã nguồn JavaScript",
        "Lưu trữ dữ liệu nhỏ để theo dõi trạng thái người dùng hoặc phiên làm việc",
        "Tăng tốc độ kết nối internet",
        "Mã hóa thông tin cá nhân"
      ],
      "correctAnswer": 1
    },
    {
      "id": 364,
      "topicId": 10,
      "question": "Tấn công XSS (Cross-Site Scripting) là gì?",
      "options": [
        "Tấn công từ chối dịch vụ (Denial of Service)",
        "Kẻ tấn công tiêm mã độc hại vào các trang web được xem bởi người dùng khác",
        "Tấn công chiếm quyền điều khiển server",
        "Tấn công bằng cách giả mạo địa chỉ IP"
      ],
      "correctAnswer": 1
    },
    {
      "id": 365,
      "topicId": 10,
      "question": " CORS (Cross-Origin Resource Sharing) là cơ chế bảo mật nào của trình duyệt?",
      "options": [
        "Ngăn chặn các yêu cầu HTTP từ các tên miền khác",
        "Cho phép các tài nguyên (như font, script, API) từ một tên miền khác được truy cập bởi trang web hiện tại",
        "Mã hóa dữ liệu trước khi gửi qua mạng",
        "Giúp phát hiện mã độc hại trong các tệp tải xuống"
      ],
      "correctAnswer": 1
    },
    {
      "id": 366,
      "topicId": 10,
      "question": "CSRF (Cross-Site Request Forgery) là loại tấn công nào?",
      "options": [
        "Tấn công bằng cách giả mạo yêu cầu từ người dùng đã xác thực để thực hiện hành động không mong muốn",
        "Tấn công tiêm mã độc",
        "Tấn công từ chối dịch vụ",
        "Tấn công dựa trên lỗ hổng SQL injection"
      ],
      "correctAnswer": 0
    },
    {
      "id": 367,
      "topicId": 10,
      "question": "HTTP status code 200 có ý nghĩa gì?",
      "options": [
        "Yêu cầu không tìm thấy",
        "Yêu cầu thành công",
        "Lỗi server nội bộ",
        "Yêu cầu không được phép"
      ],
      "correctAnswer": 1
    },
    {
      "id": 368,
      "topicId": 10,
      "question": "HTTP status code 404 có ý nghĩa gì?",
      "options": [
        "Yêu cầu thành công",
        "Không có quyền truy cập",
        "Tài nguyên không tìm thấy",
        "Lỗi cú pháp trong yêu cầu"
      ],
      "correctAnswer": 2
    },
    {
      "id": 369,
      "topicId": 10,
      "question": "API (Application Programming Interface) là gì?",
      "options": [
        "Một ngôn ngữ lập trình",
        "Một tập hợp các quy tắc và định nghĩa cho phép các ứng dụng giao tiếp với nhau",
        "Một loại cơ sở dữ liệu",
        "Một giao thức bảo mật"
      ],
      "correctAnswer": 1
    },
    {
      "id": 370,
      "topicId": 10,
      "question": "Phương thức HTTP nào được dùng để gửi dữ liệu từ client lên server để tạo một tài nguyên mới?",
      "options": [
        "GET",
        "PUT",
        "POST",
        "DELETE"
      ],
      "correctAnswer": 2
    },
    {
      "id": 371,
      "topicId": 10,
      "question": "Phương thức HTTP nào được dùng để lấy dữ liệu từ server?",
      "options": [
        "GET",
        "POST",
        "PUT",
        "DELETE"
      ],
      "correctAnswer": 0
    },
    {
      "id": 372,
      "topicId": 10,
      "question": "Cơ chế Same-Origin Policy trong trình duyệt có vai trò gì?",
      "options": [
        "Cho phép mọi trang web truy cập tài nguyên của nhau",
        "Ngăn chặn các script trên một trang web truy cập dữ liệu của một trang web từ một 'origin' khác (giao thức, host, port khác)",
        "Buộc các trang web phải sử dụng cùng một giao thức",
        "Tối ưu hóa tốc độ tải trang"
      ],
      "correctAnswer": 1
    },
    {
      "id": 373,
      "topicId": 10,
      "question": "SQL Injection là loại tấn công nào?",
      "options": [
        "Tấn công tiêm mã HTML",
        "Tấn công tiêm mã JavaScript",
        "Tấn công tiêm mã SQL độc hại vào các trường nhập liệu để thao tác cơ sở dữ liệu",
        "Tấn công từ chối dịch vụ"
      ],
      "correctAnswer": 2
    },
    {
      "id": 374,
      "topicId": 10,
      "question": "JWT (JSON Web Token) thường được sử dụng cho mục đích gì trong kiến trúc web hiện đại?",
      "options": [
        "Lưu trữ dữ liệu trong cơ sở dữ liệu",
        "Xác thực và ủy quyền (authentication and authorization) người dùng mà không cần session state trên server",
        "Tạo các file CSS động",
        "Gửi email"
      ],
      "correctAnswer": 1
    },
    {
      "id": 375,
      "topicId": 10,
      "question": "Đâu là một phương pháp tốt để bảo vệ dữ liệu nhạy cảm của người dùng trong frontend?",
      "options": [
        "Lưu trữ mật khẩu dưới dạng plain text trong localStorage",
        "Truyền tất cả dữ liệu qua HTTP thay vì HTTPS",
        "Sử dụng HTTPS và tránh lưu trữ dữ liệu nhạy cảm trên client-side nếu không cần thiết",
        "Chia sẻ thông tin xác thực qua URL"
      ],
      "correctAnswer": 2
    },
    {
      "id": 376,
      "topicId": 10,
      "question": "Phương pháp nào hiệu quả để ngăn chặn tấn công XSS trong ứng dụng web?",
      "options": [
        "Cho phép người dùng nhập bất kỳ loại mã nào.",
        "Xác thực đầu vào của người dùng và mã hóa (escape) đầu ra hiển thị trên HTML.",
        "Chỉ sử dụng HTTPS.",
        "Tắt JavaScript."
      ],
      "correctAnswer": 1
    },
    {
      "id": 377,
      "topicId": 10,
      "question": "Mục đích của Cross-Origin Resource Sharing (CORS) preflight request (`OPTIONS` method) là gì?",
      "options": [
        "Để gửi dữ liệu chính.",
        "Để kiểm tra xem server có cho phép yêu cầu cross-origin với các phương thức hoặc header cụ thể không trước khi gửi yêu cầu chính.",
        "Để lấy dữ liệu từ server.",
        "Để tạo một session mới."
      ],
      "correctAnswer": 1
    },
    {
      "id": 378,
      "topicId": 10,
      "question": "SSL/TLS certificates được dùng để làm gì trong HTTPS?",
      "options": [
        "Tăng tốc độ tải trang.",
        "Mã hóa dữ liệu và xác minh danh tính của server.",
        "Quản lý phiên làm việc người dùng.",
        "Chỉ dùng cho hình ảnh."
      ],
      "correctAnswer": 1
    },
    {
      "id": 379,
      "topicId": 10,
      "question": "HTTP headers nào thường được dùng để ngăn chặn tấn công clickjacking?",
      "options": [
        "Content-Type",
        "Cache-Control",
        "X-Frame-Options",
        "User-Agent"
      ],
      "correctAnswer": 2
    },
    {
      "id": 380,
      "topicId": 10,
      "question": "Tấn công Brute Force là gì?",
      "options": [
        "Tấn công bằng cách tiêm mã độc.",
        "Tấn công bằng cách thử tất cả các tổ hợp mật khẩu hoặc khóa có thể có cho đến khi tìm thấy cái đúng.",
        "Tấn công từ chối dịch vụ.",
        "Tấn công giả mạo yêu cầu."
      ],
      "correctAnswer": 1
    },
    {
      "id": 381,
      "topicId": 10,
      "question": "JWT (JSON Web Token) thường được ký (signed) để đảm bảo điều gì?",
      "options": [
        "Token luôn mới.",
        "Tính toàn vẹn (integrity) và xác thực (authenticity) của token (không bị thay đổi).",
        "Kích thước token nhỏ.",
        "Token được mã hóa hoàn toàn."
      ],
      "correctAnswer": 1
    },
    {
      "id": 382,
      "topicId": 10,
      "question": "Session hijacking là gì?",
      "options": [
        "Tấn công làm cho server ngừng hoạt động.",
        "Kẻ tấn công chiếm đoạt phiên làm việc của người dùng hợp lệ để thực hiện các hành động trái phép.",
        "Tấn công vào database.",
        "Tấn công tiêm mã."
      ],
      "correctAnswer": 1
    },
    {
      "id": 383,
      "topicId": 10,
      "question": "Mục đích của Content Security Policy (CSP) trong bảo mật web là gì?",
      "options": [
        "Chỉ kiểm soát các tệp CSS.",
        "Giúp ngăn chặn các cuộc tấn công XSS và các cuộc tấn công tiêm code khác bằng cách xác định các nguồn nội dung được phép.",
        "Mã hóa dữ liệu.",
        "Tăng tốc độ tải trang."
      ],
      "correctAnswer": 1
    },
    {
      "id": 384,
      "topicId": 10,
      "question": "OAuth 2.0 thường được sử dụng cho mục đích gì trong các ứng dụng web?",
      "options": [
        "Quản lý database.",
        "Cho phép người dùng cấp quyền truy cập tài nguyên của họ trên một dịch vụ cho một ứng dụng khác mà không cần chia sẻ thông tin đăng nhập.",
        "Mã hóa giao tiếp giữa client và server.",
        "Thực hiện các tác vụ backend."
      ],
      "correctAnswer": 1
    },
    {
      "id": 385,
      "topicId": 10,
      "question": "HTTPS sử dụng cổng mặc định nào?",
      "options": [
        "80",
        "443",
        "21",
        "22"
      ],
      "correctAnswer": 1
    },
    {
      "id": 386,
      "topicId": 10,
      "question": "Cơ chế 'Rate Limiting' trong API có tác dụng gì?",
      "options": [
        "Hạn chế số lượng request mà một client có thể thực hiện trong một khoảng thời gian nhất định để ngăn chặn lạm dụng và tấn công DDoS.",
        "Tăng tốc độ phản hồi của API.",
        "Chỉ cho phép một số lượng người dùng truy cập API.",
        "Mã hóa dữ liệu API."
      ],
      "correctAnswer": 0
    },
    {
      "id": 387,
      "topicId": 10,
      "question": "Tấn công Phishing (Lừa đảo) là gì?",
      "options": [
        "Tấn công bằng cách gửi mã độc.",
        "Tấn công bằng cách giả mạo trang web hoặc email để lừa người dùng tiết lộ thông tin nhạy cảm.",
        "Tấn công làm server quá tải.",
        "Tấn công vào cơ sở dữ liệu."
      ],
      "correctAnswer": 1
    },
    {
      "id": 388,
      "topicId": 10,
      "question": "HTTP method nào được dùng để xóa tài nguyên trên server?",
      "options": [
        "GET",
        "POST",
        "PUT",
        "DELETE"
      ],
      "correctAnswer": 3
    },
    {
      "id": 389,
      "topicId": 10,
      "question": "Web Application Firewall (WAF) được dùng để làm gì?",
      "options": [
        "Chỉ bảo vệ mạng nội bộ.",
        "Bảo vệ ứng dụng web khỏi các cuộc tấn công phổ biến như XSS, SQL Injection bằng cách lọc và giám sát traffic HTTP.",
        "Tăng tốc độ tải trang.",
        "Quản lý database."
      ],
      "correctAnswer": 1
    },
    {
      "id": 390,
      "topicId": 10,
      "question": "Hashing mật khẩu là gì?",
      "options": [
        "Mã hóa mật khẩu để có thể giải mã ngược lại.",
        "Chuyển đổi mật khẩu thành một chuỗi ký tự cố định chiều dài không thể đảo ngược, dùng để lưu trữ an toàn.",
        "Lưu trữ mật khẩu dưới dạng văn bản thuần túy.",
        "Tạo ra các mật khẩu ngẫu nhiên."
      ],
      "correctAnswer": 1
    },
    {
      "id": 391,
      "topicId": 10,
      "question": "Salt trong băm mật khẩu có tác dụng gì?",
      "options": [
        "Tăng tốc độ băm mật khẩu.",
        "Một chuỗi ngẫu nhiên được thêm vào mật khẩu trước khi băm để ngăn chặn tấn công rainbow table.",
        "Làm cho mật khẩu dễ nhớ hơn.",
        "Chỉ dùng cho mật khẩu yếu."
      ],
      "correctAnswer": 1
    },
    {
      "id": 392,
      "topicId": 10,
      "question": "HTTP Strict Transport Security (HSTS) là gì?",
      "options": [
        "Một tiêu đề HTTP yêu cầu trình duyệt chỉ truy cập trang web qua HTTPS trong tương lai.",
        "Một tiêu chuẩn để mã hóa dữ liệu.",
        "Một công cụ để kiểm tra lỗi bảo mật.",
        "Một phương thức để tăng tốc độ trang."
      ],
      "correctAnswer": 0
    },
    {
      "id": 393,
      "topicId": 10,
      "question": "Cơ chế nào giúp ngăn chặn việc gửi lại yêu cầu form nhiều lần (duplicate form submission)?",
      "options": [
        "Sử dụng GET request thay vì POST.",
        "Sử dụng token CSRF hoặc chuyển hướng sau khi submit thành công (Post/Redirect/Get pattern).",
        "Tắt JavaScript.",
        "Lưu trữ dữ liệu trong session."
      ],
      "correctAnswer": 1
    },
    {
      "id": 394,
      "topicId": 10,
      "question": "Cross-Site Scripting (XSS) có thể được phân loại thành những loại nào?",
      "options": [
        "Stored XSS, Reflected XSS, DOM-based XSS",
        "SQL XSS, HTML XSS",
        "Client XSS, Server XSS",
        "Active XSS, Passive XSS"
      ],
      "correctAnswer": 0
    },
    {
      "id": 395,
      "topicId": 10,
      "question": "JSON Web Token (JWT) được chia thành mấy phần chính?",
      "options": [
        "Một phần (Payload)",
        "Hai phần (Header, Payload)",
        "Ba phần (Header, Payload, Signature)",
        "Bốn phần (Header, Payload, Signature, Encryption)"
      ],
      "correctAnswer": 2
    },
    {
      "id": 396,
      "topicId": 10,
      "question": "Endpoint API là gì?",
      "options": [
        "Điểm bắt đầu của một ứng dụng.",
        "Các URL cụ thể mà ứng dụng client có thể gửi yêu cầu để tương tác với tài nguyên trên server.",
        "Chỉ là tên của một hàm.",
        "Một loại lỗi."
      ],
      "correctAnswer": 1
    },
    {
      "id": 397,
      "topicId": 10,
      "question": "Tấn công Man-in-the-Middle (MITM) là gì?",
      "options": [
        "Kẻ tấn công chặn và có thể sửa đổi giao tiếp giữa hai bên mà không bên nào biết.",
        "Tấn công làm tràn bộ nhớ server.",
        "Tấn công vào cơ sở dữ liệu.",
        "Tấn công từ chối dịch vụ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 398,
      "topicId": 10,
      "question": "Header HTTP nào dùng để kiểm soát việc trình duyệt có được phép lưu trữ phản hồi trong bộ nhớ cache không?",
      "options": [
        "Content-Type",
        "Cache-Control",
        "User-Agent",
        "Authorization"
      ],
      "correctAnswer": 1
    },
    {
      "id": 399,
      "topicId": 10,
      "question": "Cơ chế nào giúp bảo vệ các form chống lại tấn công CSRF?",
      "options": [
        "HTTPS",
        "CSRF tokens (ví dụ: synchronizer token pattern)",
        "XSS filtering",
        "HTTP Strict Transport Security"
      ],
      "correctAnswer": 1
    },
    {
      "id": 400,
      "topicId": 10,
      "question": "Tấn công 'Denial of Service' (DoS) hoặc 'Distributed Denial of Service' (DDoS) là gì?",
      "options": [
        "Tấn công nhằm đánh cắp dữ liệu người dùng.",
        "Tấn công nhằm làm quá tải server hoặc tài nguyên mạng, khiến dịch vụ không thể truy cập được đối với người dùng hợp lệ.",
        "Tấn công tiêm mã độc.",
        "Tấn công giả mạo danh tính."
      ],
      "correctAnswer": 1
    }
  ],
  "userAnswers": [
    {
      "id": 1,
      "userId": 1,
      "topicId": 1,
      "questionId": 1,
      "userAnswerIndex": 0
    },
    {
      "id": 2,
      "userId": 1,
      "topicId": 1,
      "questionId": 2,
      "userAnswerIndex": 0
    },
    {
      "id": 3,
      "userId": 2,
      "topicId": 2,
      "questionId": 41,
      "userAnswerIndex": 1
    },
    {
      "id": 4,
      "userId": 3,
      "topicId": 3,
      "questionId": 81,
      "userAnswerIndex": 2
    },
    {
      "id": 5,
      "userId": 1,
      "topicId": 1,
      "questionId": 5,
      "userAnswerIndex": 1
    }
  ],
  "questions-advance":[
    {
      "id": 1,
      "topicId": 1,
      "question": "Trong ngữ cảnh của Web Components, Shadow DOM giải quyết vấn đề gì liên quan đến CSS và DOM, và tại sao nó lại quan trọng cho tính đóng gói (encapsulation)?",
      "options": [
        "Ngăn chặn style của component bị rò rỉ ra ngoài và style bên ngoài ảnh hưởng vào trong component, đảm bảo tính đóng gói CSS và cấu trúc DOM.",
        "Cho phép chia sẻ style giữa các component khác nhau một cách dễ dàng, tăng khả năng tái sử dụng CSS.",
        "Tối ưu hóa quá trình rendering bằng cách tạo ra một DOM ảo, giúp cải thiện hiệu năng khi có nhiều thay đổi trên DOM.",
        "Cung cấp một cách thức để tải bất đồng bộ các tài nguyên HTML, CSS, và JavaScript, giảm thời gian tải trang ban đầu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 2,
      "topicId": 1,
      "question": "Sự khác biệt cốt lõi giữa `localStorage` và `sessionStorage` trong HTML Web Storage API là gì, và khi nào nên ưu tiên sử dụng từng loại?",
      "options": [
        "`localStorage` lưu trữ dữ liệu vĩnh viễn cho đến khi bị xóa thủ công, còn `sessionStorage` chỉ tồn tại trong suốt phiên làm việc của trình duyệt. Ưu tiên `localStorage` cho dữ liệu cần giữ lại qua các phiên, và `sessionStorage` cho dữ liệu tạm thời của phiên hiện tại.",
        "`localStorage` có giới hạn dung lượng lớn hơn `sessionStorage` (50MB so với 5MB). Ưu tiên `localStorage` cho dữ liệu lớn, và `sessionStorage` cho dữ liệu nhỏ.",
        "`localStorage` có thể truy cập được bởi nhiều tab/window cùng nguồn gốc, trong khi `sessionStorage` chỉ giới hạn trong tab/window đã tạo ra nó. Ưu tiên `localStorage` cho dữ liệu chia sẻ, và `sessionStorage` cho dữ liệu riêng tư của từng tab.",
        "Cả hai đều có chức năng tương tự nhưng `localStorage` được mã hóa mặc định, còn `sessionStorage` thì không. Ưu tiên `localStorage` cho dữ liệu nhạy cảm, và `sessionStorage` cho dữ liệu công khai."
      ],
      "correctAnswer": 0
    },
    {
      "id": 3,
      "topicId": 1,
      "question": "Giải thích vai trò của thuộc tính `rel=\"preload\"` trong thẻ `<link>` và tác động của nó đến hiệu suất tải trang.",
      "options": [
        "Nó chỉ thị cho trình duyệt tải tài nguyên (ví dụ: font, hình ảnh quan trọng) càng sớm càng tốt, trước khi các tài nguyên đó được khám phá trong DOM hoặc CSS, giúp cải thiện **First Contentful Paint (FCP)** và **Largest Contentful Paint (LCP)**.",
        "Nó thông báo cho trình duyệt biết tài nguyên này cần được tải sau cùng, khi tất cả các tài nguyên quan trọng khác đã hoàn tất, để tránh chặn rendering.",
        "Nó cho phép trình duyệt chỉ tải tài nguyên khi người dùng cuộn đến vị trí của chúng trên trang, giúp tiết kiệm băng thông và tăng tốc độ tải ban đầu.",
        "Nó yêu cầu trình duyệt thiết lập một kết nối TCP sớm đến nguồn gốc của tài nguyên mà không tải nội dung, chuẩn bị sẵn sàng cho các yêu cầu tài nguyên tiếp theo."
      ],
      "correctAnswer": 0
    },
    {
      "id": 4,
      "topicId": 1,
      "question": "Khi nào nên sử dụng `<iframe>` thay vì các phương pháp nhúng nội dung khác như Ajax hoặc Web Components, và những hạn chế bảo mật nào cần lưu ý?",
      "options": [
        "Nên sử dụng `<iframe>` khi cần nhúng nội dung từ một nguồn khác hoàn toàn độc lập và không tin cậy, ví dụ như quảng cáo hoặc nội dung bên thứ ba, nhờ vào cơ chế cách ly sandbox. Hạn chế bảo mật bao gồm clickjacking và lỗ hổng từ việc truyền tải thông tin nhạy cảm qua `postMessage` nếu không được kiểm soát chặt chẽ.",
        "Nên sử dụng `<iframe>` khi muốn tạo ra một ứng dụng một trang (SPA) có thể tải nhanh chóng nội dung mà không cần tải lại toàn bộ trang. Hạn chế bảo mật là dễ bị tấn công Cross-Site Scripting (XSS) hơn.",
        "Nên sử dụng `<iframe>` để tạo các component có thể tái sử dụng dễ dàng trong ứng dụng. Hạn chế bảo mật là không thể kiểm soát quyền truy cập DOM bên trong iframe từ trang cha.",
        "Nên sử dụng `<iframe>` để cải thiện hiệu suất tải trang bằng cách tải đồng thời nhiều phần của trang. Hạn chế bảo mật là có thể gây ra lỗi CORS nếu không cấu hình đúng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 5,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `inert` trong HTML và cách nó cải thiện khả năng truy cập (accessibility) cho các phần tử UI.",
      "options": [
        "Thuộc tính `inert` làm cho một phần tử không thể tương tác (không thể click, tab vào, hoặc đọc bởi assistive technologies) và loại bỏ nó khỏi cây accessibility tree. Nó cực kỳ hữu ích cho việc quản lý tiêu điểm trong các modal dialog, drawer, hoặc các phần tử overlay khác, đảm bảo người dùng chỉ tương tác với phần tử hiện tại.",
        "Thuộc tính `inert` chỉ làm cho phần tử không thể click được nhưng vẫn có thể nhận tiêu điểm từ bàn phím. Nó được dùng để vô hiệu hóa tạm thời các nút bấm trong khi chờ xử lý.",
        "Thuộc tính `inert` giúp các công cụ tìm kiếm bỏ qua phần tử đó khi lập chỉ mục trang web. Nó được dùng để ẩn các nội dung không quan trọng khỏi kết quả tìm kiếm.",
        "Thuộc tính `inert` tự động thêm một hiệu ứng chuyển động chậm khi người dùng di chuột qua phần tử đó, giúp cải thiện trải nghiệm người dùng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 6,
      "topicId": 1,
      "question": "Trong Web Components, Custom Elements cho phép bạn định nghĩa các thẻ HTML mới. Đâu là một trong những hạn chế đáng kể của việc sử dụng Custom Elements mà không có Shadow DOM?",
      "options": [
        "CSS được định nghĩa bên trong Custom Element có thể bị rò rỉ ra ngoài và ảnh hưởng đến phần còn lại của trang, phá vỡ tính đóng gói.",
        "JavaScript bên trong Custom Element sẽ không thể truy cập DOM của trang cha, gây khó khăn trong việc tương tác.",
        "Custom Elements không thể thừa kế thuộc tính từ các phần tử HTML tiêu chuẩn, làm giảm khả năng tái sử dụng.",
        "Hiệu suất rendering của các trang chứa nhiều Custom Elements sẽ bị giảm đáng kể do quá trình parsing phức tạp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 7,
      "topicId": 1,
      "question": "Thuộc tính `loading=\"lazy\"` trên thẻ `<img>` và `<iframe>` hoạt động như thế nào, và lợi ích chính của nó đối với hiệu suất tải trang là gì?",
      "options": [
        "Nó chỉ thị trình duyệt hoãn tải tài nguyên (hình ảnh hoặc iframe) cho đến khi chúng gần hoặc nằm trong viewport của người dùng, giúp giảm thời gian tải ban đầu của trang và tiết kiệm băng thông.",
        "Nó bắt buộc trình duyệt tải ngay lập tức hình ảnh hoặc iframe, ưu tiên hơn các tài nguyên khác, để đảm bảo chúng hiển thị nhanh nhất có thể.",
        "Nó cho phép tải đồng thời nhiều hình ảnh và iframe cùng lúc, bất kể vị trí của chúng trên trang, để tăng tốc độ hiển thị tổng thể.",
        "Nó mã hóa tài nguyên trước khi tải để tăng cường bảo mật, đồng thời giải mã khi hiển thị, nhưng có thể làm chậm quá trình tải."
      ],
      "correctAnswer": 0
    },
    {
      "id": 8,
      "topicId": 1,
      "question": "Giải thích khái niệm **Semantic HTML** và tại sao việc sử dụng các thẻ HTML ngữ nghĩa (semantic tags) lại quan trọng cho cả SEO và khả năng truy cập (Accessibility).",
      "options": [
        "Semantic HTML là việc sử dụng các thẻ HTML mô tả rõ ràng ý nghĩa và cấu trúc nội dung của chúng (ví dụ: `<header>`, `<nav>`, `<article>`, `<footer>`). Điều này giúp công cụ tìm kiếm hiểu rõ hơn ngữ cảnh nội dung (cải thiện SEO) và hỗ trợ các công cụ đọc màn hình (screen readers) giải thích nội dung cho người dùng khuyết tật (cải thiện Accessibility).",
        "Semantic HTML là việc viết mã HTML ngắn gọn, ít thẻ nhất có thể để giảm kích thước file. Điều này giúp tải trang nhanh hơn và dễ dàng đọc hơn cho lập trình viên.",
        "Semantic HTML là việc sử dụng JavaScript để tạo ra các phần tử HTML động, giúp trang web tương tác tốt hơn với người dùng. Điều này không ảnh hưởng trực tiếp đến SEO hay Accessibility.",
        "Semantic HTML là việc đặt các thuộc tính `id` và `class` một cách có ý nghĩa để dễ dàng nhắm mục tiêu bằng CSS và JavaScript. Điều này chỉ có lợi cho việc phát triển, không liên quan đến SEO hay Accessibility."
      ],
      "correctAnswer": 0
    },
    {
      "id": 9,
      "topicId": 1,
      "question": "Trình duyệt sẽ xử lý tài nguyên được tải qua `<link rel=\"preconnect\" href=\"...\">` khác với `<link rel=\"dns-prefetch\" href=\"...\">` như thế nào, và khi nào nên ưu tiên `preconnect`?",
      "options": [
        "`preconnect` yêu cầu trình duyệt thiết lập một kết nối (bao gồm DNS lookup, TCP handshake và TLS negotiation) sớm tới một nguồn gốc quan trọng, trong khi `dns-prefetch` chỉ thực hiện DNS lookup. Ưu tiên `preconnect` khi bạn chắc chắn sẽ cần tài nguyên từ nguồn gốc đó trong tương lai gần.",
        "`preconnect` chỉ tải các tài nguyên CSS, còn `dns-prefetch` tải các tài nguyên JavaScript. Ưu tiên `preconnect` cho các stylesheet và `dns-prefetch` cho các script.",
        "`preconnect` chặn rendering cho đến khi kết nối được thiết lập, còn `dns-prefetch` không chặn. Ưu tiên `preconnect` cho các tài nguyên không quan trọng.",
        "`preconnect` chỉ hoạt động với các nguồn gốc nội bộ, còn `dns-prefetch` hoạt động với các nguồn gốc bên ngoài. Ưu tiên `preconnect` cho nội bộ và `dns-prefetch` cho bên ngoài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 10,
      "topicId": 1,
      "question": "Mô tả cơ chế hoạt động của thuộc tính `crossorigin` trên thẻ `<script>` hoặc `<link>` và tầm quan trọng của nó trong việc xử lý các yêu cầu CORS (Cross-Origin Resource Sharing).",
      "options": [
        "Thuộc tính `crossorigin` kiểm soát việc các yêu cầu tài nguyên cross-origin có gửi thông tin xác thực (như cookie, HTTP authentication) hay không. Nó là bắt buộc để tải các script/stylesheet từ CDN để tránh lỗi CORS trong một số trường hợp, và cũng quan trọng cho việc báo cáo lỗi script cross-origin chính xác hơn.",
        "Thuộc tính `crossorigin` mã hóa nội dung của script hoặc stylesheet khi được tải từ một nguồn gốc khác, tăng cường bảo mật cho ứng dụng.",
        "Thuộc tính `crossorigin` chỉ cho phép tải tài nguyên từ các nguồn gốc đã được liệt kê trong danh sách trắng (whitelist) của trình duyệt, ngăn chặn các cuộc tấn công CSRF.",
        "Thuộc tính `crossorigin` buộc trình duyệt phải tải tài nguyên qua giao thức HTTPS, ngay cả khi URL gốc là HTTP, nhằm tăng cường bảo mật kết nối."
      ],
      "correctAnswer": 0
    },
    {
      "id": 11,
      "topicId": 1,
      "question": "Làm thế nào để nhúng nội dung SVG trực tiếp vào HTML (inline SVG) và những lợi ích cũng như hạn chế chính của phương pháp này so với việc sử dụng thẻ `<img>` để nhúng SVG?",
      "options": [
        "Nhúng SVG trực tiếp bằng cách dán mã `<svg>...</svg>` vào HTML. Lợi ích: có thể được style bằng CSS, tương tác bằng JS, không yêu cầu HTTP request riêng, độ nét cao trên mọi màn hình. Hạn chế: làm tăng kích thước file HTML, không thể cache riêng, phức tạp hơn cho nội dung SVG lớn.",
        "Nhúng SVG trực tiếp bằng cách sử dụng thuộc tính `src` trên thẻ `<object>` với file SVG. Lợi ích: đơn giản, có thể tái sử dụng. Hạn chế: không thể style bằng CSS từ trang cha, tương tác JS hạn chế.",
        "Nhúng SVG trực tiếp bằng cách sử dụng thuộc tính `background-image` trong CSS. Lợi ích: dễ dàng quản lý bằng CSS. Hạn chế: không thể tương tác bằng JS, không thể thay đổi màu sắc bằng CSS.",
        "Không thể nhúng SVG trực tiếp vào HTML; nó luôn cần được tải dưới dạng file riêng biệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 12,
      "topicId": 1,
      "question": "Giải thích vai trò của thuộc tính `defer` và `async` trên thẻ `<script>` và sự khác biệt về hành vi tải/thực thi script mà chúng mang lại.",
      "options": [
        "`defer` tải script song song với việc phân tích cú pháp HTML và thực thi script sau khi toàn bộ HTML được phân tích xong, theo đúng thứ tự xuất hiện. `async` tải script song song và thực thi ngay khi script tải xong, không đảm bảo thứ tự và có thể chặn phân tích cú pháp. Cả hai đều không chặn parsing HTML.",
        "`defer` và `async` đều chặn phân tích cú pháp HTML cho đến khi script được tải và thực thi, nhưng `defer` ưu tiên script nhỏ hơn.",
        "`defer` tải script sau khi trang đã tải hoàn toàn, trong khi `async` tải script ngay lập tức. `async` nên dùng cho các script quan trọng.",
        "`defer` chỉ dùng cho các script nội bộ, còn `async` dùng cho các script từ CDN. Cả hai đều không liên quan đến việc chặn parsing."
      ],
      "correctAnswer": 0
    },
    {
      "id": 13,
      "topicId": 1,
      "question": "Web Workers là gì và chúng giải quyết vấn đề hiệu suất nào trong ứng dụng web bằng cách nào?",
      "options": [
        "Web Workers cho phép các script chạy trong một luồng nền (background thread) riêng biệt, độc lập với luồng UI chính. Điều này giúp thực hiện các tác vụ nặng (ví dụ: tính toán phức tạp, xử lý dữ liệu lớn) mà không làm chặn hoặc đóng băng giao diện người dùng, cải thiện tính phản hồi của ứng dụng.",
        "Web Workers là một API cho phép lưu trữ dữ liệu cục bộ trên trình duyệt, giúp tăng tốc độ tải dữ liệu mà không cần gửi yêu cầu đến server.",
        "Web Workers là các công cụ để kiểm tra lỗi và debug mã JavaScript trên trình duyệt, giúp tăng hiệu suất phát triển.",
        "Web Workers là các thư viện JavaScript giúp tối ưu hóa việc tải các tài nguyên đa phương tiện (video, âm thanh) trên trang web, giảm độ trễ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 14,
      "topicId": 1,
      "question": "Sự khác biệt giữa thuộc tính `hidden` và `display: none` (CSS) trong HTML là gì về mặt ngữ nghĩa, khả năng truy cập (accessibility), và cách trình duyệt xử lý?",
      "options": [
        "`hidden` là một thuộc tính HTML mang ý nghĩa ngữ nghĩa rằng nội dung không còn liên quan hoặc có thể không hiển thị, và trình duyệt thường ẩn nó (giống `display: none`). Cả hai đều làm cho phần tử không hiển thị và không chiếm không gian, nhưng `hidden` có ý nghĩa hơn về mặt ngữ nghĩa và được assistive technologies (độc giả màn hình) tôn trọng tốt hơn.",
        "`hidden` sẽ giữ lại không gian của phần tử trong layout, trong khi `display: none` loại bỏ hoàn toàn phần tử khỏi luồng layout.",
        "`hidden` chỉ có thể được bật/tắt bằng JavaScript, còn `display: none` chỉ được kiểm soát bằng CSS.",
        "`hidden` làm cho phần tử không thể truy cập qua bàn phím, trong khi `display: none` vẫn cho phép tương tác với bàn phím."
      ],
      "correctAnswer": 0
    },
    {
      "id": 15,
      "topicId": 1,
      "question": "Thuộc tính `role` trong ARIA (Accessible Rich Internet Applications) có vai trò gì trong việc cải thiện khả năng truy cập và khi nào nên sử dụng nó?",
      "options": [
        "Thuộc tính `role` cung cấp ngữ nghĩa bổ sung cho các phần tử HTML mà bản thân chúng không có ngữ nghĩa rõ ràng (ví dụ: một `<div>` được dùng làm nút bấm). Nó giúp các công cụ đọc màn hình và assistive technologies hiểu được vai trò của phần tử, cải thiện trải nghiệm cho người dùng khuyết tật. Nên sử dụng khi phần tử DOM không có vai trò ngữ nghĩa mặc định phù hợp.",
        "Thuộc tính `role` dùng để định nghĩa các hàm JavaScript sẽ được thực thi khi phần tử tương tác với người dùng, giúp tăng tính tương tác của trang web.",
        "Thuộc tính `role` chỉ định loại dữ liệu mà phần tử có thể chứa, giúp trình duyệt kiểm tra tính hợp lệ của dữ liệu đầu vào.",
        "Thuộc tính `role` kiểm soát thứ tự tab (tab order) của các phần tử trên trang, giúp người dùng điều hướng dễ dàng hơn bằng bàn phím."
      ],
      "correctAnswer": 0
    },
    {
      "id": 16,
      "topicId": 1,
      "question": "Giải thích cơ chế hoạt động của `srcset` và `sizes` trong thẻ `<img>` và cách chúng hỗ trợ responsive images.",
      "options": [
        "`srcset` cung cấp danh sách các URL hình ảnh và kích thước tự nhiên của chúng (hoặc pixel density), trong khi `sizes` mô tả kích thước của hình ảnh trong CSS/layout tại các breakpoint khác nhau. Trình duyệt sử dụng thông tin này để chọn hình ảnh tối ưu nhất dựa trên viewport, độ phân giải màn hình và mật độ pixel của thiết bị.",
        "`srcset` chỉ định nguồn hình ảnh cho màn hình retina, còn `sizes` chỉ định nguồn hình ảnh cho màn hình non-retina.",
        "`srcset` và `sizes` đều dùng để tải hình ảnh dưới dạng lazy-loading, cải thiện hiệu suất tải trang.",
        "`srcset` cung cấp hình ảnh dưới dạng vector, còn `sizes` cung cấp hình ảnh dưới dạng raster, cho phép trình duyệt lựa chọn định dạng tốt nhất."
      ],
      "correctAnswer": 0
    },
    {
      "id": 17,
      "topicId": 1,
      "question": "Tại sao việc đặt các thẻ `<script>` ở cuối `<body>` (ngay trước thẻ đóng `</body>`) được coi là một best practice để cải thiện hiệu suất tải trang?",
      "options": [
        "Đặt script ở cuối `<body>` cho phép trình duyệt phân tích cú pháp và hiển thị nội dung HTML trước khi gặp và thực thi script, tránh việc script chặn quá trình rendering và cải thiện thời gian **First Contentful Paint (FCP)**.",
        "Đặt script ở cuối `<body>` giúp script có thể truy cập toàn bộ DOM ngay lập tức mà không cần đợi sự kiện `DOMContentLoaded`.",
        "Đặt script ở cuối `<body>` giúp giảm kích thước tải xuống ban đầu của HTML, vì các script sẽ được tải sau cùng.",
        "Đặt script ở cuối `<body>` là cách duy nhất để đảm bảo script được thực thi trong một môi trường sandbox, tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 18,
      "topicId": 1,
      "question": "Khái niệm 'Declarative Shadow DOM' là gì và lợi ích của nó so với 'Imperative Shadow DOM' trong bối cảnh Server-Side Rendering (SSR)?",
      "options": [
        "Declarative Shadow DOM cho phép bạn định nghĩa Shadow DOM trực tiếp trong HTML (sử dụng `<template shadowroot>`) thay vì phải tạo nó bằng JavaScript. Lợi ích chính là nội dung Shadow DOM có thể được render trên server, cải thiện thời gian **First Contentful Paint (FCP)** và giảm FOUC (Flash of Unstyled Content) khi SSR Web Components.",
        "Declarative Shadow DOM là một phiên bản cũ hơn của Shadow DOM, ít mạnh mẽ hơn Imperative Shadow DOM.",
        "Declarative Shadow DOM cho phép bạn sử dụng CSS Preprocessors bên trong Shadow DOM mà không cần biên dịch trước.",
        "Declarative Shadow DOM là một cách để nhúng Shadow DOM từ một iframe, giúp tăng cường bảo mật cho các Web Components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 19,
      "topicId": 1,
      "question": "Khi sử dụng thẻ `<picture>` để phục vụ responsive images, bạn sẽ cấu hình nó như thế nào để cung cấp các định dạng ảnh khác nhau (ví dụ: WebP, AVIF) cho các trình duyệt hỗ trợ?",
      "options": [
        "Sử dụng nhiều thẻ `<source>` bên trong thẻ `<picture>`, mỗi thẻ `<source>` có thuộc tính `type` để chỉ định định dạng hình ảnh và `srcset` để cung cấp các phiên bản ảnh. Trình duyệt sẽ chọn thẻ `<source>` đầu tiên mà nó hỗ trợ, sau đó fallback về thẻ `<img>` tiêu chuẩn nếu không có định dạng nào phù hợp.",
        "Sử dụng một thẻ `<img>` duy nhất với thuộc tính `type` để chỉ định định dạng ưu tiên và trình duyệt sẽ tự động chuyển đổi nếu không hỗ trợ.",
        "Sử dụng CSS `background-image` với nhiều URL và `image-set` để trình duyệt chọn định dạng tốt nhất.",
        "Sử dụng JavaScript để phát hiện khả năng hỗ trợ định dạng của trình duyệt và sau đó động thay đổi thuộc tính `src` của thẻ `<img>`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 20,
      "topicId": 1,
      "question": "Phân biệt giữa `window.onload` và `document.DOMContentLoaded` về thời điểm kích hoạt và ý nghĩa của chúng đối với việc thực thi JavaScript.",
      "options": [
        "`DOMContentLoaded` kích hoạt khi DOM đã được tải và phân tích cú pháp hoàn toàn, nhưng các tài nguyên như ảnh và stylesheet có thể chưa tải xong. `window.onload` kích hoạt khi toàn bộ trang, bao gồm tất cả các tài nguyên phụ (ảnh, stylesheet), đã tải xong hoàn toàn. `DOMContentLoaded` thường kích hoạt sớm hơn và được ưu tiên cho các script tương tác với DOM.",
        "`DOMContentLoaded` kích hoạt sau `window.onload`, đảm bảo tất cả các hình ảnh đã được hiển thị.",
        "Cả hai đều kích hoạt cùng lúc, nhưng `window.onload` chỉ dành cho JavaScript bên ngoài, còn `DOMContentLoaded` dành cho JavaScript nhúng.",
        "`window.onload` chỉ kích hoạt khi người dùng tương tác với trang, còn `DOMContentLoaded` kích hoạt ngay lập tức khi tải trang."
      ],
      "correctAnswer": 0
    },
    {
      "id": 21,
      "topicId": 1,
      "question": "Thuộc tính `loading=\"eager\"` (explicit loading) trên thẻ `<img>` và `<iframe>` có ý nghĩa gì và khi nào nên sử dụng nó thay vì `lazy`?",
      "options": [
        "`loading=\"eager\"` chỉ thị trình duyệt tải tài nguyên (hình ảnh hoặc iframe) ngay lập tức, bất kể vị trí của chúng trên trang, ưu tiên hơn các tài nguyên khác. Nên sử dụng cho các hình ảnh hoặc iframe quan trọng nằm trong viewport ban đầu của người dùng, để đảm bảo chúng hiển thị nhanh chóng.",
        "`loading=\"eager\"` buộc trình duyệt mã hóa tài nguyên trước khi tải, tăng cường bảo mật nhưng làm chậm quá trình hiển thị.",
        "`loading=\"eager\"` chỉ cho phép tải tài nguyên nếu người dùng có kết nối mạng nhanh, giúp tiết kiệm dữ liệu cho người dùng có kết nối chậm.",
        "`loading=\"eager\"` là hành vi mặc định của trình duyệt và không cần phải khai báo rõ ràng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 22,
      "topicId": 1,
      "question": "Vai trò của thuộc tính `ping` trên thẻ `<a>` là gì và nó được sử dụng trong ngữ cảnh nào?",
      "options": [
        "Thuộc tính `ping` cho phép trình duyệt gửi một yêu cầu POST nhỏ đến các URL được chỉ định khi người dùng click vào liên kết, thường được dùng để theo dõi click hoặc gửi thông báo. Điều này diễn ra trong nền và không ảnh hưởng đến điều hướng của người dùng.",
        "Thuộc tính `ping` dùng để kiểm tra xem URL đích có hoạt động hay không trước khi điều hướng, hiển thị lỗi nếu không truy cập được.",
        "Thuộc tính `ping` cho phép trình duyệt tải trước nội dung của liên kết đích để tăng tốc độ điều hướng.",
        "Thuộc tính `ping` ngăn chặn các công cụ tìm kiếm theo dõi liên kết này, giúp quản lý quyền riêng tư."
      ],
      "correctAnswer": 0
    },
    {
      "id": 23,
      "topicId": 1,
      "question": "Cách sử dụng thẻ `<template>` và `<slot>` trong Web Components để tạo nội dung có thể tùy chỉnh và lặp lại là gì?",
      "options": [
        "Thẻ `<template>` dùng để định nghĩa các khối HTML sẽ được render lại nhiều lần trong các Web Component, còn `<slot>` là placeholder trong Shadow DOM của component, cho phép chèn nội dung tùy chỉnh từ bên ngoài vào. Điều này giúp tạo ra các component linh hoạt và có khả năng tái sử dụng cao.",
        "Thẻ `<template>` dùng để định nghĩa các thành phần CSS có thể tái sử dụng, còn `<slot>` dùng để định nghĩa các biến CSS.",
        "Thẻ `<template>` dùng để tạo ra các animation động, còn `<slot>` dùng để điều khiển tốc độ animation.",
        "Thẻ `<template>` và `<slot>` là các thẻ HTML cũ không còn được sử dụng trong phát triển web hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 24,
      "topicId": 1,
      "question": "Thuộc tính `nomodule` trên thẻ `<script>` được sử dụng để làm gì và nó hỗ trợ các trình duyệt cũ như thế nào khi bạn dùng JavaScript Modules?",
      "options": [
        "Thuộc tính `nomodule` được dùng trên các script fallback chứa mã JavaScript cũ (non-module) để chỉ định rằng script này chỉ nên được thực thi bởi các trình duyệt không hỗ trợ JavaScript Modules. Các trình duyệt hiện đại sẽ bỏ qua script có `nomodule`.",
        "Thuộc tính `nomodule` ngăn chặn script được tải nếu trình duyệt không hỗ trợ WebGL, giúp tiết kiệm băng thông.",
        "Thuộc tính `nomodule` buộc script phải chạy trong chế độ nghiêm ngặt (strict mode) của JavaScript.",
        "Thuộc tính `nomodule` cho phép script được tải nhưng không thực thi cho đến khi có sự kiện từ người dùng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 25,
      "topicId": 1,
      "question": "Mô tả ý nghĩa của thuộc tính `integrity` (Subresource Integrity - SRI) trên thẻ `<script>` hoặc `<link>` và tầm quan trọng của nó đối với bảo mật.",
      "options": [
        "Thuộc tính `integrity` chứa một giá trị hash (băm) của nội dung script hoặc stylesheet. Trình duyệt sẽ chỉ thực thi hoặc áp dụng tài nguyên nếu hash của tài nguyên tải về khớp với giá trị `integrity` đã cung cấp. Điều này ngăn chặn các cuộc tấn công thay đổi nội dung (tampering) trên CDN hoặc các máy chủ bên thứ ba, tăng cường bảo mật.",
        "Thuộc tính `integrity` kiểm tra xem script có được ký số bởi nhà phát triển gốc hay không, đảm bảo tính xác thực.",
        "Thuộc tính `integrity` mã hóa nội dung của script trước khi truyền tải, bảo vệ dữ liệu khỏi bị nghe lén.",
        "Thuộc tính `integrity` giúp trình duyệt xác định xem tài nguyên có bị lỗi khi tải xuống hay không và tự động yêu cầu lại nếu cần."
      ],
      "correctAnswer": 0
    },
    {
      "id": 26,
      "topicId": 1,
      "question": "Khái niệm 'render-blocking resources' là gì và làm thế nào để tối ưu hóa chúng trong HTML để cải thiện Core Web Vitals (ví dụ: LCP)?",
      "options": [
        "Render-blocking resources là các tài nguyên (thường là CSS và JavaScript) mà trình duyệt phải tải, phân tích cú pháp và thực thi trước khi có thể hiển thị nội dung trang. Tối ưu hóa bằng cách: sử dụng thuộc tính `async`/`defer` cho script, inline CSS quan trọng (`critical CSS`), và sử dụng `rel=\"preload\"` cho các font/tài nguyên quan trọng khác.",
        "Render-blocking resources là các tài nguyên đa phương tiện như video và âm thanh. Tối ưu hóa bằng cách nén chúng thật nhỏ.",
        "Render-blocking resources là các hình ảnh có kích thước lớn. Tối ưu hóa bằng cách sử dụng lazy loading.",
        "Render-blocking resources là các yêu cầu API chậm. Tối ưu hóa bằng cách sử dụng caching."
      ],
      "correctAnswer": 0
    },
    {
      "id": 27,
      "topicId": 1,
      "question": "Thẻ `<base>` trong HTML có tác dụng gì và những rủi ro tiềm ẩn khi sử dụng nó, đặc biệt trong các ứng dụng SPA (Single Page Application)?",
      "options": [
        "Thẻ `<base>` định nghĩa URL cơ sở cho tất cả các URL tương đối trong tài liệu (bao gồm hình ảnh, script, stylesheet, và liên kết). Rủi ro trong SPA là nó có thể làm hỏng định tuyến client-side hoặc việc tải tài nguyên động nếu không được quản lý cẩn thận, do tất cả các URL tương đối sẽ dựa vào base URL này.",
        "Thẻ `<base>` dùng để nhúng các tài liệu HTML khác vào trang hiện tại, tương tự như iframe nhưng an toàn hơn.",
        "Thẻ `<base>` dùng để khai báo các biến môi trường cho JavaScript, giúp quản lý cấu hình ứng dụng.",
        "Thẻ `<base>` là một thẻ HTML cũ không còn được sử dụng trong các trình duyệt hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 28,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `nonce` trong chính sách bảo mật nội dung (Content Security Policy - CSP) và cách nó giúp giảm thiểu các cuộc tấn công XSS.",
      "options": [
        "Thuộc tính `nonce` (number used once) là một chuỗi ngẫu nhiên duy nhất được tạo ra cho mỗi yêu cầu trang và được đặt trong các thẻ `<script>` hoặc `<style>`. Nó phải khớp với giá trị `nonce` được chỉ định trong header CSP. Điều này cho phép trình duyệt chỉ thực thi hoặc áp dụng các script/style có `nonce` hợp lệ, ngăn chặn việc thực thi mã độc được tiêm vào (XSS).",
        "Thuộc tính `nonce` mã hóa nội dung của script trước khi gửi đi, bảo vệ khỏi bị nghe lén.",
        "Thuộc tính `nonce` giới hạn thời gian tồn tại của script trên trình duyệt, giúp tự động xóa các script lỗi thời.",
        "Thuộc tính `nonce` xác minh danh tính của người dùng trước khi cho phép script chạy, tăng cường xác thực."
      ],
      "correctAnswer": 0
    },
    {
      "id": 29,
      "topicId": 1,
      "question": "Thẻ `<dialog>` trong HTML5 có ý nghĩa gì và cách nó hỗ trợ xây dựng các UI components tương tác như modal/popup một cách ngữ nghĩa và khả năng truy cập tốt hơn?",
      "options": [
        "Thẻ `<dialog>` đại diện cho một hộp thoại hoặc thành phần tương tác (như alert, inspector, window). Nó đi kèm với các hành vi mặc định cho khả năng truy cập (quản lý tiêu điểm, thoát bằng Esc) và có thể mở/đóng bằng phương thức JavaScript (`show()`, `showModal()`, `close()`), giúp xây dựng modal mà không cần thư viện bên thứ ba và thân thiện với assistive technologies.",
        "Thẻ `<dialog>` dùng để hiển thị các thông báo lỗi hoặc cảnh báo cho người dùng, tương tự như `alert()` của JavaScript.",
        "Thẻ `<dialog>` là một phần tử dùng để tạo form thu thập ý kiến người dùng, tương tự như `<form>` nhưng có giao diện đẹp hơn.",
        "Thẻ `<dialog>` là một loại container cho nội dung đa phương tiện, giúp tối ưu hóa việc tải video và âm thanh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 30,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Critical Rendering Path' (CRP) và các bước chính trong quá trình trình duyệt chuyển đổi HTML, CSS, và JavaScript thành pixels trên màn hình.",
      "options": [
        "Critical Rendering Path là chuỗi các bước mà trình duyệt phải thực hiện để chuyển đổi HTML, CSS và JavaScript thành pixels trên màn hình càng nhanh càng tốt. Các bước chính bao gồm: **DOM Tree** (từ HTML), **CSSOM Tree** (từ CSS), kết hợp thành **Render Tree**, sau đó là **Layout** (Reflow) và cuối cùng là **Paint** (hoặc Compositing).",
        "Critical Rendering Path là đường dẫn tối ưu mà server sử dụng để gửi dữ liệu về cho trình duyệt, giảm thiểu độ trễ mạng.",
        "Critical Rendering Path là quá trình mà JavaScript thực thi để tạo ra DOM ảo, tăng tốc độ cập nhật giao diện.",
        "Critical Rendering Path là lộ trình mà người dùng di chuyển trên trang web, ảnh hưởng đến thứ tự tải các tài nguyên."
      ],
      "correctAnswer": 0
    },
    {
      "id": 31,
      "topicId": 1,
      "question": "Thuộc tính `inputmode` trong HTML5 có vai trò gì đối với trải nghiệm người dùng trên thiết bị di động?",
      "options": [
        "Thuộc tính `inputmode` cung cấp gợi ý cho trình duyệt về loại bàn phím ảo nên hiển thị cho trường nhập liệu, giúp người dùng nhập dữ liệu dễ dàng hơn (ví dụ: `numeric` cho số, `email` cho email).",
        "Thuộc tính `inputmode` kiểm soát việc có hiển thị placeholder text hay không trong trường nhập liệu.",
        "Thuộc tính `inputmode` xác định xem trường nhập liệu có thể nhận dữ liệu từ microphone hay không.",
        "Thuộc tính `inputmode` mã hóa dữ liệu nhập vào trước khi gửi đến server, tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 32,
      "topicId": 1,
      "question": "Thẻ `<details>` và `<summary>` trong HTML có tác dụng gì và chúng được sử dụng để xây dựng những loại UI component nào một cách ngữ nghĩa mà không cần JavaScript?",
      "options": [
        "Thẻ `<details>` tạo ra một widget tiết lộ (disclosure widget) mà người dùng có thể mở/đóng. Thẻ `<summary>` cung cấp tiêu đề hoặc tóm tắt cho nội dung của `<details>`. Chúng được dùng để tạo các accordion, collapsible sections, hoặc FAQ mà không cần JS, đồng thời thân thiện với khả năng truy cập.",
        "Thẻ `<details>` dùng để hiển thị các thông báo lỗi chi tiết, còn `<summary>` là tiêu đề của thông báo lỗi.",
        "Thẻ `<details>` dùng để nhúng các video clip ngắn, còn `<summary>` là mô tả của video.",
        "Thẻ `<details>` và `<summary>` là các thẻ HTML cũ không còn được khuyến khích sử dụng trong phát triển web hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 33,
      "topicId": 1,
      "question": "Giải thích sự khác biệt giữa `aria-label` và `aria-labelledby` trong ARIA và khi nào nên sử dụng từng thuộc tính để cải thiện khả năng truy cập.",
      "options": [
        "`aria-label` cung cấp một nhãn văn bản mô tả cho một phần tử khi không có văn bản hiển thị nào phù hợp. `aria-labelledby` trỏ đến `id` của một phần tử khác trên trang để sử dụng nội dung của phần tử đó làm nhãn cho phần tử hiện tại. Nên dùng `aria-label` khi không có văn bản hiển thị phù hợp, và `aria-labelledby` khi nhãn đã tồn tại dưới dạng phần tử khác.",
        "`aria-label` chỉ dùng cho các nút bấm, còn `aria-labelledby` chỉ dùng cho các trường nhập liệu.",
        "`aria-label` được đọc bởi trình duyệt, còn `aria-labelledby` được đọc bởi screen readers.",
        "Không có sự khác biệt đáng kể giữa hai thuộc tính này; chúng có thể được sử dụng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 34,
      "topicId": 1,
      "question": "Khái niệm 'Intrinsic Sizing' trong HTML/CSS là gì và nó ảnh hưởng đến responsive design như thế nào?",
      "options": [
        "Intrinsic sizing là khả năng của một phần tử tự động điều chỉnh kích thước dựa trên nội dung của nó hoặc kích thước của container (ví dụ: `width: auto`, `max-content`). Điều này rất quan trọng trong responsive design vì nó cho phép các phần tử co giãn linh hoạt theo không gian có sẵn mà không cần định nghĩa kích thước cố định.",
        "Intrinsic sizing là việc sử dụng JavaScript để tính toán và thiết lập kích thước của phần tử dựa trên kích thước màn hình.",
        "Intrinsic sizing là việc buộc tất cả các phần tử phải có kích thước cố định để đảm bảo layout không bị phá vỡ.",
        "Intrinsic sizing chỉ áp dụng cho hình ảnh, cho phép chúng tự động điều chỉnh kích thước để vừa với container."
      ],
      "correctAnswer": 0
    },
    {
      "id": 35,
      "topicId": 1,
      "question": "Thẻ `<picture>` khác với việc sử dụng `srcset` và `sizes` trên thẻ `<img>` như thế nào trong việc quản lý responsive images?",
      "options": [
        "Thẻ `<picture>` cho phép kiểm soát việc chọn hình ảnh dựa trên **loại định dạng file** (ví dụ: WebP, AVIF) hoặc **điều kiện media query phức tạp hơn** (ví dụ: hướng ảnh - landscape/portrait), trong khi `srcset`/`sizes` trên `<img>` chủ yếu tập trung vào việc chọn ảnh dựa trên **độ phân giải màn hình hoặc kích thước hiển thị**.",
        "Thẻ `<picture>` chỉ dùng cho ảnh vector, còn `srcset`/`sizes` dùng cho ảnh raster.",
        "Thẻ `<picture>` là cách cũ để làm responsive images, còn `srcset`/`sizes` là cách mới hơn và hiệu quả hơn.",
        "Thẻ `<picture>` cho phép thêm phụ đề vào ảnh, còn `srcset`/`sizes` thì không."
      ],
      "correctAnswer": 0
    },
    {
      "id": 36,
      "topicId": 1,
      "question": "Tại sao việc sử dụng các thẻ tiêu đề (heading tags `<h1>` đến `<h6>`) một cách hợp lý và theo thứ tự lại quan trọng đối với SEO và khả năng truy cập?",
      "options": [
        "Các thẻ tiêu đề cung cấp cấu trúc ngữ nghĩa cho tài liệu, giúp công cụ tìm kiếm hiểu được cấu trúc và tầm quan trọng của nội dung (SEO). Đồng thời, chúng giúp người dùng có khả năng truy cập (đặc biệt là người dùng screen reader) dễ dàng điều hướng và nắm bắt bố cục của trang.",
        "Các thẻ tiêu đề giúp làm cho văn bản lớn hơn và nổi bật hơn, thu hút sự chú ý của người dùng.",
        "Các thẻ tiêu đề được trình duyệt tự động cache để tải trang nhanh hơn trong các lần truy cập sau.",
        "Các thẻ tiêu đề là cách duy nhất để áp dụng style CSS cho văn bản đầu trang."
      ],
      "correctAnswer": 0
    },
    {
      "id": 37,
      "topicId": 1,
      "question": "Mô tả cơ chế hoạt động của WebSockets so với HTTP trong ngữ cảnh giao tiếp client-server và khi nào nên ưu tiên WebSockets?",
      "options": [
        "WebSockets cung cấp một kênh giao tiếp hai chiều, full-duplex, liên tục và dựa trên kết nối persistent (duy trì) giữa client và server. Không giống HTTP là request-response không trạng thái, WebSockets cho phép server chủ động đẩy dữ liệu đến client. Ưu tiên WebSockets cho các ứng dụng yêu cầu cập nhật dữ liệu thời gian thực như chat, game, thông báo.",
        "WebSockets chỉ hoạt động trên giao thức HTTPS, trong khi HTTP có thể dùng cả HTTP và HTTPS.",
        "WebSockets chỉ cho phép client gửi dữ liệu đến server, không cho phép server đẩy dữ liệu đến client.",
        "WebSockets yêu cầu nhiều tài nguyên server hơn HTTP và chỉ nên dùng cho các ứng dụng có lượng truy cập thấp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 38,
      "topicId": 1,
      "question": "Thuộc tính `popover` mới trong HTML (đang trong quá trình chuẩn hóa) có tác dụng gì và lợi ích của nó so với việc tự xây dựng các thành phần popover bằng JavaScript?",
      "options": [
        "Thuộc tính `popover` cho phép một phần tử trở thành một popover (như tooltip, menu, dialog) hiển thị lớp trên cùng của UI. Lợi ích là nó xử lý các vấn đề phức tạp về khả năng truy cập (quản lý tiêu điểm, thoát bằng Esc), layering, và tương tác ngoài hộp một cách tự động, giảm đáng kể lượng JavaScript cần viết.",
        "Thuộc tính `popover` cho phép người dùng xem trước nội dung của một liên kết khi di chuột qua nó.",
        "Thuộc tính `popover` là một cách để nhúng video quảng cáo vào trang web một cách không gây phiền nhiễu.",
        "Thuộc tính `popover` tạo ra một widget tìm kiếm trên trang, giúp người dùng tìm kiếm nội dung nhanh chóng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 39,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Content Security Policy' (CSP) và cách nó giúp bảo vệ ứng dụng web khỏi các cuộc tấn công tiêm mã (injection attacks) như XSS.",
      "options": [
        "CSP là một header phản hồi HTTP hoặc thẻ meta trong HTML, cho phép bạn chỉ định các nguồn đáng tin cậy cho tài nguyên (script, style, hình ảnh, font, v.v.). Trình duyệt sẽ chỉ tải và thực thi tài nguyên từ các nguồn này, ngăn chặn các cuộc tấn công XSS bằng cách chặn thực thi mã độc từ các nguồn không đáng tin cậy.",
        "CSP mã hóa tất cả nội dung trên trang web để ngăn chặn truy cập trái phép.",
        "CSP là một công cụ giúp kiểm tra lỗi cú pháp HTML và CSS, đảm bảo mã sạch hơn.",
        "CSP tự động nén tất cả tài nguyên để tăng tốc độ tải trang."
      ],
      "correctAnswer": 0
    },
    {
      "id": 40,
      "topicId": 1,
      "question": "Sự khác biệt giữa `<iframe>` với thuộc tính `sandbox` và một Web Worker trong việc chạy mã độc lập là gì?",
      "options": [
        "`<iframe>` với `sandbox` tạo ra một môi trường cách ly cho nội dung được nhúng, giới hạn các quyền của nó (ví dụ: không truy cập localStorage, không chạy script nếu không được cho phép). Web Worker chạy script trong một luồng nền riêng biệt, không có quyền truy cập trực tiếp vào DOM nhưng vẫn chạy trong cùng một nguồn gốc. `sandbox` là về cách ly bảo mật nội dung, còn Web Worker là về xử lý tác vụ nặng mà không chặn UI.",
        "`<iframe>` với `sandbox` chỉ dùng để hiển thị nội dung tĩnh, còn Web Worker dùng để chạy các script động.",
        "`<iframe>` với `sandbox` cho phép truy cập DOM từ trang cha, còn Web Worker không có quyền đó.",
        "`<iframe>` với `sandbox` yêu cầu kết nối internet, còn Web Worker có thể chạy offline."
      ],
      "correctAnswer": 0
    },
    {
      "id": 41,
      "topicId": 1,
      "question": "Thẻ `<picture>` và các thuộc tính `srcset`/`sizes` trên `<img>` có phải là giải pháp duy nhất cho responsive images không? Hãy nêu một giải pháp khác và ưu/nhược điểm.",
      "options": [
        "Không phải là duy nhất. Một giải pháp khác là sử dụng CSS `background-image` với `media-queries` hoặc `image-set()`. Ưu điểm: linh hoạt hơn cho hình ảnh trang trí, dễ kiểm soát bằng CSS. Nhược điểm: không phải lúc nào cũng tối ưu về hiệu suất như `<picture>`/`srcset` vì trình duyệt có thể tải tất cả ảnh và không có khả năng lazy load tự động như `<img>`.",
        "Có, chúng là giải pháp duy nhất và tiêu chuẩn.",
        "Một giải pháp khác là dùng JavaScript để thay đổi `src` của ảnh dựa vào kích thước màn hình. Ưu điểm: kiểm soát hoàn toàn. Nhược điểm: có thể gây giật lag do tải ảnh không đồng bộ và không thân thiện SEO.",
        "Một giải pháp khác là sử dụng SVG. Ưu điểm: độ nét cao, kích thước file nhỏ. Nhược điểm: chỉ phù hợp cho đồ họa vector, không phù hợp cho ảnh chụp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 42,
      "topicId": 1,
      "question": "Mô tả cách thức **Client-Side Rendering (CSR)** ảnh hưởng đến SEO và trải nghiệm người dùng ban đầu so với **Server-Side Rendering (SSR)**.",
      "options": [
        "CSR tải một HTML rỗng hoặc tối thiểu, sau đó JavaScript sẽ tải dữ liệu và dựng nội dung trên client. Điều này có thể gây ra thời gian tải ban đầu (FCP, LCP) chậm hơn và gặp thách thức về SEO vì bot tìm kiếm có thể gặp khó khăn khi index nội dung được tạo động. SSR dựng toàn bộ HTML trên server, gửi về client một trang đã hoàn chỉnh, giúp FCP/LCP nhanh hơn và thân thiện hơn với SEO, nhưng có thể tăng tải cho server.",
        "CSR luôn nhanh hơn SSR về mọi mặt vì nó tận dụng sức mạnh xử lý của client.",
        "CSR không ảnh hưởng đến SEO, trong khi SSR làm giảm khả năng index của công cụ tìm kiếm.",
        "CSR tốt hơn cho các trang web tĩnh, còn SSR tốt hơn cho các ứng dụng web động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 43,
      "topicId": 1,
      "question": "Thẻ `<meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">` có vai trò gì trong responsive design và điều gì xảy ra nếu thiếu nó?",
      "options": [
        "Thẻ này chỉ thị cho trình duyệt rằng trang web nên được hiển thị với chiều rộng bằng chiều rộng thiết bị (`width=device-width`) và tỷ lệ zoom ban đầu là 1.0. Nếu thiếu, trình duyệt di động có thể render trang ở kích thước màn hình desktop rồi thu nhỏ lại, gây ra trải nghiệm người dùng tệ và không tối ưu cho responsive design.",
        "Thẻ này buộc trình duyệt phải hiển thị trang web ở chế độ màn hình dọc, bất kể thiết bị nào.",
        "Thẻ này giúp tối ưu hóa việc sử dụng GPU khi render trang, tăng hiệu suất đồ họa.",
        "Thẻ này khai báo phiên bản HTML được sử dụng để trình duyệt có thể chọn chế độ tương thích."
      ],
      "correctAnswer": 0
    },
    {
      "id": 44,
      "topicId": 1,
      "question": "Làm thế nào để sử dụng thuộc tính `itemprop` và `itemtype` trong Microdata/Schema.org để cải thiện SEO thông qua dữ liệu có cấu trúc?",
      "options": [
        "`itemtype` định nghĩa loại thực thể (ví dụ: `http://schema.org/Article`), còn `itemprop` gán các thuộc tính cụ thể cho thực thể đó (ví dụ: `headline`, `author`). Điều này giúp công cụ tìm kiếm hiểu rõ hơn ngữ cảnh và chi tiết về nội dung trên trang, cho phép hiển thị **Rich Snippets** trong kết quả tìm kiếm.",
        "`itemprop` và `itemtype` được sử dụng để tạo ra các liên kết nội bộ trong trang web, tăng cường liên kết giữa các phần.",
        "`itemprop` và `itemtype` giúp nén dữ liệu HTML trước khi gửi đến trình duyệt, giảm kích thước tải xuống.",
        "`itemprop` và `itemtype` là các thuộc tính HTML tùy chỉnh chỉ dùng trong các ứng dụng web đặc biệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 45,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Content Editable' trong HTML và những lưu ý bảo mật, khả năng truy cập khi sử dụng nó.",
      "options": [
        "Thuộc tính `contenteditable` biến bất kỳ phần tử HTML nào thành một khu vực có thể chỉnh sửa trực tiếp bởi người dùng. Lưu ý bảo mật: phải cẩn thận với XSS nếu nội dung người dùng nhập không được sanitizing đúng cách. Khả năng truy cập: cần đảm bảo các thuộc tính ARIA phù hợp được sử dụng để thông báo cho assistive technologies rằng phần tử có thể chỉnh sửa và vai trò của nó.",
        "Content Editable là một công cụ giúp kiểm tra lỗi ngữ pháp và chính tả trong nội dung HTML.",
        "Content Editable cho phép người dùng tải lên và chỉnh sửa hình ảnh trực tiếp trên trình duyệt.",
        "Content Editable là một API cho phép tạo ra các tài liệu PDF trực tiếp từ nội dung HTML."
      ],
      "correctAnswer": 0
    },
    {
      "id": 46,
      "topicId": 1,
      "question": "WebC (Web Components) bao gồm những tiêu chuẩn nào và mối quan hệ của chúng trong việc tạo ra các component độc lập và có khả năng tái sử dụng?",
      "options": [
        "Web Components bao gồm: **Custom Elements** (định nghĩa thẻ HTML mới), **Shadow DOM** (đóng gói CSS & DOM), **HTML Templates** (`<template>` và `<slot>` cho các khối HTML có thể tái sử dụng). Các tiêu chuẩn này làm việc cùng nhau để tạo ra các thành phần UI có tính đóng gói cao, tương tác độc lập, và có thể tái sử dụng trên mọi framework hoặc không có framework nào.",
        "Web Components bao gồm: WebSockets, Web Storage và Web Workers, tất cả đều liên quan đến việc giao tiếp mạng.",
        "Web Components bao gồm: CSS Grid, CSS Flexbox và CSS Variables, tất cả đều liên quan đến bố cục trang.",
        "Web Components là một framework JavaScript độc quyền của Google, không phải là tiêu chuẩn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 47,
      "topicId": 1,
      "question": "Thuộc tính `popstate` event trong JavaScript liên quan đến API History của trình duyệt được sử dụng như thế nào trong các ứng dụng SPA (Single Page Application)?",
      "options": [
        "Sự kiện `popstate` được kích hoạt khi trạng thái lịch sử của session thay đổi (ví dụ: khi người dùng nhấn nút Back/Forward của trình duyệt). Nó được sử dụng trong SPA để phát hiện sự thay đổi URL (do `pushState` hoặc `replaceState` thay đổi trạng thái URL mà không tải lại trang) và cập nhật giao diện người dùng tương ứng mà không cần reload trang.",
        "Sự kiện `popstate` được kích hoạt khi một cửa sổ popup mới được mở hoặc đóng.",
        "Sự kiện `popstate` chỉ được kích hoạt khi người dùng tải lại trang thủ công.",
        "Sự kiện `popstate` dùng để phát hiện khi trình duyệt bị đóng và lưu trạng thái ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 48,
      "topicId": 1,
      "question": "Khi nào nên sử dụng thuộc tính `async` hoặc `defer` cho script, và khi nào nên bỏ qua chúng?",
      "options": [
        "Sử dụng `async` cho các script độc lập không phụ thuộc vào DOM hoặc các script khác, vì chúng sẽ tải và thực thi bất đồng bộ. Sử dụng `defer` cho các script cần DOM hoặc phụ thuộc vào thứ tự thực thi của các script khác, vì chúng sẽ thực thi sau khi DOM sẵn sàng và theo thứ tự. Bỏ qua cả hai (mặc định) khi script cần chặn rendering để đảm bảo nội dung hoặc giao diện hiển thị chính xác ngay lập tức (ví dụ: critical CSS in JS).",
        "Luôn luôn sử dụng `async` để tối ưu hóa hiệu suất, không bao giờ bỏ qua nó.",
        "Luôn luôn sử dụng `defer` để đảm bảo thứ tự thực thi script, không bao giờ bỏ qua nó.",
        "Chỉ sử dụng `async` hoặc `defer` khi script được tải từ một CDN bên ngoài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 49,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `sizes` trên thẻ `<link rel=\"icon\" ...>` và cách nó ảnh hưởng đến biểu tượng trang web (favicon).",
      "options": [
        "Thuộc tính `sizes` chỉ định kích thước (chiều rộng x chiều cao) của biểu tượng trang web (favicon) được cung cấp. Nó giúp trình duyệt chọn phiên bản biểu tượng có kích thước phù hợp nhất cho các ngữ cảnh khác nhau (thanh địa chỉ, tab, shortcut trên màn hình chính, v.v.), đảm bảo biểu tượng hiển thị sắc nét trên mọi thiết bị và độ phân giải.",
        "Thuộc tính `sizes` chỉ định kích thước tối đa mà biểu tượng có thể được nén để giảm dung lượng file.",
        "Thuộc tính `sizes` dùng để khai báo số lượng biểu tượng khác nhau mà trang web cung cấp.",
        "Thuộc tính `sizes` chỉ có tác dụng với các biểu tượng động (animated favicons)."
      ],
      "correctAnswer": 0
    },
    {
      "id": 50,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Shadow DOM slotting' (hoặc 'Content Distribution') và cách nó cho phép các Web Components linh hoạt hơn trong việc chèn nội dung.",
      "options": [
        "Shadow DOM slotting là cơ chế cho phép nhà phát triển 'chèn' nội dung từ Light DOM (DOM bình thường của trang) vào các vị trí được chỉ định ('slots') bên trong Shadow DOM của một Web Component. Điều này cho phép component có một cấu trúc bên trong được đóng gói nhưng vẫn linh hoạt nhận các phần nội dung khác nhau từ bên ngoài, ví dụ như tiêu đề hoặc phần thân của một card component.",
        "Shadow DOM slotting là cách để tạo ra nhiều Shadow DOM khác nhau trên cùng một phần tử HTML.",
        "Shadow DOM slotting là một kỹ thuật tối ưu hóa hiệu suất cho phép tải bất đồng bộ các phần của Shadow DOM.",
        "Shadow DOM slotting là một cách để chia sẻ style giữa các Shadow DOM khác nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 51,
      "topicId": 1,
      "question": "Thuộc tính `fetchpriority` mới (hinting API) trên thẻ `<img>`, `<link>`, và `<script>` có vai trò gì và cách nó ảnh hưởng đến hiệu suất tải trang?",
      "options": [
        "Thuộc tính `fetchpriority` gợi ý cho trình duyệt về mức độ ưu tiên tải của một tài nguyên (ví dụ: `high`, `low`, `auto`). Điều này giúp trình duyệt tối ưu hóa thứ tự tải tài nguyên, ưu tiên các tài nguyên quan trọng để cải thiện **Largest Contentful Paint (LCP)** và **First Contentful Paint (FCP)**.",
        "Thuộc tính `fetchpriority` kiểm soát việc tài nguyên có được tải qua HTTP/3 hay không.",
        "Thuộc tính `fetchpriority` quy định số lần tài nguyên được phép yêu cầu lại nếu tải thất bại.",
        "Thuộc tính `fetchpriority` chỉ áp dụng cho tài nguyên được tải từ CDN."
      ],
      "correctAnswer": 0
    },
    {
      "id": 52,
      "topicId": 1,
      "question": "Vai trò của thuộc tính `popovertarget` trong HTML (kết hợp với `popover`) là gì và nó giúp đơn giản hóa việc tạo popover như thế nào?",
      "options": [
        "Thuộc tính `popovertarget` được đặt trên một phần tử điều khiển (ví dụ: nút bấm) và trỏ đến `id` của một phần tử `popover`. Khi phần tử điều khiển được kích hoạt, nó sẽ tự động mở hoặc đóng phần tử `popover` tương ứng mà không cần bất kỳ JavaScript nào để quản lý trạng thái hiển thị.",
        "Thuộc tính `popovertarget` dùng để định nghĩa nội dung mặc định sẽ hiển thị trong popover khi nó được mở.",
        "Thuộc tính `popovertarget` chỉ định vị trí mà popover sẽ xuất hiện trên màn hình.",
        "Thuộc tính `popovertarget` là một cách để truyền dữ liệu từ phần tử điều khiển sang popover."
      ],
      "correctAnswer": 0
    },
    {
      "id": 53,
      "topicId": 1,
      "question": "Sự khác biệt giữa `window.location.href = '...'` và `window.history.pushState('...', '...', '...')` trong việc thay đổi URL trình duyệt là gì, đặc biệt trong các SPA?",
      "options": [
        "`window.location.href = '...'` sẽ tải lại toàn bộ trang, trong khi `window.history.pushState` thay đổi URL trên thanh địa chỉ và thêm một mục vào lịch sử duyệt web mà không tải lại trang. `pushState` là cách chính để quản lý định tuyến trong SPA.",
        "Cả hai đều tải lại trang, nhưng `pushState` an toàn hơn về mặt bảo mật.",
        "`window.location.href` không thể thay đổi URL mà không tải lại trang.",
        "`pushState` chỉ hoạt động với các URL cùng nguồn gốc, còn `window.location.href` thì không."
      ],
      "correctAnswer": 0
    },
    {
      "id": 54,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Declarative Custom Elements' và lợi ích của chúng trong việc tăng tốc thời gian **Time to Interactive (TTI)** cho Web Components.",
      "options": [
        "Declarative Custom Elements cho phép bạn khai báo Custom Elements trực tiếp trong HTML, tương tự như Declarative Shadow DOM. Lợi ích là HTML của component có thể được phân tích cú pháp và hiển thị bởi trình duyệt trước khi JavaScript của Custom Element tải và được định nghĩa, giúp hiển thị nội dung nhanh hơn và giảm TTI bằng cách tách biệt render khỏi hydration.",
        "Declarative Custom Elements chỉ cho phép khai báo các Custom Elements không có Shadow DOM.",
        "Declarative Custom Elements là một phiên bản cũ hơn của Custom Elements, không còn được khuyến khích sử dụng.",
        "Declarative Custom Elements yêu cầu một framework JavaScript để hoạt động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 55,
      "topicId": 1,
      "question": "Tại sao việc sử dụng thuộc tính `type=\"module\"` trên thẻ `<script>` lại quan trọng cho phát triển web hiện đại, đặc biệt là với JavaScript Modules?",
      "options": [
        "`type=\"module\"` chỉ thị cho trình duyệt rằng script này là một JavaScript Module, cho phép nó sử dụng cú pháp `import`/`export`, chạy trong strict mode mặc định, và tải/thực thi `defer` theo mặc định. Điều này giúp tổ chức code tốt hơn, tránh xung đột biến toàn cục và hỗ trợ cây phụ thuộc.",
        "`type=\"module\"` chỉ định rằng script này chứa các hàm dựng sẵn của trình duyệt, không phải code của nhà phát triển.",
        "`type=\"module\"` mã hóa nội dung của script để bảo vệ nó khỏi việc bị chỉnh sửa trái phép.",
        "`type=\"module\"` cho phép script được nhúng trực tiếp vào HTML mà không cần file `.js` riêng biệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 56,
      "topicId": 1,
      "question": "Phân biệt giữa 'Light DOM' và 'Shadow DOM' trong ngữ cảnh của Web Components.",
      "options": [
        "Light DOM là DOM bình thường của tài liệu, là nơi mà các phần tử Custom Element được đặt và nội dung của chúng được chèn vào. Shadow DOM là một cây DOM riêng biệt, đóng gói bên trong Custom Element, được cách ly hoàn toàn với Light DOM về CSS và logic, tạo ra tính đóng gói mạnh mẽ.",
        "Light DOM chỉ chứa các thẻ HTML cơ bản, còn Shadow DOM chứa các thẻ HTML phức tạp hơn.",
        "Light DOM được tải trước, còn Shadow DOM được tải sau bằng JavaScript.",
        "Light DOM chỉ hiển thị trên trình duyệt di động, còn Shadow DOM hiển thị trên tất cả các thiết bị."
      ],
      "correctAnswer": 0
    },
    {
      "id": 57,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `loading=\"eager\"` (explicit loading) trên thẻ `<img>` và `<iframe>` và khi nào nên sử dụng nó thay vì `lazy`.",
      "options": [
        "`loading=\"eager\"` chỉ thị trình duyệt tải tài nguyên (hình ảnh hoặc iframe) ngay lập tức, bất kể vị trí của chúng trên trang, ưu tiên hơn các tài nguyên khác. Nên sử dụng cho các hình ảnh hoặc iframe quan trọng nằm trong viewport ban đầu của người dùng, để đảm bảo chúng hiển thị nhanh chóng.",
        "`loading=\"eager\"` buộc trình duyệt mã hóa tài nguyên trước khi tải, tăng cường bảo mật nhưng làm chậm quá trình hiển thị.",
        "`loading=\"eager\"` chỉ cho phép tải tài nguyên nếu người dùng có kết nối mạng nhanh, giúp tiết kiệm dữ liệu cho người dùng có kết nối chậm.",
        "`loading=\"eager\"` là hành vi mặc định của trình duyệt và không cần phải khai báo rõ ràng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 58,
      "topicId": 1,
      "question": "Thuộc tính `itemscope` và `itemtype` trong HTML Microdata có tác dụng gì đối với SEO và cách nó giúp công cụ tìm kiếm hiểu nội dung?",
      "options": [
        "`itemscope` khai báo một 'item' (thực thể) mới trên trang, và `itemtype` xác định loại của item đó (ví dụ: `http://schema.org/Article`, `http://schema.org/Person`). Kết hợp với `itemprop`, chúng giúp công cụ tìm kiếm hiểu rõ ngữ cảnh và mối quan hệ giữa các dữ liệu trên trang, từ đó hiển thị **Rich Snippets** (kết quả tìm kiếm phong phú) và cải thiện thứ hạng SEO.",
        "`itemscope` và `itemtype` dùng để tạo các hiệu ứng động trên trang web, tăng tính tương tác.",
        "`itemscope` và `itemtype` là các thuộc tính CSS để định dạng văn bản.",
        "`itemscope` và `itemtype` được dùng để nhúng các video từ YouTube vào trang web."
      ],
      "correctAnswer": 0
    },
    {
      "id": 59,
      "topicId": 1,
      "question": "Phân tích lợi ích của việc sử dụng các thẻ HTML ngữ nghĩa (semantic HTML) như `<main>`, `<section>`, `<article>`, `<aside>`, `<footer>` so với việc chỉ dùng `<div>` với `class` hoặc `id`.",
      "options": [
        "Thẻ ngữ nghĩa cung cấp ý nghĩa cấu trúc rõ ràng cho nội dung, giúp công cụ tìm kiếm hiểu tốt hơn về cấu trúc và nội dung trang (SEO), cải thiện khả năng truy cập (accessibility) cho người dùng screen reader, và làm cho mã nguồn dễ đọc, dễ bảo trì hơn cho lập trình viên. `<div>` không có ý nghĩa ngữ nghĩa vốn có.",
        "Các thẻ ngữ nghĩa giúp trang web tải nhanh hơn vì chúng nhỏ gọn hơn `<div>`.",
        "Các thẻ ngữ nghĩa tự động thêm các hiệu ứng CSS đẹp mắt mà không cần viết thêm mã.",
        "Các thẻ ngữ nghĩa chỉ hoạt động trên các trình duyệt hiện đại nhất."
      ],
      "correctAnswer": 0
    },
    {
      "id": 60,
      "topicId": 1,
      "question": "Thẻ `<dialog>` trong HTML có những phương thức JavaScript nào để điều khiển hiển thị và sự khác biệt giữa `show()` và `showModal()` là gì?",
      "options": [
        "Thẻ `<dialog>` có các phương thức `show()` và `showModal()`. `show()` hiển thị hộp thoại nhưng không phải là modal (không chặn tương tác với phần còn lại của trang). `showModal()` hiển thị hộp thoại dưới dạng modal (chặn tương tác với các yếu tố bên dưới, đặt tiêu điểm vào dialog, và có thể đóng bằng phím Esc).",
        "`show()` và `showModal()` đều hiển thị dialog như modal, nhưng `showModal()` yêu cầu người dùng xác nhận trước khi đóng.",
        "`show()` chỉ dùng cho các dialog thông báo, còn `showModal()` dùng cho các dialog yêu cầu nhập liệu.",
        "Không có phương thức JavaScript nào để điều khiển `<dialog>`; nó chỉ hiển thị bằng thuộc tính HTML."
      ],
      "correctAnswer": 0
    },
    {
      "id": 61,
      "topicId": 1,
      "question": "Mô tả cơ chế hoạt động của `Service Workers` trong HTML5 và vai trò của chúng trong việc xây dựng Progressive Web Apps (PWAs) với khả năng offline và hiệu suất cao.",
      "options": [
        "Service Workers là một loại Web Worker đặc biệt hoạt động như một proxy giữa trình duyệt và mạng. Chúng có thể chặn và quản lý các yêu cầu mạng, lưu trữ tài nguyên vào cache, và phục vụ nội dung offline. Điều này cho phép PWAs có khả năng hoạt động ngoại tuyến, tải nhanh hơn, và gửi thông báo đẩy (push notifications).",
        "Service Workers là công cụ để kiểm tra lỗi và debug JavaScript trong môi trường offline.",
        "Service Workers là một API cho phép tạo ra các animation phức tạp mà không ảnh hưởng đến hiệu suất.",
        "Service Workers giúp tự động tối ưu hóa hình ảnh và video trên trang web."
      ],
      "correctAnswer": 0
    },
    {
      "id": 62,
      "topicId": 1,
      "question": "Khái niệm `template literal` (hoặc template string) trong JavaScript liên quan như thế nào đến việc tạo cấu trúc HTML động trong các ứng dụng web?",
      "options": [
        "Template literals cho phép nhúng biểu thức JavaScript và tạo chuỗi đa dòng một cách dễ dàng. Chúng rất hữu ích để xây dựng các chuỗi HTML động một cách rõ ràng và dễ đọc, đặc biệt khi cần chèn biến hoặc logic đơn giản vào cấu trúc HTML, thay vì sử dụng nối chuỗi phức tạp.",
        "Template literals là một cách mới để khai báo biến HTML trong CSS.",
        "Template literals giúp trình duyệt hiểu và render HTML nhanh hơn.",
        "Template literals chỉ dùng để tạo các biểu mẫu nhập liệu có tính tương tác cao."
      ],
      "correctAnswer": 0
    },
    {
      "id": 63,
      "topicId": 1,
      "question": "Thẻ `<data>` và thuộc tính `value` của nó có tác dụng gì trong HTML5 và khi nào nên sử dụng chúng thay vì các thuộc tính khác như `id` hoặc `class`?",
      "options": [
        "Thẻ `<data>` đại diện cho dữ liệu của một phần tử, và thuộc tính `value` của nó chứa giá trị đọc được của máy (machine-readable value) liên quan đến nội dung có thể đọc được của con người. Nó hữu ích khi bạn muốn gắn một ID hoặc giá trị cụ thể cho dữ liệu, đặc biệt trong các ứng dụng hiển thị dữ liệu và cần xử lý bằng script.",
        "Thẻ `<data>` dùng để tạo ra các bảng dữ liệu phức tạp, còn `value` là tiêu đề của bảng.",
        "Thẻ `<data>` dùng để nhúng các file dữ liệu bên ngoài vào trang HTML.",
        "Thẻ `<data>` và `value` chỉ dùng trong các ứng dụng cơ sở dữ liệu web."
      ],
      "correctAnswer": 0
    },
    {
      "id": 64,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `autofocus` trên các phần tử form và những vấn đề về khả năng truy cập cần lưu ý khi sử dụng nó.",
      "options": [
        "Thuộc tính `autofocus` tự động đặt tiêu điểm (focus) vào một trường nhập liệu cụ thể khi trang tải. Mặc dù tiện lợi, nó có thể gây khó chịu cho người dùng screen reader hoặc người dùng bàn phím vì tiêu điểm bị di chuyển bất ngờ, tiềm ẩn vấn đề về khả năng truy cập.",
        "Thuộc tính `autofocus` tự động gửi dữ liệu form khi trang được tải.",
        "Thuộc tính `autofocus` chỉ hiển thị trường nhập liệu khi người dùng nhấp vào nó.",
        "Thuộc tính `autofocus` giúp tự động điền thông tin vào trường nhập liệu dựa trên lịch sử duyệt web."
      ],
      "correctAnswer": 0
    },
    {
      "id": 65,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Race Condition' trong bối cảnh tải và thực thi script HTML và cách `async`/`defer` có thể giúp quản lý chúng.",
      "options": [
        "Race Condition xảy ra khi thứ tự hoặc thời điểm thực thi của các script phụ thuộc vào các yếu tố không thể đoán trước (ví dụ: tốc độ tải mạng), dẫn đến hành vi không mong muốn. `async` không đảm bảo thứ tự thực thi, có thể gây race condition nếu script phụ thuộc lẫn nhau. `defer` đảm bảo thứ tự thực thi theo thứ tự xuất hiện trong HTML sau khi DOM sẵn sàng, giúp quản lý race condition cho các script phụ thuộc.",
        "Race Condition là khi nhiều người dùng cố gắng truy cập cùng một tài nguyên trên server cùng lúc.",
        "Race Condition là lỗi xảy ra khi script không thể tải được do lỗi mạng.",
        "Race Condition là khi script cố gắng truy cập một biến chưa được định nghĩa."
      ],
      "correctAnswer": 0
    },
    {
      "id": 66,
      "topicId": 1,
      "question": "Vai trò của thuộc tính `decoding=\"async\"` trên thẻ `<img>` là gì và khi nào nên sử dụng nó?",
      "options": [
        "Thuộc tính `decoding=\"async\"` gợi ý cho trình duyệt rằng hình ảnh có thể được giải mã (decode) một cách bất đồng bộ, mà không làm chặn quá trình rendering hoặc đóng băng UI. Nên sử dụng cho các hình ảnh không quan trọng hoặc hình ảnh lớn nằm ngoài viewport ban đầu để cải thiện tính phản hồi của trang.",
        "Thuộc tính `decoding=\"async\"` mã hóa hình ảnh trước khi hiển thị, tăng cường bảo mật.",
        "Thuộc tính `decoding=\"async\"` chỉ cho phép tải hình ảnh nếu trình duyệt hỗ trợ WebGL.",
        "Thuộc tính `decoding=\"async\"` giúp tự động chuyển đổi định dạng hình ảnh sang WebP hoặc AVIF."
      ],
      "correctAnswer": 0
    },
    {
      "id": 67,
      "topicId": 1,
      "question": "Làm thế nào để sử dụng thuộc tính `data-*` trong HTML5 để lưu trữ dữ liệu tùy chỉnh và vai trò của nó trong việc tương tác giữa HTML và JavaScript?",
      "options": [
        "Thuộc tính `data-*` cho phép bạn nhúng dữ liệu tùy chỉnh, không hiển thị trên giao diện, trực tiếp vào các phần tử HTML. Dữ liệu này có thể được truy cập và thao tác dễ dàng bằng JavaScript thông qua `element.dataset` object. Nó rất hữu ích để lưu trữ các thông tin liên quan đến UI hoặc logic ứng dụng mà không cần sử dụng `id` hoặc `class` với mục đích không phù hợp.",
        "Thuộc tính `data-*` dùng để khai báo các biến môi trường cho CSS.",
        "Thuộc tính `data-*` chỉ có thể lưu trữ dữ liệu số, không thể lưu trữ chuỗi.",
        "Thuộc tính `data-*` tự động gửi dữ liệu đến server khi người dùng tương tác với phần tử."
      ],
      "correctAnswer": 0
    },
    {
      "id": 68,
      "topicId": 1,
      "question": "Mô tả ý nghĩa của việc sử dụng thuộc tính `reversed` trên thẻ `<ol>` (ordered list) và các trường hợp sử dụng phổ biến.",
      "options": [
        "Thuộc tính `reversed` làm cho danh sách có thứ tự được đánh số theo thứ tự giảm dần, bắt đầu từ số lớn nhất xuống số nhỏ nhất. Nó hữu ích cho việc hiển thị các bảng xếp hạng (ví dụ: top 100 từ dưới lên) hoặc các danh sách cần đếm ngược.",
        "Thuộc tính `reversed` làm cho các mục trong danh sách hiển thị từ phải sang trái.",
        "Thuộc tính `reversed` chỉ cho phép danh sách hiển thị khi người dùng cuộn xuống đến vị trí của nó.",
        "Thuộc tính `reversed` buộc danh sách phải được sắp xếp lại theo thứ tự ABC."
      ],
      "correctAnswer": 0
    },
    {
      "id": 69,
      "topicId": 1,
      "question": "Thẻ `<meter>` và `<progress>` trong HTML5 có sự khác biệt gì về mặt ngữ nghĩa và khi nào nên sử dụng từng loại?",
      "options": [
        "Thẻ `<meter>` đại diện cho một giá trị đo lường trong một phạm vi xác định (ví dụ: mức pin, điểm đánh giá), có ý nghĩa ngữ nghĩa về một giá trị hiện tại so với một ngưỡng. Thẻ `<progress>` đại diện cho tiến độ hoàn thành của một tác vụ (ví dụ: tải file, cài đặt phần mềm), thể hiện một quá trình đang diễn ra. Nên dùng `<meter>` cho các giá trị tĩnh/thay đổi trạng thái, và `<progress>` cho các tác vụ động.",
        "Thẻ `<meter>` chỉ hiển thị số, còn `<progress>` hiển thị thanh tiến độ.",
        "Thẻ `<meter>` yêu cầu JavaScript để cập nhật giá trị, còn `<progress>` thì không.",
        "Cả hai thẻ đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 70,
      "topicId": 1,
      "question": "Khái niệm 'Intrinsic Size' của hình ảnh là gì và tại sao nó lại quan trọng khi làm việc với `<img>` trong responsive design?",
      "options": [
        "Intrinsic size là kích thước (chiều rộng và chiều cao) thực tế của một hình ảnh theo pixel mà nó được lưu trữ. Quan trọng vì nó là cơ sở để trình duyệt tính toán tỷ lệ khung hình và quyết định không gian chiếm giữ nếu không có CSS nào được áp dụng, giúp tránh **Layout Shift (CLS)** khi tải ảnh và hỗ trợ responsive scaling.",
        "Intrinsic size là kích thước tối đa mà hình ảnh có thể được nén để giảm dung lượng file.",
        "Intrinsic size là kích thước mà hình ảnh sẽ hiển thị trên màn hình lớn nhất.",
        "Intrinsic size là kích thước mặc định của hình ảnh khi không có thuộc tính `width` hoặc `height` được định nghĩa."
      ],
      "correctAnswer": 0
    },
    {
      "id": 71,
      "topicId": 1,
      "question": "Tại sao việc sử dụng thuộc tính `alt` trên thẻ `<img>` lại quan trọng cho cả SEO và khả năng truy cập (Accessibility)?",
      "options": [
        "Thuộc tính `alt` cung cấp văn bản thay thế mô tả nội dung của hình ảnh. Đối với SEO, nó giúp công cụ tìm kiếm hiểu được hình ảnh (vì bot không 'nhìn' được ảnh). Đối với khả năng truy cập, nó được screen reader đọc cho người dùng khiếm thị, giúp họ hiểu nội dung của ảnh và cung cấp ngữ cảnh khi ảnh không tải được.",
        "Thuộc tính `alt` giúp nén hình ảnh, giảm kích thước file và tăng tốc độ tải.",
        "Thuộc tính `alt` chỉ có tác dụng khi người dùng di chuột qua hình ảnh, hiển thị tooltip.",
        "Thuộc tính `alt` xác định vị trí mà hình ảnh sẽ xuất hiện trên trang."
      ],
      "correctAnswer": 0
    },
    {
      "id": 72,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `loading=\"lazy\"` trên thẻ `<img>` và `<iframe>` và lợi ích chính của nó đối với hiệu suất tải trang.",
      "options": [
        "Thuộc tính `loading=\"lazy\"` chỉ thị trình duyệt hoãn tải tài nguyên (hình ảnh hoặc iframe) cho đến khi chúng gần hoặc nằm trong viewport của người dùng. Điều này giúp giảm thời gian tải ban đầu của trang, tiết kiệm băng thông và cải thiện **Core Web Vitals** bằng cách ưu tiên tải các tài nguyên hiển thị ngay lập tức.",
        "Thuộc tính `loading=\"lazy\"` chỉ tải tài nguyên khi người dùng click vào chúng.",
        "Thuộc tính `loading=\"lazy\"` mã hóa tài nguyên để tăng cường bảo mật trong quá trình truyền tải.",
        "Thuộc tính `loading=\"lazy\"` tự động chuyển đổi định dạng tài nguyên sang một định dạng nhẹ hơn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 73,
      "topicId": 1,
      "question": "Sự khác biệt giữa `rel=\"preload\"` và `rel=\"prefetch\"` trong thẻ `<link>` là gì và khi nào nên sử dụng từng loại?",
      "options": [
        "`preload` được sử dụng để tải trước các tài nguyên **quan trọng** mà bạn chắc chắn sẽ cần trong phiên hiện tại của trang (ví dụ: font, hình ảnh LCP, CSS critical) càng sớm càng tốt trong quá trình tải trang. `prefetch` được sử dụng để tải trước các tài nguyên **có thể cần** trong các điều hướng tương lai (ví dụ: tài nguyên của trang tiếp theo mà người dùng có thể click vào).",
        "`preload` chỉ tải CSS, còn `prefetch` chỉ tải JavaScript.",
        "`preload` chặn rendering, còn `prefetch` thì không.",
        "`preload` chỉ hoạt động với tài nguyên nội bộ, còn `prefetch` hoạt động với tài nguyên bên ngoài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 74,
      "topicId": 1,
      "question": "Khái niệm 'Web Vitals' (ví dụ: LCP, FID, CLS) liên quan đến HTML và cấu trúc Web như thế nào?",
      "options": [
        "Web Vitals là một tập hợp các chỉ số được Google đề xuất để đo lường trải nghiệm người dùng trên web. HTML và cấu trúc của nó ảnh hưởng trực tiếp đến các chỉ số này: LCP (Largest Contentful Paint) phụ thuộc vào tốc độ render HTML và các tài nguyên quan trọng; CLS (Cumulative Layout Shift) bị ảnh hưởng bởi việc chèn nội dung động hoặc tải hình ảnh không có kích thước; FID (First Input Delay) bị ảnh hưởng bởi việc script chặn luồng chính.",
        "Web Vitals là các công cụ kiểm tra lỗi cú pháp HTML.",
        "Web Vitals là các tiêu chuẩn mới cho việc tạo responsive design.",
        "Web Vitals chỉ liên quan đến hiệu suất server, không liên quan đến HTML."
      ],
      "correctAnswer": 0
    },
    {
      "id": 75,
      "topicId": 1,
      "question": "Thẻ `<input type=\"module\">` có tồn tại trong HTML không và nếu không, cơ chế tương đương để tải JavaScript Modules vào form là gì?",
      "options": [
        "Không có thẻ `<input type=\"module\">`. Để tải JavaScript Modules, bạn sử dụng thẻ `<script type=\"module\">` thông thường. Các module này có thể tương tác với các phần tử form thông qua DOM API như bất kỳ script JavaScript nào khác.",
        "Có, `<input type=\"module\">` là một thẻ HTML mới để tải JavaScript Modules vào form.",
        "`<input type=\"module\">` chỉ được dùng trong các trình duyệt thử nghiệm.",
        "JavaScript Modules không thể được tải vào form HTML."
      ],
      "correctAnswer": 0
    },
    {
      "id": 76,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Native Lazy Loading' trong HTML và ưu/nhược điểm của nó so với các giải pháp lazy loading dựa trên JavaScript.",
      "options": [
        "Native Lazy Loading là tính năng tích hợp sẵn của trình duyệt cho phép hoãn tải hình ảnh/iframe bằng thuộc tính `loading=\"lazy\"`. Ưu điểm: dễ sử dụng (chỉ cần thêm thuộc tính), hiệu suất tốt hơn vì trình duyệt tự quản lý, không cần JS. Nhược điểm: không phải tất cả trình duyệt đều hỗ trợ, đôi khi ít kiểm soát hơn so với giải pháp JS tùy chỉnh (ví dụ: ngưỡng khoảng cách tới viewport).",
        "Native Lazy Loading chỉ hoạt động trên các thiết bị di động.",
        "Native Lazy Loading yêu cầu server phải hỗ trợ đặc biệt.",
        "Native Lazy Loading chỉ áp dụng cho nội dung tĩnh, không áp dụng cho nội dung động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 77,
      "topicId": 1,
      "question": "Vai trò của thuộc tính `referrerpolicy` trong HTML là gì và cách nó ảnh hưởng đến quyền riêng tư của người dùng?",
      "options": [
        "Thuộc tính `referrerpolicy` kiểm soát lượng thông tin referrer (URL của trang hiện tại) được gửi đi cùng với các yêu cầu HTTP. Nó giúp bảo vệ quyền riêng tư của người dùng bằng cách cho phép bạn hạn chế hoặc loại bỏ thông tin này khi điều hướng đến các nguồn gốc khác, ngăn chặn việc theo dõi không mong muốn.",
        "Thuộc tính `referrerpolicy` chỉ định chính sách cache của trình duyệt cho tài nguyên.",
        "Thuộc tính `referrerpolicy` xác định ngôn ngữ ưu tiên cho nội dung trang.",
        "Thuộc tính `referrerpolicy` yêu cầu người dùng xác nhận trước khi rời khỏi trang."
      ],
      "correctAnswer": 0
    },
    {
      "id": 78,
      "topicId": 1,
      "question": "Sự khác biệt giữa `id` và `name` trên thẻ `<input>` trong HTML là gì, đặc biệt liên quan đến việc gửi form và JavaScript?",
      "options": [
        "`id` là một định danh duy nhất trong toàn bộ tài liệu, dùng để nhắm mục tiêu phần tử bằng CSS, JavaScript, và liên kết nhãn (`<label>`). `name` được dùng để định danh trường dữ liệu khi form được gửi đến server (key-value pair) và cũng dùng để nhóm các radio buttons. `name` là bắt buộc để dữ liệu input được gửi đi.",
        "`id` chỉ dùng cho JavaScript, còn `name` chỉ dùng cho CSS.",
        "`id` có thể trùng lặp, còn `name` phải duy nhất.",
        "`id` và `name` đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 79,
      "topicId": 1,
      "question": "Thẻ `<base>` trong HTML có những hạn chế nào khi sử dụng trong các ứng dụng web phức tạp hoặc khi có nhiều đường dẫn tương đối?",
      "options": [
        "Hạn chế chính là nó thay đổi tất cả các URL tương đối trên toàn bộ tài liệu, có thể gây khó khăn trong việc quản lý các tài nguyên có đường dẫn tương đối khác nhau hoặc trong các SPA với định tuyến client-side. Nếu không cẩn thận, nó có thể dẫn đến lỗi tải tài nguyên hoặc lỗi định tuyến.",
        "Thẻ `<base>` làm tăng kích thước file HTML đáng kể.",
        "Thẻ `<base>` không tương thích với các trình duyệt cũ.",
        "Thẻ `<base>` chỉ hoạt động với các tài nguyên từ cùng một domain."
      ],
      "correctAnswer": 0
    },
    {
      "id": 80,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Image Fallback' trong HTML khi sử dụng `<picture>` hoặc `srcset` và lý do nó lại quan trọng.",
      "options": [
        "Image fallback là việc cung cấp một thẻ `<img>` tiêu chuẩn làm phương án dự phòng bên trong `<picture>` hoặc sau thuộc tính `srcset`. Điều này đảm bảo rằng ngay cả khi trình duyệt không hỗ trợ các định dạng ảnh hiện đại (như WebP, AVIF) hoặc các thuộc tính responsive, hình ảnh vẫn sẽ được hiển thị cho người dùng thông qua định dạng ảnh truyền thống (ví dụ: JPEG, PNG).",
        "Image fallback là khi hình ảnh không tải được và trình duyệt tự động hiển thị một hình ảnh mặc định thay thế.",
        "Image fallback là một kỹ thuật để tải hình ảnh chất lượng thấp trước, sau đó thay thế bằng hình ảnh chất lượng cao.",
        "Image fallback chỉ áp dụng cho các hình ảnh được tải từ CDN."
      ],
      "correctAnswer": 0
    },
    {
      "id": 81,
      "topicId": 1,
      "question": "Vai trò của thuộc tính `download` trên thẻ `<a>` là gì và khi nào nên sử dụng nó?",
      "options": [
        "Thuộc tính `download` gợi ý cho trình duyệt rằng liên kết nên được tải xuống dưới dạng file thay vì điều hướng đến URL đó. Bạn có thể cung cấp một giá trị cho `download` để gợi ý tên file tải xuống. Nó hữu ích khi bạn muốn cung cấp link tải tài liệu, hình ảnh, hoặc các file khác.",
        "Thuộc tính `download` chỉ cho phép tải xuống các file từ cùng một domain.",
        "Thuộc tính `download` tự động mở file sau khi tải xuống hoàn tất.",
        "Thuộc tính `download` mã hóa file trước khi tải xuống, tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 82,
      "topicId": 1,
      "question": "Khi sử dụng Web Components, tại sao việc tạo Shadow DOM ở chế độ 'open' (`mode: 'open'`) lại phổ biến hơn 'closed' (`mode: 'closed'`)?",
      "options": [
        "Chế độ 'open' cho phép JavaScript bên ngoài (và của component đó) truy cập vào Shadow DOM thông qua `element.shadowRoot`. Điều này giúp việc debug, kiểm thử và tương tác với component dễ dàng hơn. Chế độ 'closed' ngăn chặn truy cập bên ngoài, làm cho component tự đóng gói hơn nhưng khó debug và tương tác hơn rất nhiều.",
        "Chế độ 'open' có hiệu suất tốt hơn 'closed' khi render.",
        "Chế độ 'open' cho phép CSS bên ngoài ảnh hưởng đến Shadow DOM, còn 'closed' thì không.",
        "Chế độ 'open' là mặc định của trình duyệt, còn 'closed' cần cấu hình đặc biệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 83,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `translate=\"no\"` trong HTML và khi nào nên sử dụng nó để cải thiện trải nghiệm người dùng.",
      "options": [
        "Thuộc tính `translate=\"no\"` chỉ thị cho trình duyệt hoặc các công cụ dịch thuật bên ngoài (như Google Translate) rằng nội dung của phần tử này không nên được dịch. Nó hữu ích cho các tên riêng, mã code, thuật ngữ chuyên ngành hoặc nội dung mà việc dịch có thể làm mất ý nghĩa hoặc gây hiểu lầm.",
        "Thuộc tính `translate=\"no\"` làm cho văn bản không thể sao chép được.",
        "Thuộc tính `translate=\"no\"` thay đổi hướng đọc của văn bản từ phải sang trái.",
        "Thuộc tính `translate=\"no\"` vô hiệu hóa tất cả các hiệu ứng CSS trên phần tử."
      ],
      "correctAnswer": 0
    },
    {
      "id": 84,
      "topicId": 1,
      "question": "Khái niệm 'Accessible Rich Internet Applications (ARIA)' là gì và mối quan hệ của nó với HTML ngữ nghĩa để cải thiện khả năng truy cập?",
      "options": [
        "ARIA là một tập hợp các thuộc tính HTML (ví dụ: `role`, `aria-label`, `aria-expanded`) giúp thêm ngữ nghĩa và thông tin vào các phần tử HTML không có ngữ nghĩa gốc hoặc không đủ ngữ nghĩa để tạo ra trải nghiệm tốt cho người dùng khuyết tật (đặc biệt là người dùng screen reader). ARIA bổ sung cho HTML ngữ nghĩa, không thay thế nó.",
        "ARIA là một framework JavaScript để xây dựng giao diện người dùng có khả năng truy cập.",
        "ARIA là một công cụ kiểm tra lỗi bảo mật trên trang web.",
        "ARIA là một tiêu chuẩn CSS để tạo responsive layout."
      ],
      "correctAnswer": 0
    },
    {
      "id": 85,
      "topicId": 1,
      "question": "Sự khác biệt giữa `async` và `defer` trên thẻ `<script>` có thể gây ra lỗi gì nếu không được sử dụng đúng cách, đặc biệt khi script tương tác với DOM?",
      "options": [
        "Nếu một script cần tương tác với DOM nhưng được tải với `async`, nó có thể thực thi trước khi DOM được phân tích cú pháp hoàn toàn, dẫn đến lỗi 'Cannot read properties of null' (hoặc tương tự) khi cố gắng truy cập các phần tử DOM chưa tồn tại. `defer` sẽ an toàn hơn trong trường hợp này vì nó đảm bảo thực thi sau khi DOM sẵn sàng.",
        "`async` và `defer` đều có thể gây lỗi Cross-Site Scripting (XSS) nếu không được cấu hình đúng.",
        "Nếu sử dụng `async` hoặc `defer` sai cách, script có thể bị tải nhiều lần, gây lãng phí băng thông.",
        "`async` và `defer` có thể làm cho trình duyệt bị treo nếu script quá lớn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 86,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `inert` trong HTML và cách nó cải thiện khả năng truy cập (accessibility) cho các phần tử UI.",
      "options": [
        "Thuộc tính `inert` làm cho một phần tử không thể tương tác (không thể click, tab vào, hoặc đọc bởi assistive technologies) và loại bỏ nó khỏi cây accessibility tree. Nó cực kỳ hữu ích cho việc quản lý tiêu điểm trong các modal dialog, drawer, hoặc các phần tử overlay khác, đảm bảo người dùng chỉ tương tác với phần tử hiện tại.",
        "Thuộc tính `inert` chỉ làm cho phần tử không thể click được nhưng vẫn có thể nhận tiêu điểm từ bàn phím. Nó được dùng để vô hiệu hóa tạm thời các nút bấm trong khi chờ xử lý.",
        "Thuộc tính `inert` giúp các công cụ tìm kiếm bỏ qua phần tử đó khi lập chỉ mục trang web. Nó được dùng để ẩn các nội dung không quan trọng khỏi kết quả tìm kiếm.",
        "Thuộc tính `inert` tự động thêm một hiệu ứng chuyển động chậm khi người dùng di chuột qua phần tử đó, giúp cải thiện trải nghiệm người dùng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 87,
      "topicId": 1,
      "question": "Thẻ `<slot>` trong Shadow DOM có thể có thuộc tính `name` và `assignedElements()`/`assignedNodes()` để làm gì?",
      "options": [
        "Thuộc tính `name` trên `<slot>` cho phép bạn tạo nhiều 'slots' khác nhau trong một Shadow DOM, nơi nội dung từ Light DOM có thể được chèn vào các vị trí cụ thể bằng cách sử dụng thuộc tính `slot=\"name\"` trên phần tử Light DOM. Các phương thức `assignedElements()`/`assignedNodes()` giúp JavaScript truy cập các phần tử/node đã được gán vào một slot cụ thể.",
        "Thuộc tính `name` trên `<slot>` dùng để đặt tên cho Shadow DOM.",
        "Thuộc tính `name` trên `<slot>` chỉ định loại dữ liệu mà slot có thể chấp nhận.",
        "Các phương thức `assignedElements()`/`assignedNodes()` dùng để tạo ra các slot mới động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 88,
      "topicId": 1,
      "question": "Giải thích cách thuộc tính `media` trên thẻ `<link rel=\"stylesheet\" ...>` giúp tối ưu hóa Critical Rendering Path.",
      "options": [
        "Thuộc tính `media` cho phép bạn chỉ định các điều kiện media query (ví dụ: `print`, `screen and (max-width: 600px)`) mà stylesheet chỉ nên được áp dụng. Bằng cách này, các stylesheet không cần thiết cho việc hiển thị ban đầu của trang (ví dụ: stylesheet chỉ dành cho in ấn) có thể được trình duyệt tải bất đồng bộ hoặc ưu tiên thấp hơn, không chặn quá trình rendering và cải thiện thời gian tải trang ban đầu.",
        "Thuộc tính `media` giúp mã hóa nội dung của stylesheet, tăng cường bảo mật.",
        "Thuộc tính `media` chỉ cho phép tải stylesheet từ các nguồn gốc đáng tin cậy.",
        "Thuộc tính `media` tự động nén stylesheet để giảm kích thước tải xuống."
      ],
      "correctAnswer": 0
    },
    {
      "id": 89,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `formaction` trên các nút `<input type=\"submit\">` hoặc `<button type=\"submit\">`.",
      "options": [
        "Thuộc tính `formaction` ghi đè giá trị của thuộc tính `action` trên thẻ `<form>` cha của nút submit. Nó cho phép một nút submit cụ thể gửi dữ liệu form đến một URL khác với URL mặc định của form, hữu ích khi bạn có nhiều hành động submit khác nhau cho cùng một form.",
        "Thuộc tính `formaction` xác định phương thức HTTP (GET/POST) để gửi form.",
        "Thuộc tính `formaction` chỉ định tên của form mà nút này thuộc về.",
        "Thuộc tính `formaction` giúp tự động điền các trường trong form."
      ],
      "correctAnswer": 0
    },
    {
      "id": 90,
      "topicId": 1,
      "question": "Thẻ `<output>` trong HTML5 có ý nghĩa ngữ nghĩa gì và nó thường được sử dụng trong trường hợp nào?",
      "options": [
        "Thẻ `<output>` đại diện cho kết quả của một phép tính hoặc hành động của người dùng (ví dụ: kết quả của một biểu thức, phản hồi từ server). Nó thường được dùng kết hợp với các phần tử form (ví dụ: `<input type=\"range\">` và JavaScript) để hiển thị kết quả động cho người dùng mà không cần gửi form.",
        "Thẻ `<output>` dùng để nhúng các file âm thanh hoặc video.",
        "Thẻ `<output>` dùng để hiển thị các thông báo debug từ JavaScript.",
        "Thẻ `<output>` là một cách để in nội dung trang ra giấy."
      ],
      "correctAnswer": 0
    },
    {
      "id": 91,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Declarative Shadow DOM' và lợi ích của nó so với 'Imperative Shadow DOM' trong bối cảnh Server-Side Rendering (SSR).",
      "options": [
        "Declarative Shadow DOM cho phép bạn định nghĩa Shadow DOM trực tiếp trong HTML (sử dụng `<template shadowroot>`) thay vì phải tạo nó bằng JavaScript. Lợi ích chính là nội dung Shadow DOM có thể được render trên server, cải thiện thời gian **First Contentful Paint (FCP)** và giảm FOUC (Flash of Unstyled Content) khi SSR Web Components.",
        "Declarative Shadow DOM là một phiên bản cũ hơn của Shadow DOM, ít mạnh mẽ hơn Imperative Shadow DOM.",
        "Declarative Shadow DOM cho phép bạn sử dụng CSS Preprocessors bên trong Shadow DOM mà không cần biên dịch trước.",
        "Declarative Shadow DOM là một cách để nhúng Shadow DOM từ một iframe, giúp tăng cường bảo mật cho các Web Components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 92,
      "topicId": 1,
      "question": "Tại sao việc duy trì tỷ lệ khung hình (aspect ratio) cho hình ảnh và video lại quan trọng trong responsive design và cách HTML/CSS hỗ trợ điều này?",
      "options": [
        "Duy trì tỷ lệ khung hình giúp ngăn chặn **Layout Shift (CLS)** khi hình ảnh/video tải, đảm bảo không gian được giữ chỗ chính xác trước khi tài nguyên thực sự tải xong. HTML hỗ trợ thông qua thuộc tính `width` và `height` (cung cấp intrinsic size) trên `<img>` và `<video>`, CSS có thể dùng `aspect-ratio` property hoặc padding hack.",
        "Duy trì tỷ lệ khung hình giúp giảm kích thước file của hình ảnh và video.",
        "Duy trì tỷ lệ khung hình chỉ quan trọng cho các hình ảnh động (GIF).",
        "Duy trì tỷ lệ khung hình tự động chuyển đổi video sang định dạng tối ưu hơn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 93,
      "topicId": 1,
      "question": "Thẻ `<meta name=\"theme-color\" content=\"#HEXCODE\">` có vai trò gì trong việc tùy chỉnh giao diện PWA (Progressive Web App) hoặc trang web trên thiết bị di động?",
      "options": [
        "Thẻ này cho phép bạn định nghĩa màu sắc chủ đề mà trình duyệt sẽ sử dụng để tô màu thanh địa chỉ, thanh công cụ hoặc giao diện hệ thống của trình duyệt khi người dùng xem trang web của bạn trên thiết bị di động, giúp tạo trải nghiệm người dùng liền mạch hơn và phù hợp với thương hiệu.",
        "Thẻ này chỉ định màu nền mặc định cho toàn bộ trang web.",
        "Thẻ này kiểm soát màu sắc của các liên kết trên trang.",
        "Thẻ này tự động thay đổi màu sắc dựa trên chế độ sáng/tối của thiết bị."
      ],
      "correctAnswer": 0
    },
    {
      "id": 94,
      "topicId": 1,
      "question": "Mô tả vai trò của thuộc tính `ping` trên thẻ `<a>` và nó được sử dụng trong ngữ cảnh nào?",
      "options": [
        "Thuộc tính `ping` cho phép trình duyệt gửi một yêu cầu POST nhỏ đến các URL được chỉ định khi người dùng click vào liên kết, thường được dùng để theo dõi click hoặc gửi thông báo. Điều này diễn ra trong nền và không ảnh hưởng đến điều hướng của người dùng.",
        "Thuộc tính `ping` dùng để kiểm tra xem URL đích có hoạt động hay không trước khi điều hướng, hiển thị lỗi nếu không truy cập được.",
        "Thuộc tính `ping` cho phép trình duyệt tải trước nội dung của liên kết đích để tăng tốc độ điều hướng.",
        "Thuộc tính `ping` ngăn chặn các công cụ tìm kiếm theo dõi liên kết này, giúp quản lý quyền riêng tư."
      ],
      "correctAnswer": 0
    },
    {
      "id": 95,
      "topicId": 1,
      "question": "Khi nào nên sử dụng thuộc tính `tabindex` với giá trị không phải `0` hoặc `-1`, và những rủi ro về khả năng truy cập cần lưu ý?",
      "options": [
        "Không nên sử dụng `tabindex` với giá trị dương (1 trở lên) vì nó thay đổi thứ tự tab tự nhiên và có thể gây khó hiểu cho người dùng bàn phím và screen reader. Giá trị `0` đưa phần tử vào thứ tự tab tự nhiên. Giá trị `-1` loại bỏ phần tử khỏi thứ tự tab nhưng vẫn cho phép tập trung vào nó bằng JavaScript. Việc sử dụng giá trị dương là một anti-pattern về khả năng truy cập.",
        "`tabindex` với giá trị dương giúp tăng cường bảo mật cho form.",
        "`tabindex` với giá trị dương làm cho phần tử không thể click được.",
        "`tabindex` với giá trị dương chỉ được dùng cho các phần tử chỉ đọc."
      ],
      "correctAnswer": 0
    },
    {
      "id": 96,
      "topicId": 1,
      "question": "Giải thích vai trò của thuộc tính `nonce` trong Content Security Policy (CSP) và cách nó giúp giảm thiểu các cuộc tấn công XSS.",
      "options": [
        "Thuộc tính `nonce` (number used once) là một chuỗi ngẫu nhiên duy nhất được tạo ra cho mỗi yêu cầu trang và được đặt trong các thẻ `<script>` hoặc `<style>`. Nó phải khớp với giá trị `nonce` được chỉ định trong header CSP. Điều này cho phép trình duyệt chỉ thực thi hoặc áp dụng các script/style có `nonce` hợp lệ, ngăn chặn việc thực thi mã độc được tiêm vào (XSS).",
        "Thuộc tính `nonce` mã hóa nội dung của script trước khi gửi đi, bảo vệ khỏi bị nghe lén.",
        "Thuộc tính `nonce` giới hạn thời gian tồn tại của script trên trình duyệt, giúp tự động xóa các script lỗi thời.",
        "Thuộc tính `nonce` xác minh danh tính của người dùng trước khi cho phép script chạy, tăng cường xác thực."
      ],
      "correctAnswer": 0
    },
    {
      "id": 97,
      "topicId": 1,
      "question": "Thẻ `<label>` và thuộc tính `for` của nó có vai trò gì trong việc cải thiện khả năng truy cập của form HTML?",
      "options": [
        "Thẻ `<label>` cung cấp một nhãn văn bản liên kết ngữ nghĩa với một trường nhập liệu form (thường là `<input>`, `<textarea>`, `<select>`) thông qua thuộc tính `for` trỏ đến `id` của trường. Điều này giúp người dùng screen reader hiểu rõ mục đích của trường nhập liệu và cũng cho phép người dùng nhấp vào nhãn để tập trung vào trường liên quan, cải thiện đáng kể UX và accessibility.",
        "Thẻ `<label>` chỉ dùng để định dạng văn bản nhãn, không có ý nghĩa ngữ nghĩa đặc biệt.",
        "Thuộc tính `for` trong `<label>` được dùng để xác định màu sắc của nhãn.",
        "Thẻ `<label>` và thuộc tính `for` chỉ áp dụng cho các form có JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 98,
      "topicId": 1,
      "question": "Mô tả cơ chế hoạt động của `Web Share API` và `Web Share Target API` trong HTML và lợi ích của chúng cho Progressive Web Apps (PWAs).",
      "options": [
        "`Web Share API` cho phép ứng dụng web kích hoạt tính năng chia sẻ nội dung gốc của hệ điều hành (ví dụ: chia sẻ URL, văn bản, hình ảnh). `Web Share Target API` cho phép PWA của bạn nhận nội dung được chia sẻ từ các ứng dụng khác trên hệ điều hành. Cả hai đều cải thiện trải nghiệm người dùng bằng cách tích hợp PWA sâu hơn vào hệ sinh thái thiết bị, giống như ứng dụng native.",
        "`Web Share API` và `Web Share Target API` giúp nén dữ liệu trước khi chia sẻ, giảm băng thông.",
        "`Web Share API` và `Web Share Target API` chỉ cho phép chia sẻ nội dung giữa các PWA khác nhau.",
        "`Web Share API` và `Web Share Target API` là các công cụ bảo mật để ngăn chặn chia sẻ nội dung không mong muốn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 99,
      "topicId": 1,
      "question": "Thẻ `<output>` trong HTML5 có ý nghĩa ngữ nghĩa gì và nó thường được sử dụng trong trường hợp nào?",
      "options": [
        "Thẻ `<output>` đại diện cho kết quả của một phép tính hoặc hành động của người dùng (ví dụ: kết quả của một biểu thức, phản hồi từ server). Nó thường được dùng kết hợp với các phần tử form (ví dụ: `<input type=\"range\">` và JavaScript) để hiển thị kết quả động cho người dùng mà không cần gửi form.",
        "Thẻ `<output>` dùng để nhúng các file âm thanh hoặc video.",
        "Thẻ `<output>` dùng để hiển thị các thông báo debug từ JavaScript.",
        "Thẻ `<output>` là một cách để in nội dung trang ra giấy."
      ],
      "correctAnswer": 0
    },
    {
      "id": 100,
      "topicId": 1,
      "question": "Giải thích khái niệm 'Critical CSS' và cách nó được sử dụng để tối ưu hóa hiệu suất tải trang ban đầu.",
      "options": [
        "Critical CSS là một tập hợp tối thiểu các quy tắc CSS cần thiết để hiển thị nội dung 'above-the-fold' (phần trang hiển thị ngay khi tải mà không cần cuộn) một cách nhanh nhất. Bằng cách nhúng (inline) Critical CSS trực tiếp vào thẻ `<style>` trong `<head>` của HTML, trình duyệt có thể hiển thị nội dung quan trọng mà không cần đợi file CSS bên ngoài tải xong, cải thiện **First Contentful Paint (FCP)** và **Largest Contentful Paint (LCP)**.",
        "Critical CSS là CSS được sử dụng để tạo các animation quan trọng trên trang.",
        "Critical CSS là các quy tắc CSS được trình duyệt tự động ưu tiên tải trước.",
        "Critical CSS là CSS được sử dụng để phát hiện lỗi trong layout."
      ],
      "correctAnswer": 0
    },
    {
      "id": 101,
      "topicId": 2,
      "question": "Trong CSS Grid Layout, sự khác biệt chính giữa `grid-template-columns` và `grid-auto-columns` là gì và khi nào nên sử dụng từng thuộc tính?",
      "options": [
        "`grid-template-columns` xác định số lượng và kích thước của các cột được định nghĩa rõ ràng (explicit grid tracks), trong khi `grid-auto-columns` xác định kích thước của các cột được tạo tự động (implicit grid tracks) khi có nhiều item hơn số cột đã định nghĩa. Nên dùng `grid-template-columns` cho cấu trúc chính, và `grid-auto-columns` cho nội dung tràn.",
        "`grid-template-columns` chỉ dùng cho bố cục một chiều, còn `grid-auto-columns` dùng cho bố cục hai chiều.",
        "`grid-template-columns` chỉ áp dụng cho trình duyệt cũ, còn `grid-auto-columns` cho trình duyệt hiện đại.",
        "Cả hai thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 102,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Specificity' và cách nó ảnh hưởng đến việc áp dụng các quy tắc CSS khi có xung đột.",
      "options": [
        "CSS Specificity là một hệ thống tính điểm mà trình duyệt sử dụng để quyết định quy tắc CSS nào sẽ được áp dụng khi nhiều quy tắc nhắm mục tiêu cùng một phần tử. Thứ tự ưu tiên (từ cao đến thấp) thường là: inline styles > IDs > Classes, attributes, pseudo-classes > Elements, pseudo-elements. Quy tắc có độ đặc hiệu cao hơn sẽ được ưu tiên.",
        "CSS Specificity là kỹ thuật nén file CSS để tăng tốc độ tải trang.",
        "CSS Specificity là cách để tạo ra các biến CSS toàn cục.",
        "CSS Specificity là một thuộc tính để định nghĩa các media query phức tạp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 103,
      "topicId": 2,
      "question": "Thuộc tính `clip-path` trong CSS có tác dụng gì và những trường hợp sử dụng sáng tạo của nó?",
      "options": [
        "Thuộc tính `clip-path` cho phép bạn tạo ra một vùng cắt (clipping region) cho một phần tử, chỉ hiển thị phần nội dung bên trong vùng đó và ẩn phần còn lại. Nó có thể được sử dụng để tạo các hình dạng không phải hình chữ nhật (hình tròn, đa giác), hiệu ứng hover sáng tạo, hoặc hiệu ứng chuyển động cắt hình ảnh/video.",
        "Thuộc tính `clip-path` dùng để tạo bóng đổ cho phần tử.",
        "Thuộc tính `clip-path` kiểm soát việc cuộn nội dung bên trong phần tử.",
        "Thuộc tính `clip-path` chỉ định đường dẫn mà animation sẽ đi theo."
      ],
      "correctAnswer": 0
    },
    {
      "id": 104,
      "topicId": 2,
      "question": "Sự khác biệt giữa `transform: translate()` và `position: relative/absolute` để di chuyển phần tử là gì, và tại sao `transform` thường được ưu tiên cho animation?",
      "options": [
        "`transform: translate()` di chuyển phần tử mà không gây ra reflow (thay đổi vị trí các phần tử khác) và được tối ưu hóa tốt hơn cho GPU, dẫn đến animation mượt mà hơn. `position: relative/absolute` thay đổi vị trí trong luồng tài liệu, có thể gây reflow và thường ít hiệu quả hơn về mặt hiệu suất cho animation.",
        "`transform: translate()` chỉ có thể di chuyển theo trục X, còn `position` có thể di chuyển theo cả X và Y.",
        "`transform` chỉ hoạt động trên các trình duyệt hiện đại, còn `position` thì không.",
        "Cả hai phương pháp đều có hiệu suất như nhau cho animation."
      ],
      "correctAnswer": 0
    },
    {
      "id": 105,
      "topicId": 2,
      "question": "Giải thích vai trò của thuộc tính `font-display` trong `@font-face` và tác động của nó đến hiệu suất tải font và trải nghiệm người dùng.",
      "options": [
        "`font-display` xác định cách font được tải và hiển thị (hoặc ẩn) trước khi nó hoàn tất việc tải. Các giá trị như `swap`, `fallback`, `optional` giúp kiểm soát hiện tượng **Flash of Unstyled Text (FOUT)** hoặc **Flash of Invisible Text (FOIT)**, cải thiện trải nghiệm người dùng bằng cách đảm bảo văn bản hiển thị nhanh chóng, dù có thể ban đầu bằng font dự phòng.",
        "`font-display` cho phép bạn thay đổi màu sắc của font chữ dựa trên điều kiện của trình duyệt.",
        "`font-display` tự động nén kích thước của file font để tăng tốc độ tải.",
        "`font-display` là một cách để mã hóa font để ngăn chặn việc sao chép trái phép."
      ],
      "correctAnswer": 0
    },
    {
      "id": 106,
      "topicId": 2,
      "question": "Trong CSS, khái niệm 'BEM' (Block, Element, Modifier) là gì và lợi ích của nó trong việc quản lý CSS ở quy mô lớn?",
      "options": [
        "BEM là một quy ước đặt tên class CSS giúp tổ chức mã, làm cho CSS mô-đun, dễ tái sử dụng và dễ hiểu hơn. Nó tách biệt các thành phần UI (Block), các phần của thành phần (Element), và các biến thể của thành phần (Modifier). Lợi ích: giúp tránh xung đột class, dễ dàng mở rộng và bảo trì codebase CSS lớn.",
        "BEM là một công cụ nén CSS để giảm kích thước file.",
        "BEM là một phương pháp để viết CSS chỉ bằng JavaScript.",
        "BEM là một tiêu chuẩn CSS mới để tạo các layout phức tạp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 107,
      "topicId": 2,
      "question": "Thuộc tính `will-change` trong CSS có tác dụng gì và khi nào nên sử dụng nó một cách thận trọng để tối ưu hóa hiệu suất?",
      "options": [
        "`will-change` là một thuộc tính gợi ý cho trình duyệt biết rằng một phần tử sẽ thay đổi một hoặc nhiều thuộc tính CSS trong tương lai gần (ví dụ: `transform`, `opacity`). Điều này cho phép trình duyệt tối ưu hóa trước (ví dụ: tạo layer GPU riêng), giúp animation/transition mượt mà hơn. Nên sử dụng thận trọng và chỉ khi cần thiết vì việc lạm dụng có thể gây tốn bộ nhớ hoặc tài nguyên CPU.",
        "`will-change` buộc trình duyệt phải tải lại toàn bộ trang khi có bất kỳ thay đổi CSS nào.",
        "`will-change` tự động tạo các hiệu ứng chuyển động cho phần tử mà không cần viết keyframes.",
        "`will-change` ngăn chặn các thuộc tính CSS khác ảnh hưởng đến phần tử."
      ],
      "correctAnswer": 0
    },
    {
      "id": 108,
      "topicId": 2,
      "question": "Phân biệt giữa `rem` và `em` trong CSS và khi nào nên ưu tiên sử dụng từng đơn vị để tạo responsive typography và layout.",
      "options": [
        "`em` là đơn vị tương đối so với `font-size` của phần tử cha trực tiếp. `rem` (root em) là đơn vị tương đối so với `font-size` của phần tử gốc (`<html>`). `rem` thường được ưu tiên cho typography và layout tổng thể để tránh hiệu ứng 'compounding' (font size tăng lũy tiến) của `em`, giúp dễ quản lý tỷ lệ toàn trang.",
        "`rem` chỉ dùng cho font size, còn `em` dùng cho mọi thuộc tính kích thước.",
        "`rem` được hỗ trợ bởi tất cả các trình duyệt, còn `em` thì không.",
        "`em` là đơn vị cố định, còn `rem` là đơn vị tương đối."
      ],
      "correctAnswer": 0
    },
    {
      "id": 109,
      "topicId": 2,
      "question": "Giải thích cách hoạt động của `CSS Custom Properties` (biến CSS) và lợi ích của chúng so với các biến từ preprocessor (như Sass/Less).",
      "options": [
        "CSS Custom Properties (ví dụ: `--primary-color: blue;`) là các biến được định nghĩa trực tiếp trong CSS và có thể được truy cập bằng hàm `var()`. Lợi ích: có thể thay đổi động bằng JavaScript, kế thừa theo Cascading, và hoạt động ngay trong trình duyệt mà không cần biên dịch. Khác với biến preprocessor chỉ là thay thế tĩnh khi biên dịch.",
        "CSS Custom Properties chỉ có thể lưu trữ giá trị số, không thể lưu trữ chuỗi.",
        "CSS Custom Properties chỉ hoạt động trong môi trường phát triển, không hoạt động trên production.",
        "CSS Custom Properties có thể được sử dụng để điều khiển các API của trình duyệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 110,
      "topicId": 2,
      "question": "Trong CSS Grid, sự khác biệt giữa `fr` unit và `auto` keyword là gì khi định nghĩa kích thước track?",
      "options": [
        "`fr` (fractional unit) đại diện cho một phần không gian trống còn lại trong grid container sau khi đã phân bổ không gian cho các track có kích thước cố định hoặc `auto`. `auto` cho phép track tự động điều chỉnh kích thước để chứa nội dung của nó, có thể co lại hoặc giãn ra. `fr` là để phân bổ không gian khả dụng, `auto` là để dựa vào nội dung.",
        "`fr` chỉ định kích thước tuyệt đối, còn `auto` chỉ định kích thước tương đối.",
        "`fr` chỉ áp dụng cho cột, còn `auto` áp dụng cho hàng.",
        "Cả hai đều có chức năng tương tự, nhưng `fr` hiệu quả hơn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 111,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `aspect-ratio` trong CSS và cách nó giúp quản lý responsive images/videos mà không cần padding hack.",
      "options": [
        "Thuộc tính `aspect-ratio` cho phép bạn xác định tỷ lệ khung hình cố định cho một phần tử (ví dụ: `16 / 9`, `1 / 1`). Điều này giúp duy trì tỷ lệ hình dạng của phần tử khi kích thước của nó thay đổi trong responsive layout, đặc biệt hữu ích cho `<img>`, `<video>` hoặc các container không có intrinsic size, ngăn chặn CLS.",
        "Thuộc tính `aspect-ratio` tự động cắt hình ảnh để phù hợp với tỷ lệ khung hình mong muốn.",
        "Thuộc tính `aspect-ratio` chỉ áp dụng cho các phần tử có `position: fixed`.",
        "Thuộc tính `aspect-ratio` là một cách để chuyển đổi hình ảnh sang định dạng WebP."
      ],
      "correctAnswer": 0
    },
    {
      "id": 112,
      "topicId": 2,
      "question": "Giải thích cách hoạt động của `::marker` pseudo-element trong CSS và khả năng tùy chỉnh nó.",
      "options": [
        "`::marker` là một pseudo-element cho phép bạn style các ký hiệu đánh dấu của các mục trong danh sách (`<li>`, `<summary>`). Bạn có thể thay đổi màu sắc, kích thước font, hoặc thậm chí nội dung của marker bằng thuộc tính `content` và các thuộc tính liên quan đến font/color, cung cấp khả năng tùy chỉnh cao hơn so với mặc định của trình duyệt.",
        "`::marker` được sử dụng để tạo các biểu tượng trên bản đồ.",
        "`::marker` chỉ định vị trí của con trỏ chuột trên trang.",
        "`::marker` là một thuộc tính CSS để tạo các hiệu ứng chuyển động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 113,
      "topicId": 2,
      "question": "Trong Flexbox, sự khác biệt giữa `align-items` và `align-content` là gì và khi nào nên sử dụng từng thuộc tính?",
      "options": [
        "`align-items` căn chỉnh các item riêng lẻ dọc theo trục cross-axis (ngang nếu `flex-direction: row`, dọc nếu `flex-direction: column`). `align-content` căn chỉnh các *dòng* (flex lines) của các item dọc theo trục cross-axis khi có nhiều dòng (do `flex-wrap: wrap`). `align-content` chỉ có tác dụng khi có nhiều hơn một dòng flex.",
        "`align-items` căn chỉnh item theo trục chính, còn `align-content` căn chỉnh item theo trục phụ.",
        "`align-items` chỉ dùng cho các container có một dòng, còn `align-content` cho các container có nhiều dòng.",
        "Cả hai thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 114,
      "topicId": 2,
      "question": "Thuộc tính `contain` trong CSS có tác dụng gì và cách nó cải thiện hiệu suất rendering?",
      "options": [
        "Thuộc tính `contain` cho phép bạn cô lập một phần của DOM, chỉ thị cho trình duyệt rằng phần tử con bên trong sẽ không ảnh hưởng đến layout, style, hoặc paint của phần còn lại của trang. Điều này giúp trình duyệt tối ưu hóa quá trình rendering bằng cách hạn chế phạm vi tính toán lại khi có thay đổi, tăng hiệu suất, đặc biệt là với các phần tử phức tạp hoặc chứa nội dung động.",
        "`contain` làm cho phần tử không thể tương tác được với người dùng.",
        "`contain` tự động nén nội dung của phần tử để giảm kích thước tải xuống.",
        "`contain` chỉ định xem phần tử có nên được hiển thị trong chế độ xem di động hay không."
      ],
      "correctAnswer": 0
    },
    {
      "id": 115,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Logical Properties' (ví dụ: `margin-inline-start`, `padding-block-end`) và lợi ích của chúng cho đa ngôn ngữ và RTL.",
      "options": [
        "CSS Logical Properties thay thế các thuộc tính vật lý (như `margin-left`, `padding-top`) bằng các thuộc tính dựa trên hướng viết của văn bản (text direction) và chế độ viết (writing mode). Ví dụ, `margin-inline-start` sẽ là `margin-left` cho LTR và `margin-right` cho RTL. Lợi ích: tạo layout dễ dàng thích ứng với các ngôn ngữ đọc từ phải sang trái (RTL) hoặc từ trên xuống dưới, cải thiện khả năng quốc tế hóa.",
        "CSS Logical Properties giúp tạo ra các hiệu ứng chuyển động mượt mà hơn.",
        "CSS Logical Properties là một cách để mã hóa CSS để ngăn chặn việc chỉnh sửa trái phép.",
        "CSS Logical Properties chỉ hoạt động trong các trình duyệt thử nghiệm."
      ],
      "correctAnswer": 0
    },
    {
      "id": 116,
      "topicId": 2,
      "question": "Mô tả vai trò của `display: contents` trong CSS Grid/Flexbox và những vấn đề về khả năng truy cập (accessibility) cần lưu ý khi sử dụng nó.",
      "options": [
        "`display: contents` làm cho phần tử container biến mất khỏi cây DOM ảo (accessibility tree) và các hộp CSS của nó bị loại bỏ, nhưng các phần tử con của nó vẫn được giữ lại trong luồng layout và thừa kế thuộc tính từ cha của container đó. Nó hữu ích để làm phẳng cấu trúc DOM trong Grid/Flexbox, nhưng có thể gây vấn đề về accessibility vì các công cụ đọc màn hình có thể bỏ qua phần tử cha ban đầu.",
        "`display: contents` ẩn hoàn toàn phần tử và các con của nó khỏi DOM.",
        "`display: contents` làm cho phần tử trở thành một Flex container mà không cần khai báo `display: flex`.",
        "`display: contents` tự động thêm một cuộn ngang cho nội dung quá dài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 117,
      "topicId": 2,
      "question": "Thuộc tính `text-rendering` trong CSS có tác dụng gì và khi nào nên sử dụng các giá trị khác nhau của nó?",
      "options": [
        "`text-rendering` gợi ý cho trình duyệt về cách ưu tiên render văn bản: tốc độ, độ chính xác, hoặc tối ưu hóa cho màn hình (pixelated). Giá trị `optimizeLegibility` ưu tiên độ rõ ràng (cho các font lớn), `optimizeSpeed` ưu tiên tốc độ, `geometricPrecision` ưu tiên độ chính xác hình học. Thường dùng để tinh chỉnh hiển thị font chữ, đặc biệt là với font tùy chỉnh.",
        "`text-rendering` chuyển đổi văn bản sang dạng hình ảnh để tối ưu hóa hiển thị.",
        "`text-rendering` mã hóa văn bản để ngăn chặn việc sao chép.",
        "`text-rendering` tự động căn chỉnh văn bản vào giữa phần tử."
      ],
      "correctAnswer": 0
    },
    {
      "id": 118,
      "topicId": 2,
      "question": "Sự khác biệt giữa `box-sizing: content-box` và `box-sizing: border-box` là gì và tại sao `border-box` thường được ưu tiên trong CSS hiện đại?",
      "options": [
        "`content-box` (mặc định) chỉ bao gồm `width`/`height` của nội dung, `padding` và `border` được thêm vào bên ngoài. `border-box` bao gồm `padding` và `border` vào trong `width`/`height` đã định nghĩa. `border-box` được ưu tiên vì nó làm cho việc tính toán kích thước phần tử dễ đoán và trực quan hơn, đơn giản hóa layout và responsive design.",
        "`content-box` chỉ hoạt động với Flexbox, còn `border-box` chỉ hoạt động với Grid.",
        "`content-box` cho hiệu suất tốt hơn khi render, còn `border-box` thì không.",
        "Không có sự khác biệt đáng kể giữa hai thuộc tính này; chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 119,
      "topicId": 2,
      "question": "Giải thích vai trò của thuộc tính `image-set()` trong CSS và cách nó giúp quản lý responsive images trong `background-image`.",
      "options": [
        "`image-set()` cho phép bạn cung cấp nhiều phiên bản của một hình ảnh nền (background image) với các độ phân giải hoặc định dạng khác nhau. Trình duyệt sẽ tự động chọn phiên bản tối ưu nhất dựa trên mật độ pixel của màn hình (device-pixel-ratio) và khả năng hỗ trợ định dạng, tương tự như `srcset` cho `<img>`.",
        "`image-set()` tự động tạo các hiệu ứng parallax cho hình ảnh nền.",
        "`image-set()` chỉ áp dụng cho các hình ảnh vector, không phải hình ảnh raster.",
        "`image-set()` là một cách để mã hóa hình ảnh để bảo vệ chúng khỏi việc sao chép."
      ],
      "correctAnswer": 0
    },
    {
      "id": 120,
      "topicId": 2,
      "question": "Mô tả cách hoạt động của `@property` (CSS Houdini) và tiềm năng của nó trong việc tạo các thuộc tính CSS tùy chỉnh có khả năng hoạt hình (animatable) và kiểm tra kiểu (type-checked).",
      "options": [
        "`@property` cho phép bạn đăng ký CSS Custom Properties với một kiểu dữ liệu, giá trị ban đầu, và cờ kế thừa. Điều này biến các biến CSS thông thường thành các thuộc tính tùy chỉnh được trình duyệt hiểu sâu sắc hơn, cho phép chúng có thể được hoạt hình mượt mà (transition/animation) và kiểm tra kiểu dữ liệu, mở ra khả năng sáng tạo mới trong CSS.",
        "`@property` là một cách để tạo các biến JavaScript trong CSS.",
        "`@property` chỉ định tên của file CSS sẽ được tải.",
        "`@property` tự động thêm tiền tố (prefix) cho các thuộc tính CSS cũ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 121,
      "topicId": 2,
      "question": "Trong CSS Grid, thuộc tính `gap` (hoặc `grid-gap`) được sử dụng để làm gì và lợi ích của nó so với việc sử dụng `margin`?",
      "options": [
        "`gap` tạo khoảng trống giữa các hàng và cột trong grid layout, mà không thêm khoảng trống thừa ở các cạnh của container hoặc giữa các phần tử không liền kề. Lợi ích: đơn giản hóa việc quản lý khoảng cách trong grid, tránh các vấn đề 'collapsing margins' hoặc 'extra margins' thường gặp với `margin`, và giữ cho grid item dễ dàng căn chỉnh.",
        "`gap` chỉ áp dụng cho các phần tử hình ảnh trong grid.",
        "`gap` chỉ định kích thước tối thiểu của các track trong grid.",
        "`gap` tự động thêm một đường viền (border) xung quanh các grid item."
      ],
      "correctAnswer": 0
    },
    {
      "id": 122,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Variables Scope' (phạm vi của biến CSS) và cách nó ảnh hưởng đến việc kế thừa giá trị.",
      "options": [
        "Phạm vi của biến CSS được xác định bởi nơi nó được định nghĩa trong cây DOM. Một biến được định nghĩa trên một phần tử sẽ có thể được sử dụng bởi chính phần tử đó và tất cả các phần tử con của nó. Điều này cho phép tạo các biến cục bộ hoặc toàn cục, và chúng kế thừa theo cascading, giúp quản lý style linh hoạt hơn.",
        "Phạm vi của biến CSS chỉ có thể là toàn cục (global) hoặc cục bộ (local).",
        "Biến CSS chỉ có thể được truy cập bằng JavaScript, không thể được kế thừa.",
        "Biến CSS chỉ hoạt động trong một số trình duyệt nhất định."
      ],
      "correctAnswer": 0
    },
    {
      "id": 123,
      "topicId": 2,
      "question": "Sự khác biệt giữa `position: sticky` và `position: fixed` là gì và khi nào nên sử dụng `sticky`?",
      "options": [
        "`position: fixed` giữ phần tử cố định ở một vị trí trên viewport, bất kể cuộn trang. `position: sticky` hoạt động như `relative` cho đến khi phần tử cuộn đến một ngưỡng nhất định (xác định bởi `top`, `bottom`, `left`, `right`), sau đó nó sẽ 'dính' vào vị trí đó giống như `fixed`. Nên dùng `sticky` cho các thanh điều hướng, tiêu đề section hoặc sidebar cần 'dính' khi cuộn qua.",
        "`position: sticky` chỉ hoạt động trên thiết bị di động, còn `fixed` hoạt động trên desktop.",
        "`position: sticky` yêu cầu JavaScript để hoạt động, còn `fixed` thì không.",
        "Cả hai thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 124,
      "topicId": 2,
      "question": "Thuộc tính `filter` trong CSS có tác dụng gì và cách nó giúp tạo hiệu ứng hình ảnh mà không cần chỉnh sửa file ảnh gốc?",
      "options": [
        "Thuộc tính `filter` cho phép bạn áp dụng các hiệu ứng đồ họa như làm mờ (`blur()`), làm sáng (`brightness()`), làm tối (`contrast()`), đổ bóng (`drop-shadow()`) trực tiếp lên một phần tử HTML (bao gồm hình ảnh, văn bản). Điều này giúp tạo hiệu ứng hình ảnh động và tương tác mà không cần sửa đổi file ảnh gốc hoặc sử dụng JavaScript phức tạp.",
        "Thuộc tính `filter` giúp nén hình ảnh, giảm kích thước file.",
        "Thuộc tính `filter` chỉ áp dụng cho văn bản, không áp dụng cho hình ảnh.",
        "Thuộc tính `filter` là một cách để mã hóa nội dung để ngăn chặn việc sao chép."
      ],
      "correctAnswer": 0
    },
    {
      "id": 125,
      "topicId": 2,
      "question": "Mô tả vai trò của `prefers-color-scheme` media feature trong CSS và cách nó hỗ trợ Dark Mode.",
      "options": [
        "`prefers-color-scheme` cho phép bạn áp dụng các style CSS khác nhau dựa trên sở thích chế độ màu (sáng hoặc tối) mà người dùng đã thiết lập trong hệ điều hành của họ. Điều này giúp dễ dàng triển khai Dark Mode (chế độ tối) cho trang web mà không cần JavaScript hoặc chuyển đổi thủ công, cải thiện trải nghiệm người dùng.",
        "`prefers-color-scheme` tự động chuyển đổi màu sắc của trang web dựa trên thời gian trong ngày.",
        "`prefers-color-scheme` chỉ áp dụng cho các trang web tĩnh, không áp dụng cho các ứng dụng web động.",
        "`prefers-color-scheme` giúp phát hiện lỗi màu sắc trong thiết kế."
      ],
      "correctAnswer": 0
    },
    {
      "id": 126,
      "topicId": 2,
      "question": "Trong CSS, khái niệm 'Container Queries' (ví dụ: `@container`) là gì và lợi ích của chúng so với Media Queries truyền thống?",
      "options": [
        "Container Queries cho phép bạn áp dụng style CSS dựa trên kích thước của **container cha** của một phần tử, thay vì kích thước của toàn bộ viewport (như Media Queries). Lợi ích: cho phép tạo các component thực sự linh hoạt và độc lập với vị trí, vì chúng tự điều chỉnh dựa trên không gian có sẵn, không phụ thuộc vào kích thước màn hình tổng thể. Điều này giúp xây dựng các hệ thống thiết kế mô-đun hơn.",
        "Container Queries giúp kiểm soát hiệu suất tải trang bằng cách tải CSS theo khối.",
        "Container Queries là một cách để tạo các biến CSS động.",
        "Container Queries chỉ áp dụng cho các phần tử Flexbox."
      ],
      "correctAnswer": 0
    },
    {
      "id": 127,
      "topicId": 2,
      "question": "Giải thích sự khác biệt giữa `margin` và `padding` trong CSS Box Model và tác động của chúng đến kích thước và bố cục phần tử.",
      "options": [
        "`padding` là không gian bên trong phần tử, giữa nội dung và đường viền (border). `margin` là không gian bên ngoài phần tử, tạo khoảng cách giữa phần tử đó và các phần tử lân cận. `padding` thêm vào kích thước của phần tử con nhưng vẫn nằm trong background của phần tử, còn `margin` là khoảng cách bên ngoài và trong suốt, không ảnh hưởng đến kích thước thực tế của phần tử (chỉ là khoảng cách xung quanh).",
        "`margin` chỉ áp dụng cho các phần tử block, còn `padding` áp dụng cho cả inline.",
        "`margin` có thể âm, còn `padding` thì không.",
        "Cả hai thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 128,
      "topicId": 2,
      "question": "Thuộc tính `object-fit` và `object-position` trong CSS có tác dụng gì và chúng giúp kiểm soát hình ảnh/video trong các container như thế nào?",
      "options": [
        "`object-fit` xác định cách nội dung của một phần tử thay thế (ví dụ: `<img>`, `<video>`) nên được thay đổi kích thước để vừa với hộp của nó (ví dụ: `cover`, `contain`, `fill`). `object-position` xác định cách nội dung được căn chỉnh bên trong hộp đó. Chúng rất hữu ích để kiểm soát cách hình ảnh/video hiển thị trong các container có kích thước cố định mà không làm méo hoặc cắt bỏ quá nhiều.",
        "`object-fit` và `object-position` chỉ áp dụng cho các phần tử 3D.",
        "`object-fit` và `object-position` giúp tự động tạo các hiệu ứng phản chiếu cho hình ảnh.",
        "`object-fit` và `object-position` là thuộc tính mới chỉ hỗ trợ trên trình duyệt di động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 129,
      "topicId": 2,
      "question": "Mô tả vai trò của `calc()` function trong CSS và những trường hợp sử dụng phức tạp của nó.",
      "options": [
        "`calc()` cho phép bạn thực hiện các phép tính toán (cộng, trừ, nhân, chia) trực tiếp trong các giá trị thuộc tính CSS. Nó hữu ích cho việc kết hợp các đơn vị khác nhau (ví dụ: `width: calc(100% - 20px)`), tạo khoảng cách động, hoặc tính toán kích thước trong responsive layout mà không cần JavaScript. Nó giúp tạo bố cục linh hoạt và chính xác hơn.",
        "`calc()` chỉ có thể thực hiện phép cộng và trừ, không thể nhân chia.",
        "`calc()` chỉ dùng cho các biến CSS, không thể dùng trực tiếp với các giá trị thuộc tính.",
        "`calc()` là một hàm JavaScript, không phải là hàm CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 130,
      "topicId": 2,
      "question": "Trong CSS, khái niệm 'Stacking Context' là gì và cách các thuộc tính như `z-index`, `position`, `opacity`, `transform` ảnh hưởng đến nó?",
      "options": [
        "Stacking Context là một khái niệm trong việc render web, xác định thứ tự xếp chồng (layering) của các phần tử trên trục Z. Các thuộc tính như `position` (khác `static`), `z-index` (trên phần tử có `position` khác `static`), `opacity`, `transform`, `filter`... có thể tạo ra một stacking context mới, ảnh hưởng đến cách các phần tử con của nó được xếp chồng lên nhau và lên các phần tử khác trên trang.",
        "Stacking Context chỉ định thứ tự mà các file CSS được tải.",
        "Stacking Context là một cách để tạo các hiệu ứng 3D trên trang web.",
        "Stacking Context chỉ liên quan đến việc đặt vị trí của các phần tử trong Flexbox."
      ],
      "correctAnswer": 0
    },
    {
      "id": 131,
      "topicId": 2,
      "question": "Giải thích vai trò của `display: flex` và `display: grid` trong CSS và khi nào nên ưu tiên sử dụng từng loại cho bố cục trang?",
      "options": [
        "`display: flex` (Flexbox) được thiết kế cho bố cục một chiều (hàng hoặc cột), lý tưởng để sắp xếp các nhóm phần tử nhỏ hơn, căn chỉnh chúng và phân bổ không gian trong một chiều. `display: grid` (CSS Grid) được thiết kế cho bố cục hai chiều (hàng và cột), lý tưởng để định nghĩa cấu trúc tổng thể của trang hoặc các phần phức tạp cần căn chỉnh cả theo chiều ngang và dọc. Nên dùng Flexbox cho component, Grid cho layout tổng thể.",
        "`display: flex` chỉ hoạt động trên thiết bị di động, còn `display: grid` chỉ hoạt động trên desktop.",
        "`display: flex` cho hiệu suất tốt hơn `display: grid` trong mọi trường hợp.",
        "Cả hai thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 132,
      "topicId": 2,
      "question": "Thuộc tính `scroll-snap-type` và `scroll-snap-align` trong CSS có tác dụng gì và chúng giúp tạo trải nghiệm cuộn mượt mà như thế nào?",
      "options": [
        "Các thuộc tính `scroll-snap` cho phép bạn xác định các 'điểm neo' mà trình duyệt sẽ 'bắt dính' khi người dùng cuộn. `scroll-snap-type` đặt hành vi chụp dính (ví dụ: `mandatory`, `proximity`), và `scroll-snap-align` xác định vị trí mà phần tử con sẽ chụp dính (ví dụ: `start`, `center`, `end`). Điều này tạo ra trải nghiệm cuộn theo từng phần (pagination) mượt mà và được kiểm soát.",
        "`scroll-snap-type` và `scroll-snap-align` chỉ áp dụng cho việc cuộn ngang, không áp dụng cho cuộn dọc.",
        "`scroll-snap-type` và `scroll-snap-align` tự động thêm một thanh cuộn tùy chỉnh vào phần tử.",
        "`scroll-snap-type` và `scroll-snap-align` là các thuộc tính JavaScript, không phải CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 133,
      "topicId": 2,
      "question": "Mô tả vai trò của `clamp()`, `min()`, và `max()` functions trong CSS và cách chúng giúp tạo typography và layout linh hoạt hơn.",
      "options": [
        "`min()` chọn giá trị nhỏ nhất từ một danh sách các giá trị, `max()` chọn giá trị lớn nhất, và `clamp()` giữ một giá trị trong một phạm vi giữa giá trị tối thiểu và tối đa. Các hàm này cho phép bạn tạo các giá trị động cho thuộc tính CSS (ví dụ: `font-size: clamp(1rem, 2vw + 1rem, 3rem)`), giúp responsive typography và layout mà không cần nhiều media queries.",
        "Các hàm này dùng để thực hiện các phép tính toán phức tạp trong JavaScript.",
        "Các hàm này chỉ hoạt động với các đơn vị tuyệt đối như `px`.",
        "Các hàm này là một cách để tạo các biến CSS với giá trị động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 134,
      "topicId": 2,
      "question": "Trong Shadow DOM, làm thế nào để styling các phần tử bên trong Shadow Root từ CSS bên ngoài Light DOM và ngược lại?",
      "options": [
        "Mặc định, Shadow DOM đóng gói CSS, nghĩa là CSS từ Light DOM không ảnh hưởng vào Shadow DOM và ngược lại. Để styling các phần tử bên trong Shadow Root từ ngoài, bạn có thể sử dụng **CSS Custom Properties** (biến CSS) hoặc phần tử **`::part()`** (CSS Shadow Parts). Để style ngược lại, bạn sử dụng các **CSS pseudo-elements** như `::slotted()` để style các phần tử được 'slot' vào Shadow DOM.",
        "Bạn không thể styling Shadow DOM từ Light DOM hoặc ngược lại; chúng hoàn toàn bị cô lập.",
        "Sử dụng `!important` trong CSS để ép buộc style vào Shadow DOM.",
        "Sử dụng JavaScript để thay đổi style trực tiếp cho các phần tử trong Shadow DOM."
      ],
      "correctAnswer": 0
    },
    {
      "id": 135,
      "topicId": 2,
      "question": "Giải thích vai trò của thuộc tính `initial`, `inherit`, `unset`, và `revert` trong CSS để kiểm soát giá trị của thuộc tính.",
      "options": [
        "`initial` đặt thuộc tính về giá trị mặc định của nó theo spec. `inherit` đặt thuộc tính về giá trị của phần tử cha. `unset` đặt thuộc tính về `inherit` nếu nó kế thừa, hoặc `initial` nếu nó không kế thừa. `revert` đặt thuộc tính về giá trị được định nghĩa bởi kiểu của trình duyệt hoặc style của người dùng, trước khi bất kỳ style nào của tác giả (developer) được áp dụng. Chúng hữu ích để reset hoặc kiểm soát luồng style.",
        "Các thuộc tính này chỉ dùng để tạo animation.",
        "Các thuộc tính này chỉ hoạt động với các biến CSS.",
        "Các thuộc tính này giúp mã hóa CSS để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 136,
      "topicId": 2,
      "question": "Mô tả cơ chế hoạt động của `isolation: isolate` trong CSS và lợi ích của nó đối với các hiệu ứng `mix-blend-mode` hoặc `filter`.",
      "options": [
        "`isolation: isolate` tạo ra một stacking context mới và một 'grouping context' mới cho phần tử. Điều này đảm bảo rằng các hiệu ứng như `mix-blend-mode` và `filter` chỉ áp dụng cho nội dung bên trong phần tử đó, không ảnh hưởng đến các phần tử bên ngoài. Nó giúp kiểm soát và dự đoán hành vi của các hiệu ứng phức tạp.",
        "`isolation: isolate` ẩn hoàn toàn phần tử khỏi hiển thị.",
        "`isolation: isolate` chỉ cho phép phần tử hiển thị trên các trình duyệt cũ.",
        "`isolation: isolate` ngăn chặn phần tử nhận các sự kiện click."
      ],
      "correctAnswer": 0
    },
    {
      "id": 137,
      "topicId": 2,
      "question": "Trong CSS, khái niệm 'Layout Shift' (CLS - Cumulative Layout Shift) là gì và những nguyên nhân CSS phổ biến gây ra nó?",
      "options": [
        "Layout Shift (CLS) là khi các phần tử trên trang bất ngờ di chuyển hoặc dịch chuyển sau khi trang đã tải một phần, gây khó chịu cho người dùng. Các nguyên nhân CSS phổ biến bao gồm: hình ảnh/video không có `width`/`height` (intrinsic size), nội dung được chèn động (ví dụ: quảng cáo), font chữ tải muộn gây FOUT/FOIT, hoặc các hiệu ứng/animation thay đổi kích thước/vị trí đột ngột.",
        "Layout Shift là khi trình duyệt thay đổi thứ tự của các file CSS được tải.",
        "Layout Shift là một lỗi xảy ra khi CSS không tương thích với HTML.",
        "Layout Shift chỉ xảy ra trên các thiết bị di động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 138,
      "topicId": 2,
      "question": "Giải thích vai trò của `hyphens` property trong CSS và cách nó cải thiện khả năng đọc của văn bản, đặc biệt là với các ngôn ngữ dài.",
      "options": [
        "Thuộc tính `hyphens` cho phép trình duyệt tự động ngắt từ ở cuối dòng bằng dấu gạch nối (hyphen) khi văn bản bị tràn khỏi container. Điều này giúp cải thiện khả năng đọc, đặc biệt với các từ dài trong các ngôn ngữ có kiểu ngắt từ phức tạp, và tạo bố cục văn bản gọn gàng, đẹp mắt hơn bằng cách giảm khoảng trắng thừa.",
        "`hyphens` tự động thêm các dấu cách vào giữa các từ để căn đều văn bản.",
        "`hyphens` mã hóa văn bản để ngăn chặn việc sao chép.",
        "`hyphens` chỉ áp dụng cho các font chữ tùy chỉnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 139,
      "topicId": 2,
      "question": "Sự khác biệt giữa `transform: scale()` và `font-size` để thay đổi kích thước của văn bản là gì và khi nào nên sử dụng `scale`?",
      "options": [
        "`font-size` thay đổi kích thước thực tế của văn bản và ảnh hưởng đến luồng layout, có thể gây reflow. `transform: scale()` thay đổi kích thước hiển thị của phần tử mà không ảnh hưởng đến layout hoặc các phần tử xung quanh, và thường được GPU tăng tốc. Nên dùng `scale` cho các hiệu ứng phóng to/thu nhỏ animation mượt mà mà không muốn ảnh hưởng đến bố cục trang.",
        "`transform: scale()` chỉ có thể phóng to, không thể thu nhỏ.",
        "`transform: scale()` chỉ áp dụng cho hình ảnh, không áp dụng cho văn bản.",
        "Cả hai thuộc tính đều có hiệu suất như nhau cho animation."
      ],
      "correctAnswer": 0
    },
    {
      "id": 140,
      "topicId": 2,
      "question": "Mô tả vai trò của `@layer` (CSS Cascade Layers) trong CSS và cách nó giúp quản lý độ ưu tiên (specificity) của các stylesheet.",
      "options": [
        "`@layer` cho phép bạn định nghĩa các lớp (layers) trong CSS để quản lý thứ tự xếp chồng và độ ưu tiên của các quy tắc style. Các quy tắc trong một layer sau sẽ ghi đè các quy tắc trong layer trước, bất kể độ đặc hiệu (specificity) của chúng. Điều này giúp tổ chức và kiểm soát style trong các dự án lớn hoặc hệ thống thiết kế (design systems) tốt hơn, giảm thiểu xung đột.",
        "`@layer` giúp tự động nén các file CSS để giảm kích thước tải xuống.",
        "`@layer` chỉ áp dụng cho các thuộc tính CSS tùy chỉnh (Custom Properties).",
        "`@layer` là một cách để tạo các animation đa lớp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 141,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Grid Areas' và cách chúng giúp tạo ra bố cục phức tạp một cách trực quan hơn.",
      "options": [
        "CSS Grid Areas cho phép bạn đặt tên cho các vùng trong grid bằng thuộc tính `grid-template-areas`. Sau đó, bạn có thể đặt các item vào các vùng này bằng thuộc tính `grid-area`. Điều này giúp tạo ra các bố cục phức tạp một cách trực quan, dễ đọc và dễ thay đổi hơn nhiều so với việc chỉ dùng `grid-row`/`grid-column` cho từng item.",
        "CSS Grid Areas chỉ cho phép tạo các bố cục một chiều.",
        "CSS Grid Areas chỉ hoạt động trên các trình duyệt cũ.",
        "CSS Grid Areas là một cách để mã hóa CSS để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 142,
      "topicId": 2,
      "question": "Khi sử dụng `@keyframes` trong CSS animation, sự khác biệt giữa `linear` và `ease-in-out` trong thuộc tính `animation-timing-function` là gì?",
      "options": [
        "`linear` làm cho animation diễn ra với tốc độ không đổi từ đầu đến cuối. `ease-in-out` làm cho animation bắt đầu và kết thúc chậm, nhưng tăng tốc ở giữa. `ease-in-out` thường tạo ra cảm giác tự nhiên và mượt mà hơn cho animation của UI.",
        "`linear` chỉ hoạt động với các animation đơn giản, còn `ease-in-out` cho các animation phức tạp.",
        "`linear` làm cho animation lặp lại vô hạn, còn `ease-in-out` chỉ chạy một lần.",
        "Không có sự khác biệt đáng kể về hiệu ứng giữa hai giá trị này."
      ],
      "correctAnswer": 0
    },
    {
      "id": 143,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `backdrop-filter` trong CSS và khả năng tạo hiệu ứng 'kính mờ' (frosted glass) độc đáo của nó.",
      "options": [
        "`backdrop-filter` cho phép bạn áp dụng các hiệu ứng đồ họa (như `blur()`, `brightness()`, `grayscale()`) lên khu vực đằng sau (backdrop) của phần tử. Điều này giúp tạo ra hiệu ứng 'kính mờ' hoặc các hiệu ứng tương tự, nơi nội dung phía dưới bị biến đổi nhưng vẫn nhìn thấy được qua phần tử trong suốt.",
        "`backdrop-filter` chỉ áp dụng hiệu ứng cho chính phần tử đó, không phải nội dung phía sau.",
        "`backdrop-filter` tự động tạo một nền màu gradient cho phần tử.",
        "`backdrop-filter` chỉ hoạt động trên các phần tử video."
      ],
      "correctAnswer": 0
    },
    {
      "id": 144,
      "topicId": 2,
      "question": "Tại sao việc sử dụng `rem` hoặc `em` cho `padding` và `margin` thường được ưu tiên hơn `px` trong responsive design?",
      "options": [
        "Sử dụng `rem` hoặc `em` cho `padding` và `margin` giúp các khoảng cách này tự động co giãn theo kích thước font của người dùng hoặc theo cấu trúc responsive của trang. Điều này tạo ra một layout linh hoạt hơn, dễ dàng thích ứng với các kích thước màn hình và sở thích về khả năng truy cập, trong khi `px` là cố định và không thay đổi.",
        "Sử dụng `rem` hoặc `em` làm giảm kích thước file CSS.",
        "Sử dụng `rem` hoặc `em` giúp trình duyệt render trang nhanh hơn.",
        "Sử dụng `rem` hoặc `em` chỉ áp dụng cho các thiết bị di động."
      ],
      "correctAnswer": 0
    },
    {
      "id": 145,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Reset' và 'Normalize.css' và sự khác biệt về triết lý giữa chúng.",
      "options": [
        "CSS Reset loại bỏ tất cả các style mặc định của trình duyệt để tạo ra một nền tảng nhất quán, thường làm cho các phần tử trông 'trần trụi' hơn. Normalize.css giữ lại các style mặc định hữu ích nhưng chuẩn hóa chúng trên các trình duyệt khác nhau, khắc phục sự không nhất quán mà không xóa sạch các style có sẵn. Reset là 'wipe the slate clean', Normalize là 'make consistent'.",
        "CSS Reset và Normalize.css đều là các framework CSS để tạo layout.",
        "CSS Reset chỉ dùng cho các trình duyệt cũ, còn Normalize.css cho trình duyệt hiện đại.",
        "CSS Reset và Normalize.css đều làm tăng kích thước file CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 146,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `mix-blend-mode` trong CSS và các ứng dụng sáng tạo của nó.",
      "options": [
        "`mix-blend-mode` xác định cách một phần tử hòa trộn (blend) với nội dung phía sau nó (background hoặc các phần tử khác). Nó hoạt động tương tự như các chế độ hòa trộn trong phần mềm đồ họa (ví dụ: `multiply`, `screen`, `overlay`), cho phép tạo ra các hiệu ứng hình ảnh phức tạp và sáng tạo như văn bản biến đổi màu sắc dựa trên hình ảnh nền, hoặc các hiệu ứng ánh sáng độc đáo.",
        "`mix-blend-mode` chỉ áp dụng cho việc trộn màu sắc của văn bản.",
        "`mix-blend-mode` tự động tạo các hiệu ứng chuyển động khi hai phần tử chồng lên nhau.",
        "`mix-blend-mode` là một cách để mã hóa màu sắc trong CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 147,
      "topicId": 2,
      "question": "Khi sử dụng CSS Modules hoặc CSS-in-JS, lợi ích chính về mặt `specificity` và `scoping` là gì so với việc viết CSS truyền thống?",
      "options": [
        "CSS Modules/CSS-in-JS giúp tự động tạo ra các tên class duy nhất (scoped CSS) và cách ly style cho từng component, giải quyết vấn đề xung đột `specificity` và rò rỉ style toàn cục. Mỗi style được gắn với một component cụ thể, giảm thiểu khả năng các style khác ảnh hưởng đến nó, giúp quản lý CSS dễ dàng hơn trong các ứng dụng lớn.",
        "CSS Modules/CSS-in-JS chỉ cho phép viết CSS bằng JavaScript.",
        "CSS Modules/CSS-in-JS làm tăng kích thước file CSS đáng kể.",
        "CSS Modules/CSS-in-JS không có bất kỳ lợi ích nào so với CSS truyền thống."
      ],
      "correctAnswer": 0
    },
    {
      "id": 148,
      "topicId": 2,
      "question": "Giải thích vai trò của `prefers-reduced-motion` media feature và cách nó giúp cải thiện khả năng truy cập cho người dùng nhạy cảm với chuyển động.",
      "options": [
        "`prefers-reduced-motion` cho phép bạn cung cấp các style khác nhau dựa trên sở thích của người dùng về chuyển động giảm thiểu (ví dụ: không có parallax, animation ngắn hơn) được thiết lập trong hệ điều hành của họ. Điều này giúp cải thiện khả năng truy cập và trải nghiệm người dùng cho những người có hội chứng tiền đình, động kinh hoặc nhạy cảm với các hiệu ứng chuyển động mạnh.",
        "`prefers-reduced-motion` tự động giảm tốc độ animation trên trang web.",
        "`prefers-reduced-motion` chỉ áp dụng cho các animation 3D.",
        "`prefers-reduced-motion` là một công cụ để phát hiện lỗi trong animation CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 149,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `writing-mode` trong CSS và cách nó hỗ trợ thiết kế cho các ngôn ngữ viết dọc hoặc từ phải sang trái.",
      "options": [
        "`writing-mode` xác định hướng viết của văn bản và các thành phần khác trên trang (ngang từ trái sang phải, ngang từ phải sang trái, hoặc dọc). Nó là một thuộc tính quan trọng để hỗ trợ quốc tế hóa, cho phép các bố cục web dễ dàng thích ứng với các ngôn ngữ như tiếng Nhật (viết dọc), tiếng Ả Rập/Do Thái (viết từ phải sang trái), đảm bảo nội dung được hiển thị chính xác.",
        "`writing-mode` chỉ định font chữ sẽ được sử dụng cho văn bản.",
        "`writing-mode` tự động dịch văn bản sang ngôn ngữ khác.",
        "`writing-mode` chỉ áp dụng cho các phần tử inline."
      ],
      "correctAnswer": 0
    },
    {
      "id": 150,
      "topicId": 2,
      "question": "Trong CSS, thuộc tính `initial-letter` có tác dụng gì và nó giúp cải thiện typography như thế nào?",
      "options": [
        "`initial-letter` cho phép bạn tạo hiệu ứng chữ cái đầu dòng lớn (drop cap) giống như trong sách báo. Nó điều khiển số lượng dòng mà chữ cái đầu tiên của một đoạn văn bản sẽ chiếm, tạo ra hiệu ứng thị giác ấn tượng và cải thiện tính thẩm mỹ của typography.",
        "`initial-letter` chỉ định font chữ ban đầu cho toàn bộ trang.",
        "`initial-letter` tự động viết hoa chữ cái đầu tiên của mỗi từ.",
        "`initial-letter` là một cách để mã hóa văn bản để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 151,
      "topicId": 2,
      "question": "Trong CSS Grid, thuộc tính `grid-auto-flow` có tác dụng gì và khi nào nên sử dụng nó để kiểm soát việc tự động đặt các grid item?",
      "options": [
        "`grid-auto-flow` kiểm soát cách các grid item được đặt tự động vào các ô trống khi chúng không được định vị rõ ràng bằng `grid-column` hoặc `grid-row`. Giá trị `row` (mặc định) sẽ lấp đầy theo hàng, sau đó tạo hàng mới; `column` lấp đầy theo cột, sau đó tạo cột mới; `dense` cố gắng lấp đầy các ô trống sớm hơn trong grid. Nó hữu ích cho các bố cục linh hoạt nơi số lượng item thay đổi.",
        "`grid-auto-flow` tự động căn chỉnh các grid item theo một trục cố định.",
        "`grid-auto-flow` chỉ áp dụng cho các grid item có kích thước cố định.",
        "`grid-auto-flow` là một thuộc tính để định nghĩa các khoảng cách giữa các grid item."
      ],
      "correctAnswer": 0
    },
    {
      "id": 152,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Containment' và các giá trị của thuộc tính `contain` để tối ưu hóa hiệu suất rendering.",
      "options": [
        "CSS Containment là một kỹ thuật hiệu suất cho phép nhà phát triển cô lập một nhánh của DOM từ phần còn lại của cây layout. Thuộc tính `contain` có các giá trị như `layout`, `paint`, `size`, `style`, hoặc `strict`. Khi được áp dụng, nó chỉ thị cho trình duyệt rằng các thay đổi bên trong container sẽ không ảnh hưởng đến bên ngoài, cho phép trình duyệt tối ưu hóa việc tính toán lại (recalculations) và render chỉ trong phạm vi container đó, cải thiện tốc độ và mượt mà.",
        "`contain` làm cho phần tử không thể được chọn bằng JavaScript.",
        "`contain` chỉ cho phép phần tử hiển thị trên một số trình duyệt nhất định.",
        "`contain` tự động thêm một cuộn ngang cho nội dung quá dài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 153,
      "topicId": 2,
      "question": "Sự khác biệt giữa `transition` và `animation` trong CSS là gì và khi nào nên ưu tiên sử dụng từng loại?",
      "options": [
        "`transition` là một hiệu ứng chuyển tiếp giữa hai trạng thái CSS khác nhau, được kích hoạt bởi sự kiện (ví dụ: `hover`, thay đổi class bằng JS), chỉ chạy một lần hoặc khi trạng thái thay đổi. `animation` được định nghĩa bằng `@keyframes`, cho phép kiểm soát nhiều điểm giữa các trạng thái và có thể chạy lặp lại vô hạn, hoặc tự động kích hoạt khi tải trang. `transition` đơn giản cho hiệu ứng 2 trạng thái, `animation` phức tạp hơn cho nhiều trạng thái và điều khiển thời gian.",
        "`transition` chỉ hoạt động với các thuộc tính màu sắc, còn `animation` với tất cả các thuộc tính.",
        "`transition` luôn mượt mà hơn `animation`.",
        "Cả hai đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 154,
      "topicId": 2,
      "question": "Mô tả vai trò của `clip-path` trong CSS và các trường hợp sử dụng sáng tạo của nó ngoài việc tạo hình dạng cơ bản.",
      "options": [
        "`clip-path` cho phép bạn tạo ra một vùng cắt (clipping region) cho một phần tử, chỉ hiển thị phần nội dung bên trong vùng đó và ẩn phần còn lại. Ngoài các hình dạng cơ bản, nó có thể được sử dụng để tạo hiệu ứng tiết lộ (reveal effects), mask ảnh động, hiệu ứng chuyển cảnh độc đáo, hoặc tương tác với SVG để tạo các đường cắt phức tạp, mở rộng khả năng thiết kế phi hình hộp.",
        "`clip-path` dùng để tạo hiệu ứng đổ bóng phức tạp cho văn bản.",
        "`clip-path` kiểm soát thứ tự xếp chồng của các phần tử 3D.",
        "`clip-path` là một thuộc tính để tạo hiệu ứng cuộn mượt mà."
      ],
      "correctAnswer": 0
    },
    {
      "id": 155,
      "topicId": 2,
      "question": "Giải thích cách hoạt động của `ch` unit trong CSS và khi nào nó hữu ích cho typography và responsive design.",
      "options": [
        "`ch` unit đại diện cho chiều rộng của ký tự '0' (zero) trong font hiện tại. Nó hữu ích cho typography để thiết lập `max-width` cho các khối văn bản nhằm đảm bảo số lượng ký tự trên mỗi dòng phù hợp (ví dụ: 50-75 ký tự), cải thiện khả năng đọc. Điều này giúp tạo bố cục responsive dựa trên chiều rộng ký tự chứ không phải kích thước viewport.",
        "`ch` unit chỉ hoạt động với font chữ monospace.",
        "`ch` unit là một cách để mã hóa văn bản để tăng cường bảo mật.",
        "`ch` unit tự động thay đổi font chữ dựa trên kích thước màn hình."
      ],
      "correctAnswer": 0
    },
    {
      "id": 156,
      "topicId": 2,
      "question": "Trong CSS, khái niệm 'Vendor Prefixes' (tiền tố nhà cung cấp) là gì và tại sao chúng vẫn còn xuất hiện trong các codebase cũ?",
      "options": [
        "Vendor Prefixes (ví dụ: `-webkit-`, `-moz-`, `-ms-`, `-o-`) là các tiền tố mà các nhà cung cấp trình duyệt sử dụng để thử nghiệm các tính năng CSS mới trước khi chúng được chuẩn hóa. Chúng vẫn còn trong codebase cũ vì các dự án đó được phát triển khi các tính năng này chưa ổn định hoặc cần hỗ trợ trình duyệt cũ. Hiện nay, hầu hết các tính năng đã được chuẩn hóa, nên việc sử dụng prefix đã giảm đi nhiều.",
        "Vendor Prefixes là các thuộc tính CSS độc quyền của một trình duyệt nhất định.",
        "Vendor Prefixes giúp tối ưu hóa hiệu suất render CSS.",
        "Vendor Prefixes là một cách để ẩn các thuộc tính CSS khỏi các trình duyệt không hỗ trợ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 157,
      "topicId": 2,
      "question": "Sự khác biệt giữa `opacity: 0` và `visibility: hidden` và `display: none` trong việc ẩn phần tử HTML trong CSS là gì về mặt layout, tương tác và khả năng truy cập?",
      "options": [
        "`opacity: 0` làm cho phần tử trong suốt nhưng vẫn chiếm không gian và có thể tương tác (click). `visibility: hidden` ẩn phần tử nhưng vẫn chiếm không gian và không thể tương tác. `display: none` loại bỏ hoàn toàn phần tử khỏi luồng tài liệu, không chiếm không gian và không thể tương tác. `display: none` và `visibility: hidden` đều ẩn khỏi cây accessibility, còn `opacity: 0` thì không.",
        "`opacity: 0` ảnh hưởng đến SEO, còn các thuộc tính kia thì không.",
        "`visibility: hidden` chỉ hoạt động với các phần tử inline.",
        "Cả ba thuộc tính đều có chức năng giống nhau và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 158,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `background-blend-mode` trong CSS và các trường hợp sử dụng sáng tạo của nó.",
      "options": [
        "`background-blend-mode` xác định cách các lớp hình nền (background layers) của một phần tử hòa trộn với nhau hoặc với màu nền của phần tử đó. Tương tự như `mix-blend-mode` nhưng chỉ áp dụng cho background. Nó cho phép tạo ra các hiệu ứng hình ảnh độc đáo, phức tạp với nhiều hình nền chồng lên nhau, ví dụ: hiệu ứng màu sắc cho ảnh đen trắng hoặc kết hợp nhiều texture.",
        "`background-blend-mode` chỉ áp dụng cho việc trộn màu sắc của văn bản.",
        "`background-blend-mode` tự động tạo các hiệu ứng chuyển động khi hình nền thay đổi.",
        "`background-blend-mode` là một cách để mã hóa hình nền để tăng cường bảo mật."
      ]
      , "correctAnswer": 0
    },
    {
      "id": 159,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Filters' và cách chúng được sử dụng để tạo hiệu ứng hình ảnh mà không cần chỉnh sửa đồ họa bên ngoài.",
      "options": [
        "CSS Filters là một tập hợp các hàm (ví dụ: `grayscale()`, `sepia()`, `blur()`, `drop-shadow()`, `contrast()`) cho phép áp dụng các hiệu ứng đồ họa trực tiếp lên phần tử HTML, bao gồm hình ảnh, video và văn bản. Điều này giúp tạo hiệu ứng hình ảnh động và tương tác một cách hiệu quả, không phá hủy, và được tăng tốc bằng GPU mà không cần các công cụ chỉnh sửa ảnh chuyên dụng.",
        "CSS Filters chỉ có thể áp dụng cho các phần tử SVG.",
        "CSS Filters là một cách để nén hình ảnh để tăng tốc độ tải.",
        "CSS Filters tự động chuyển đổi định dạng hình ảnh sang WebP."
      ],
      "correctAnswer": 0
    },
    {
      "id": 160,
      "topicId": 2,
      "question": "Trong CSS, tại sao việc sử dụng `border-radius` với giá trị phần trăm (%) có thể tạo ra hình elip hoặc hình tròn, và cơ chế tính toán của nó?",
      "options": [
        "Khi `border-radius` được đặt bằng phần trăm, nó sẽ tính toán bán kính góc dựa trên kích thước của hộp phần tử. Với một giá trị phần trăm duy nhất, nó sẽ tạo ra hình elip nếu `width` và `height` của phần tử khác nhau, và hình tròn hoàn hảo nếu `width` và `height` bằng nhau (ví dụ: `border-radius: 50%` trên một hình vuông sẽ tạo ra hình tròn).",
        "`border-radius` với phần trăm chỉ hoạt động với các phần tử hình ảnh.",
        "`border-radius` với phần trăm tạo ra các hiệu ứng 3D trên góc của phần tử.",
        "`border-radius` với phần trăm chỉ hoạt động trên các trình duyệt cũ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 161,
      "topicId": 2,
      "question": "Mô tả vai trò của `clip-path` trong CSS và các trường hợp sử dụng sáng tạo của nó ngoài việc tạo hình dạng cơ bản.",
      "options": [
        "`clip-path` cho phép bạn tạo ra một vùng cắt (clipping region) cho một phần tử, chỉ hiển thị phần nội dung bên trong vùng đó và ẩn phần còn lại. Ngoài các hình dạng cơ bản, nó có thể được sử dụng để tạo hiệu ứng tiết lộ (reveal effects), mask ảnh động, hiệu ứng chuyển cảnh độc đáo, hoặc tương tác với SVG để tạo các đường cắt phức tạp, mở rộng khả năng thiết kế phi hình hộp.",
        "`clip-path` dùng để tạo hiệu ứng đổ bóng phức tạp cho văn bản.",
        "`clip-path` kiểm soát thứ tự xếp chồng của các phần tử 3D.",
        "`clip-path` là một thuộc tính để tạo hiệu ứng cuộn mượt mà."
      ],
      "correctAnswer": 0
    },
    {
      "id": 162,
      "topicId": 2,
      "question": "Trong CSS, thuộc tính `object-fit` và `object-position` được sử dụng như thế nào để xử lý hình ảnh và video trong responsive design?",
      "options": [
        "`object-fit` xác định cách nội dung của một phần tử thay thế (như `<img>` hoặc `<video>`) nên được thay đổi kích thước để vừa với khung chứa của nó, với các giá trị như `cover`, `contain`, `fill`. `object-position` sau đó định vị nội dung trong khung đó. Cả hai đều rất quan trọng để đảm bảo hình ảnh/video hiển thị đúng cách mà không bị méo hoặc cắt xén một cách không mong muốn trong các container có kích thước linh hoạt, cải thiện UX.",
        "`object-fit` và `object-position` chỉ áp dụng cho việc tạo ảnh động.",
        "`object-fit` và `object-position` là thuộc tính mới chỉ hỗ trợ trên trình duyệt di động.",
        "`object-fit` và `object-position` giúp tự động tạo các hiệu ứng phản chiếu cho hình ảnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 163,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Custom Properties' (biến CSS) và lợi ích của chúng so với các biến từ preprocessor (như Sass/Less) trong việc tạo các hệ thống thiết kế.",
      "options": [
        "CSS Custom Properties (ví dụ: `--primary-color: blue;`) là các biến được định nghĩa trực tiếp trong CSS, có thể được truy cập bằng hàm `var()`, và có tính kế thừa theo Cascading. Lợi ích: có thể thay đổi động bằng JavaScript, hoạt động ngay trong trình duyệt, và là xương sống cho việc tạo các hệ thống thiết kế linh hoạt, nơi các giá trị (màu sắc, font size) có thể được cập nhật dễ dàng trên toàn bộ trang hoặc cục bộ. Khác với biến preprocessor chỉ là thay thế tĩnh khi biên dịch.",
        "CSS Custom Properties chỉ có thể lưu trữ giá trị số, không thể lưu trữ chuỗi.",
        "CSS Custom Properties chỉ hoạt động trong môi trường phát triển, không hoạt động trên production.",
        "CSS Custom Properties có thể được sử dụng để điều khiển các API của trình duyệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 164,
      "topicId": 2,
      "question": "Sự khác biệt giữa `vw`/`vh` và `%` khi định nghĩa kích thước trong CSS là gì và khi nào nên ưu tiên `vw`/`vh`?",
      "options": [
        "`vw` (viewport width) và `vh` (viewport height) là các đơn vị tương đối so với kích thước của viewport trình duyệt (1vw = 1% chiều rộng viewport). `%` là đơn vị tương đối so với kích thước của phần tử cha trực tiếp. Nên ưu tiên `vw`/`vh` khi bạn muốn phần tử thay đổi kích thước trực tiếp theo kích thước màn hình tổng thể, không bị ảnh hưởng bởi padding/margin của cha, hữu ích cho các thành phần full-screen hoặc typography linh hoạt.",
        "`vw`/`vh` chỉ hoạt động trên thiết bị di động, còn `%` hoạt động trên desktop.",
        "`vw`/`vh` cho hiệu suất tốt hơn khi render, còn `%` thì không.",
        "Không có sự khác biệt đáng kể giữa hai loại đơn vị này; chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 165,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Scroll Snap' và các thuộc tính liên quan (`scroll-snap-type`, `scroll-snap-align`, `scroll-padding`) để tạo trải nghiệm cuộn được kiểm soát.",
      "options": [
        "CSS Scroll Snap cho phép bạn xác định các điểm dừng mà trình duyệt sẽ 'bắt dính' khi người dùng cuộn qua một khu vực (ví dụ: carousel, section). `scroll-snap-type` đặt hành vi (bắt buộc/gần), `scroll-snap-align` định vị item trong viewport, và `scroll-padding` điều chỉnh khoảng cách chụp dính từ các cạnh. Nó giúp tạo trải nghiệm cuộn mượt mà, định vị chính xác và được kiểm soát, cải thiện UX cho các danh sách hoặc slideshow.",
        "CSS Scroll Snap tự động cuộn trang web đến một vị trí cụ thể khi tải.",
        "CSS Scroll Snap chỉ áp dụng cho các phần tử hình ảnh.",
        "CSS Scroll Snap là một cách để mã hóa nội dung để ngăn chặn việc sao chép."
      ],
      "correctAnswer": 0
    },
    {
      "id": 166,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `backdrop-filter` trong CSS và khả năng tạo hiệu ứng 'kính mờ' (frosted glass) độc đáo của nó.",
      "options": [
        "`backdrop-filter` cho phép bạn áp dụng các hiệu ứng đồ họa (như `blur()`, `brightness()`, `grayscale()`) lên khu vực đằng sau (backdrop) của phần tử. Điều này giúp tạo ra hiệu ứng 'kính mờ' hoặc các hiệu ứng tương tự, nơi nội dung phía dưới bị biến đổi nhưng vẫn nhìn thấy được qua phần tử trong suốt mà không làm thay đổi chính phần tử đó, mang lại hiệu ứng thị giác hiện đại.",
        "`backdrop-filter` chỉ áp dụng hiệu ứng cho chính phần tử đó, không phải nội dung phía sau.",
        "`backdrop-filter` tự động tạo một nền màu gradient cho phần tử.",
        "`backdrop-filter` chỉ hoạt động trên các phần tử video."
      ],
      "correctAnswer": 0
    },
    {
      "id": 167,
      "topicId": 2,
      "question": "Trong CSS, tại sao việc sử dụng `transform` cho animation thường tốt hơn việc thay đổi `left`/`top` hoặc `width`/`height`?",
      "options": [
        "Các thuộc tính `transform` (như `translate`, `scale`, `rotate`) thường được GPU tăng tốc (hardware accelerated) vì chúng không gây ra reflow (thay đổi vị trí các phần tử khác trong luồng layout) hoặc repaint (vẽ lại toàn bộ phần tử). Ngược lại, thay đổi `left`/`top` hoặc `width`/`height` thường kích hoạt reflow và repaint, gây tốn tài nguyên và có thể dẫn đến animation giật lag, đặc biệt là trên các thiết bị yếu hơn.",
        "`transform` chỉ hoạt động với animation 3D.",
        "`transform` làm tăng kích thước file CSS đáng kể.",
        "`transform` chỉ hoạt động trên các trình duyệt cũ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 168,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS BFC' (Block Formatting Context) và cách nó ảnh hưởng đến bố cục phần tử.",
      "options": [
        "Block Formatting Context (BFC) là một môi trường render trong CSS, nơi các phần tử block được bố trí theo một bộ quy tắc nhất định. Trong một BFC, mọi thứ được tính toán theo một cách độc lập với các phần tử bên ngoài. Việc tạo BFC (ví dụ bằng `overflow: auto`, `display: flow-root`) có thể giải quyết các vấn đề như collapsing margins, chứa float, hoặc ngăn các phần tử nội bộ tràn ra ngoài, giúp kiểm soát bố cục tốt hơn.",
        "BFC là một cách để tạo các biến CSS toàn cục.",
        "BFC chỉ áp dụng cho các phần tử inline.",
        "BFC giúp tối ưu hóa hiệu suất tải CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 169,
      "topicId": 2,
      "question": "Sự khác biệt giữa `grid-template-areas` và việc sử dụng `grid-row`/`grid-column` trực tiếp để định vị grid item là gì?",
      "options": [
        "`grid-template-areas` cho phép bạn định nghĩa một bố cục grid trực quan bằng cách đặt tên cho các vùng trong grid và sau đó gán các item vào các vùng đó bằng `grid-area`. Điều này làm cho cấu trúc layout dễ đọc và dễ hình dung hơn, đặc biệt cho bố cục phức tạp. `grid-row`/`grid-column` trực tiếp định vị item bằng số dòng/cột, ít trực quan hơn nhưng kiểm soát chính xác hơn từng ô.",
        "`grid-template-areas` chỉ hoạt động với các bố cục một chiều.",
        "`grid-template-areas` làm tăng kích thước file CSS đáng kể.",
        "`grid-template-areas` là một thuộc tính cũ không còn được khuyến khích sử dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 170,
      "topicId": 2,
      "question": "Mô tả vai trò của `@supports` (CSS Feature Queries) trong CSS và cách nó cho phép 'Progressive Enhancement' trong thiết kế web.",
      "options": [
        "`@supports` cho phép bạn kiểm tra xem trình duyệt hiện tại có hỗ trợ một thuộc tính hoặc giá trị CSS cụ thể hay không trước khi áp dụng các quy tắc style. Điều này giúp bạn triển khai 'Progressive Enhancement' – xây dựng một phiên bản cơ bản hoạt động trên mọi trình duyệt, sau đó thêm các tính năng CSS tiên tiến cho các trình duyệt hiện đại mà không làm hỏng trải nghiệm trên trình duyệt cũ, đảm bảo tính tương thích và linh hoạt.",
        "`@supports` tự động thêm tiền tố nhà cung cấp cho các thuộc tính CSS mới.",
        "`@supports` giúp tối ưu hóa hiệu suất tải CSS bằng cách tải các quy tắc theo điều kiện.",
        "`@supports` là một cách để mã hóa CSS để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 171,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Custom Properties' (biến CSS) và lợi ích của chúng so với các biến từ preprocessor (như Sass/Less) trong việc tạo các hệ thống thiết kế.",
      "options": [
        "CSS Custom Properties (ví dụ: `--primary-color: blue;`) là các biến được định nghĩa trực tiếp trong CSS, có thể được truy cập bằng hàm `var()`, và có tính kế thừa theo Cascading. Lợi ích: có thể thay đổi động bằng JavaScript, hoạt động ngay trong trình duyệt, và là xương sống cho việc tạo các hệ thống thiết kế linh hoạt, nơi các giá trị (màu sắc, font size) có thể được cập nhật dễ dàng trên toàn bộ trang hoặc cục bộ. Khác với biến preprocessor chỉ là thay thế tĩnh khi biên dịch.",
        "CSS Custom Properties chỉ có thể lưu trữ giá trị số, không thể lưu trữ chuỗi.",
        "CSS Custom Properties chỉ hoạt động trong môi trường phát triển, không hoạt động trên production.",
        "CSS Custom Properties có thể được sử dụng để điều khiển các API của trình duyệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 172,
      "topicId": 2,
      "question": "Trong Flexbox, sự khác biệt giữa `justify-content` và `align-items` là gì và chúng tác động lên các item theo trục nào?",
      "options": [
        "`justify-content` căn chỉnh các item dọc theo **trục chính** (main axis), phân phối không gian trống giữa/xung quanh chúng. `align-items` căn chỉnh các item dọc theo **trục phụ** (cross axis), căn chỉnh chúng trong từng hàng/cột tương ứng. Cả hai đều kiểm soát sự phân bố của các item trong Flex container.",
        "`justify-content` chỉ áp dụng cho các item có kích thước cố định, còn `align-items` cho các item linh hoạt.",
        "`justify-content` chỉ hoạt động với `flex-direction: row`, còn `align-items` với `flex-direction: column`.",
        "Cả hai thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 173,
      "topicId": 2,
      "question": "Thuộc tính `text-wrap: balance` trong CSS có tác dụng gì và nó cải thiện khả năng đọc của văn bản như thế nào?",
      "options": [
        "`text-wrap: balance` (đang trong quá trình chuẩn hóa/thử nghiệm) cố gắng phân bổ văn bản giữa các dòng một cách cân đối hơn, tránh các 'dòng mồ côi' (orphan lines) hoặc các dòng rất ngắn. Điều này giúp tạo ra các khối văn bản có hình dạng gọn gàng và dễ đọc hơn, đặc biệt là cho tiêu đề hoặc các đoạn văn bản ngắn.",
        "`text-wrap: balance` tự động ngắt từ ở cuối dòng để văn bản không tràn ra ngoài.",
        "`text-wrap: balance` chỉ áp dụng cho các font chữ tùy chỉnh.",
        "`text-wrap: balance` mã hóa văn bản để ngăn chặn việc sao chép."
      ],
      "correctAnswer": 0
    },
    {
      "id": 174,
      "topicId": 2,
      "question": "Mô tả vai trò của `subgrid` trong CSS Grid Layout và khi nào nên sử dụng nó để giải quyết các vấn đề căn chỉnh phức tạp.",
      "options": [
        "`subgrid` cho phép một grid con kế thừa các định nghĩa track (hàng và/hoặc cột) từ grid cha của nó. Điều này giúp căn chỉnh các item bên trong grid con với các item hoặc dòng/cột của grid cha, giải quyết vấn đề khi bạn cần các phần tử ở các cấp độ lồng nhau khác nhau vẫn thẳng hàng với nhau, tạo ra bố cục phức tạp và nhất quán hơn.",
        "`subgrid` chỉ hoạt động với các grid item có kích thước cố định.",
        "`subgrid` tự động tạo các khoảng cách giữa các grid item.",
        "`subgrid` là một cách để tối ưu hóa hiệu suất rendering của grid."
      ],
      "correctAnswer": 0
    },
    {
      "id": 175,
      "topicId": 2,
      "question": "Giải thích cách hoạt động của `overscroll-behavior` trong CSS và cách nó giúp kiểm soát hành vi cuộn của trình duyệt (ví dụ: ngăn chặn 'pull-to-refresh').",
      "options": [
        "`overscroll-behavior` kiểm soát hành vi của trình duyệt khi đạt đến giới hạn cuộn của một phần tử (ví dụ: cuộn đến cuối danh sách). Nó có thể ngăn chặn hiệu ứng cuộn mặc định của trình duyệt như 'pull-to-refresh' trên di động hoặc cuộn trang chính khi một popup bên trong cuộn đến cuối, giúp tạo trải nghiệm cuộn tùy chỉnh và tránh xung đột.",
        "`overscroll-behavior` chỉ định hướng cuộn của phần tử (ngang hoặc dọc).",
        "`overscroll-behavior` làm cho việc cuộn trang mượt mà hơn bằng cách thêm hiệu ứng động.",
        "`overscroll-behavior` là một thuộc tính JavaScript để điều khiển cuộn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 176,
      "topicId": 2,
      "question": "Trong CSS, sự khác biệt giữa `min-width` trong media query và `min-content` trong sizing là gì?",
      "options": [
        "`min-width` trong media query là một breakpoint để áp dụng style khi viewport đạt đến một chiều rộng tối thiểu. `min-content` là một giá trị kích thước (`width`/`height`) cho phép phần tử co lại đến kích thước nhỏ nhất có thể mà không làm tràn nội dung của nó. `min-width` là điều kiện, `min-content` là giá trị kích thước nội tại.",
        "`min-width` và `min-content` đều là các đơn vị đo lường kích thước tương tự nhau.",
        "`min-width` chỉ áp dụng cho hình ảnh, còn `min-content` cho văn bản.",
        "Không có sự khác biệt đáng kể giữa hai khái niệm này."
      ],
      "correctAnswer": 0
    },
    {
      "id": 177,
      "topicId": 2,
      "question": "Tại sao việc tối ưu hóa CSS (nén, gộp file, loại bỏ CSS không dùng) lại quan trọng cho hiệu suất tải trang và cách công cụ hỗ trợ điều này?",
      "options": [
        "Tối ưu hóa CSS giúp giảm kích thước file CSS, từ đó giảm thời gian tải xuống và phân tích cú pháp. Điều này trực tiếp cải thiện tốc độ tải trang, **First Contentful Paint (FCP)** và **Largest Contentful Paint (LCP)**. Các công cụ như PostCSS, PurgeCSS, CSSNano, hoặc tính năng tối ưu hóa trong các build tools (Webpack, Rollup) có thể tự động thực hiện việc này.",
        "Tối ưu hóa CSS giúp mã hóa nội dung để tăng cường bảo mật.",
        "Tối ưu hóa CSS chỉ có lợi cho các trang web tĩnh.",
        "Tối ưu hóa CSS làm cho mã CSS dễ đọc hơn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 178,
      "topicId": 2,
      "question": "Mô tả vai trò của `mask-image` trong CSS và các trường hợp sử dụng sáng tạo của nó so với `clip-path`.",
      "options": [
        "`mask-image` cho phép bạn sử dụng một hình ảnh (hoặc gradient) làm mặt nạ để che giấu hoặc tiết lộ các phần của phần tử, dựa trên độ trong suốt (alpha channel) hoặc độ sáng của hình ảnh mặt nạ. Khác với `clip-path` chỉ tạo ra các hình dạng cứng nhắc, `mask-image` cho phép hiệu ứng che giấu phức tạp hơn, mềm mại hơn, và có thể bán trong suốt, mở ra khả năng thiết kế đồ họa phong phú.",
        "`mask-image` chỉ áp dụng cho việc làm mờ hình ảnh.",
        "`mask-image` tự động tạo các hiệu ứng 3D cho hình ảnh.",
        "`mask-image` là một thuộc tính JavaScript để điều khiển hiển thị ảnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 179,
      "topicId": 2,
      "question": "Trong CSS, thuộc tính `flex-grow`, `flex-shrink`, và `flex-basis` hoạt động như thế nào trong Flexbox để kiểm soát kích thước item linh hoạt?",
      "options": [
        "`flex-grow` xác định khả năng của item giãn nở để lấp đầy không gian trống trong container. `flex-shrink` xác định khả năng của item co lại khi không gian không đủ. `flex-basis` là kích thước ban đầu của item trước khi không gian trống được phân bổ. Kết hợp, chúng (`flex` shorthand) cho phép kiểm soát linh hoạt cách các item Flex tự điều chỉnh kích thước theo không gian có sẵn.",
        "`flex-grow` và `flex-shrink` chỉ hoạt động với các giá trị tuyệt đối.",
        "`flex-basis` chỉ áp dụng cho chiều cao của item.",
        "Cả ba thuộc tính đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 180,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Grid Alignment' và các thuộc tính `place-items`, `place-content`, `place-self` để căn chỉnh trong Grid Layout.",
      "options": [
        "CSS Grid Alignment là cách căn chỉnh các grid item bên trong các ô grid hoặc các track. `place-items` là shorthand của `align-items` và `justify-items` (căn chỉnh item bên trong ô). `place-content` là shorthand của `align-content` và `justify-content` (căn chỉnh toàn bộ grid trong container). `place-self` là shorthand của `align-self` và `justify-self` (căn chỉnh một item cụ thể bên trong ô của nó).",
        "Các thuộc tính `place-*` chỉ hoạt động trên trình duyệt cũ.",
        "Các thuộc tính `place-*` làm tăng kích thước file CSS đáng kể.",
        "Các thuộc tính `place-*` chỉ áp dụng cho các phần tử có `position: fixed`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 181,
      "topicId": 2,
      "question": "Mô tả vai trò của `font-display: swap` trong CSS và lợi ích của nó đối với Core Web Vitals (đặc biệt là FCP và LCP).",
      "options": [
        "`font-display: swap` chỉ thị cho trình duyệt sử dụng một font dự phòng (fallback font) để hiển thị văn bản ngay lập tức trong khi font web chính đang tải. Khi font web tải xong, nó sẽ 'hoán đổi' (swap) font. Lợi ích chính là ngăn chặn **Flash of Invisible Text (FOIT)** và cải thiện **First Contentful Paint (FCP)** và **Largest Contentful Paint (LCP)** bằng cách đảm bảo nội dung văn bản hiển thị nhanh chóng cho người dùng, dù ban đầu có thể chưa đúng font hoàn hảo.",
        "`font-display: swap` mã hóa font để ngăn chặn việc sao chép.",
        "`font-display: swap` tự động tải font từ CDN nhanh hơn.",
        "`font-display: swap` chỉ áp dụng cho các font hệ thống, không phải font web tùy chỉnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 182,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Selector Performance' và các loại selector nên tránh hoặc hạn chế sử dụng để tối ưu hóa hiệu suất rendering.",
      "options": [
        "CSS Selector Performance liên quan đến tốc độ trình duyệt khớp các selector với các phần tử trong DOM. Các selector càng phức tạp, đặc biệt là các selector con cháu (`div > p > span`) hoặc các selector thuộc tính chung (`[attribute]`), hoặc các selector Universal (`*`) có thể làm chậm quá trình tính toán style. Nên tránh các selector quá dài, quá cụ thể không cần thiết, hoặc các selector đòi hỏi trình duyệt phải duyệt ngược cây DOM.",
        "CSS Selector Performance chỉ liên quan đến việc viết mã CSS sạch hơn.",
        "CSS Selector Performance là một công cụ để kiểm tra lỗi cú pháp selector.",
        "CSS Selector Performance chỉ ảnh hưởng đến tốc độ tải file CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 183,
      "topicId": 2,
      "question": "Trong CSS, sự khác biệt giữa `auto` và `0` khi dùng với `flex-basis` hoặc `width` trong Flexbox là gì?",
      "options": [
        "Khi `flex-basis: auto`, kích thước của item được xác định bởi `width`/`height` của nó hoặc nội dung của nó, và nó sẽ giãn nở/co lại từ đó. Khi `flex-basis: 0` (hoặc `0%`), item được coi là không có kích thước ban đầu, và không gian trống sẽ được phân bổ hoàn toàn dựa trên `flex-grow`/`flex-shrink`, thường được dùng khi bạn muốn các item chia đều không gian trống.",
        "`auto` làm cho item chiếm toàn bộ không gian còn lại, còn `0` làm cho item không hiển thị.",
        "`auto` chỉ hoạt động với các số nguyên, còn `0` với các số thập phân.",
        "Cả hai đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 184,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `resize` trong CSS và những giá trị phổ biến của nó.",
      "options": [
        "Thuộc tính `resize` cho phép người dùng thay đổi kích thước của phần tử bằng cách kéo viền của nó. Các giá trị phổ biến bao gồm `horizontal` (chỉ thay đổi chiều ngang), `vertical` (chỉ thay đổi chiều dọc), `both` (thay đổi cả hai chiều), và `none` (không cho phép thay đổi). Nó thường được dùng cho các `<textarea>` hoặc các khu vực nội dung có thể điều chỉnh kích thước.",
        "`resize` tự động thay đổi kích thước phần tử để phù hợp với nội dung.",
        "`resize` là một thuộc tính để tạo hiệu ứng phóng to/thu nhỏ khi di chuột.",
        "`resize` chỉ hoạt động trên các phần tử hình ảnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 185,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Isolation' trong các framework hoặc thư viện (ví dụ: Vue Scoped CSS, Styled Components) và cách chúng giải quyết vấn đề rò rỉ style.",
      "options": [
        "CSS Isolation là phương pháp đảm bảo rằng style của một component chỉ ảnh hưởng đến chính component đó và không bị rò rỉ ra ngoài hoặc bị ảnh hưởng bởi style bên ngoài. Các kỹ thuật như tạo tên class độc đáo (CSS Modules), sử dụng Shadow DOM (Web Components), hoặc tự động tạo CSSscoped (Vue, Svelte) giúp đạt được điều này, ngăn chặn xung đột CSS và làm cho các component độc lập và tái sử dụng được.",
        "CSS Isolation là một cách để mã hóa CSS để tăng cường bảo mật.",
        "CSS Isolation chỉ áp dụng cho các trang web tĩnh.",
        "CSS Isolation làm tăng kích thước file CSS đáng kể."
      ],
      "correctAnswer": 0
    },
    {
      "id": 186,
      "topicId": 2,
      "question": "Trong CSS Grid, sự khác biệt giữa `grid` (shorthand) và các thuộc tính riêng lẻ như `grid-template-columns`, `grid-template-rows` là gì?",
      "options": [
        "`grid` là một thuộc tính shorthand cho phép bạn định nghĩa nhiều thuộc tính Grid cùng một lúc, bao gồm `grid-template-rows`, `grid-template-columns`, `grid-template-areas`, `grid-auto-rows`, `grid-auto-columns`, và `grid-auto-flow`. Nó cung cấp cách viết ngắn gọn và tiện lợi để khai báo toàn bộ bố cục grid. Các thuộc tính riêng lẻ cung cấp khả năng kiểm soát từng khía cạnh cụ thể.",
        "`grid` chỉ áp dụng cho các bố cục đơn giản, còn các thuộc tính riêng lẻ cho bố cục phức tạp.",
        "`grid` làm tăng hiệu suất rendering, còn các thuộc tính riêng lẻ thì không.",
        "`grid` chỉ hoạt động với các giá trị tuyệt đối."
      ],
      "correctAnswer": 0
    },
    {
      "id": 187,
      "topicId": 2,
      "question": "Mô tả vai trò của `mix-blend-mode` trong CSS và các ứng dụng sáng tạo của nó ngoài việc chỉ đơn thuần trộn màu sắc.",
      "options": [
        "`mix-blend-mode` xác định cách một phần tử hòa trộn (blend) với nội dung phía sau nó (background hoặc các phần tử khác) giống như các chế độ hòa trộn trong phần mềm đồ họa (ví dụ: Photoshop). Nó cho phép tạo ra các hiệu ứng hình ảnh phức tạp và sáng tạo như văn bản thay đổi màu sắc khi cuộn qua ảnh, hiệu ứng ánh sáng động, hoặc các lớp phủ tương tác, vượt xa việc chỉ trộn màu cơ bản.",
        "`mix-blend-mode` chỉ áp dụng cho việc làm mờ hình ảnh.",
        "`mix-blend-mode` tự động tạo các hiệu ứng 3D cho phần tử.",
        "`mix-blend-mode` là một cách để mã hóa màu sắc trong CSS."
      ],
      "correctAnswer": 0
    },
    {
      "id": 188,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Containment' và các giá trị của thuộc tính `contain` để tối ưu hóa hiệu suất rendering.",
      "options": [
        "CSS Containment là một kỹ thuật hiệu suất cho phép nhà phát triển cô lập một nhánh của DOM từ phần còn lại của cây layout. Thuộc tính `contain` có các giá trị như `layout`, `paint`, `size`, `style`, hoặc `strict`. Khi được áp dụng, nó chỉ thị cho trình duyệt rằng các thay đổi bên trong container sẽ không ảnh hưởng đến bên ngoài, cho phép trình duyệt tối ưu hóa việc tính toán lại (recalculations) và render chỉ trong phạm vi container đó, cải thiện tốc độ và mượt mà.",
        "`contain` làm cho phần tử không thể được chọn bằng JavaScript.",
        "`contain` chỉ cho phép phần tử hiển thị trên một số trình duyệt nhất định.",
        "`contain` tự động thêm một cuộn ngang cho nội dung quá dài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 189,
      "topicId": 2,
      "question": "Sự khác biệt giữa `text-decoration-thickness` và `text-underline-offset` trong CSS Typography?",
      "options": [
        "`text-decoration-thickness` điều khiển độ dày của đường kẻ trang trí văn bản (ví dụ: gạch chân, gạch ngang). `text-underline-offset` điều khiển khoảng cách giữa đường gạch chân và đường cơ sở của văn bản. Cả hai đều cung cấp kiểm soát chi tiết hơn đối với các hiệu ứng trang trí văn bản, cải thiện tính thẩm mỹ và khả năng đọc.",
        "Cả hai đều là thuộc tính cũ không còn được sử dụng.",
        "Một thuộc tính dùng cho gạch chân, một thuộc tính dùng cho gạch ngang.",
        "Một thuộc tính dùng cho màu sắc, một thuộc tính dùng cho kiểu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 190,
      "topicId": 2,
      "question": "Mô tả vai trò của `writing-mode` trong CSS và cách nó hỗ trợ thiết kế cho các ngôn ngữ viết dọc hoặc từ phải sang trái.",
      "options": [
        "`writing-mode` xác định hướng viết của văn bản và các thành phần khác trên trang (ngang từ trái sang phải, ngang từ phải sang trái, hoặc dọc từ trên xuống dưới/dưới lên trên). Nó là một thuộc tính quan trọng để hỗ trợ quốc tế hóa, cho phép các bố cục web dễ dàng thích ứng với các ngôn ngữ như tiếng Nhật (viết dọc), tiếng Ả Rập/Do Thái (viết từ phải sang trái), đảm bảo nội dung được hiển thị chính xác.",
        "`writing-mode` chỉ định font chữ sẽ được sử dụng cho văn bản.",
        "`writing-mode` tự động dịch văn bản sang ngôn ngữ khác.",
        "`writing-mode` chỉ áp dụng cho các phần tử inline."
      ],
      "correctAnswer": 0
    },
    {
      "id": 191,
      "topicId": 2,
      "question": "Trong CSS, thuộc tính `gap` (hoặc `column-gap`, `row-gap`) được sử dụng để làm gì và lợi ích của nó so với việc sử dụng `margin` trong Flexbox/Grid?",
      "options": [
        "`gap` tạo khoảng trống giữa các hàng và cột trong Flexbox hoặc Grid Layout, mà không thêm khoảng trống thừa ở các cạnh của container hoặc giữa các phần tử không liền kề. Lợi ích: đơn giản hóa việc quản lý khoảng cách, tránh các vấn đề 'collapsing margins' hoặc 'extra margins' thường gặp với `margin`, và giữ cho layout gọn gàng, dễ bảo trì hơn.",
        "`gap` chỉ áp dụng cho các phần tử hình ảnh trong grid.",
        "`gap` chỉ định kích thước tối thiểu của các track trong grid.",
        "`gap` tự động thêm một đường viền (border) xung quanh các grid item."
      ],
      "correctAnswer": 0
    },
    {
      "id": 192,
      "topicId": 2,
      "question": "Giải thích khái niệm 'Initial, Inherit, Unset, Revert' trong CSS để kiểm soát giá trị của thuộc tính và khi nào nên sử dụng chúng.",
      "options": [
        "`initial` đặt thuộc tính về giá trị mặc định của nó theo thông số kỹ thuật (spec). `inherit` đặt thuộc tính về giá trị được tính toán của phần tử cha. `unset` sẽ hành xử như `inherit` nếu thuộc tính kế thừa được, và như `initial` nếu không. `revert` sẽ khôi phục thuộc tính về giá trị mặc định của trình duyệt hoặc kiểu của người dùng. Chúng hữu ích cho việc 'reset' hoặc kiểm soát luồng style một cách chính xác hơn so với việc gán giá trị cố định.",
        "Các thuộc tính này chỉ dùng để tạo animation.",
        "Các thuộc tính này chỉ hoạt động với các biến CSS.",
        "Các thuộc tính này giúp mã hóa CSS để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 193,
      "topicId": 2,
      "question": "Mô tả vai trò của `line-clamp` trong CSS (Webkit-specific/chuẩn hóa) và cách nó giúp giới hạn số dòng của văn bản mà không cần JavaScript.",
      "options": [
        "`line-clamp` cho phép bạn giới hạn số lượng dòng văn bản hiển thị trong một khối và thêm dấu ba chấm (...) nếu văn bản bị cắt. Ban đầu là thuộc tính `webkit-line-clamp` của Webkit, nay đã được chuẩn hóa. Nó rất hữu ích cho các thẻ bài viết, mô tả sản phẩm, hoặc các đoạn văn bản dài cần được rút gọn để giữ cho bố cục gọn gàng, mà không cần tính toán bằng JavaScript.",
        "`line-clamp` tự động thêm gạch chân vào văn bản khi người dùng di chuột qua.",
        "`line-clamp` chỉ áp dụng cho các font chữ tùy chỉnh.",
        "`line-clamp` giúp tối ưu hóa hiệu suất hiển thị văn bản."
      ],
      "correctAnswer": 0
    },
    {
      "id": 194,
      "topicId": 2,
      "question": "Trong CSS, tại sao việc sử dụng `z-index` không hoạt động nếu phần tử không có thuộc tính `position` được định nghĩa (ngoài `static`)?",
      "options": [
        "`z-index` chỉ có tác dụng khi phần tử nằm trong một **stacking context** mới. Một stacking context được tạo ra bởi các phần tử có `position` khác `static` (ví dụ: `relative`, `absolute`, `fixed`, `sticky`), hoặc các thuộc tính như `opacity` dưới 1, `transform`, `filter`, v.v. Nếu một phần tử chỉ có `position: static` (mặc định), nó sẽ không tạo ra stacking context riêng và `z-index` sẽ không có tác dụng.",
        "`z-index` chỉ hoạt động với các phần tử có `display: block`.",
        "`z-index` chỉ có tác dụng trong môi trường 3D.",
        "`z-index` chỉ áp dụng cho các phần tử hình ảnh."
      ],
      "correctAnswer": 0
    },
    {
      "id": 195,
      "topicId": 2,
      "question": "Giải thích khái niệm 'CSS Houdini' và những khả năng mà nó mở ra cho các nhà phát triển frontend.",
      "options": [
        "CSS Houdini là một tập hợp các API cấp thấp cho phép nhà phát triển mở rộng CSS bằng JavaScript và tương tác với quy trình render của trình duyệt. Nó bao gồm API cho Custom Properties (`@property`), Worklets (animation, layout, paint), và Typed OM. Houdini cho phép tạo ra các hiệu ứng, bố cục và thuộc tính CSS tùy chỉnh hiệu suất cao, giống như các thuộc tính native, mở ra một kỷ nguyên mới cho khả năng mở rộng CSS.",
        "CSS Houdini là một framework CSS để tạo giao diện người dùng.",
        "CSS Houdini là một công cụ kiểm tra lỗi bảo mật trong CSS.",
        "CSS Houdini là một cách để nén file CSS để tăng tốc độ tải."
      ],
      "correctAnswer": 0
    },
    {
      "id": 196,
      "topicId": 2,
      "question": "Mô tả vai trò của thuộc tính `aspect-ratio` trong CSS và cách nó giúp quản lý responsive images/videos mà không cần padding hack.",
      "options": [
        "Thuộc tính `aspect-ratio` cho phép bạn xác định tỷ lệ khung hình cố định cho một phần tử (ví dụ: `16 / 9`, `1 / 1`). Điều này giúp duy trì tỷ lệ hình dạng của phần tử khi kích thước của nó thay đổi trong responsive layout, đặc biệt hữu ích cho `<img>`, `<video>` hoặc các container không có intrinsic size, ngăn chặn CLS bằng cách giữ chỗ đúng kích thước ngay từ đầu.",
        "Thuộc tính `aspect-ratio` tự động cắt hình ảnh để phù hợp với tỷ lệ khung hình mong muốn.",
        "Thuộc tính `aspect-ratio` chỉ áp dụng cho các phần tử có `position: fixed`.",
        "Thuộc tính `aspect-ratio` là một cách để chuyển đổi hình ảnh sang định dạng WebP."
      ],
      "correctAnswer": 0
    },
    {
      "id": 197,
      "topicId": 2,
      "question": "Trong CSS, làm thế nào để styling các phần tử bên trong Shadow Root từ CSS bên ngoài Light DOM và ngược lại, đặc biệt với `::part()` và `::slotted()`?",
      "options": [
        "Mặc định, Shadow DOM đóng gói CSS. Để styling các phần tử bên trong Shadow Root từ ngoài, component có thể sử dụng thuộc tính `part` trên các phần tử của nó, sau đó CSS bên ngoài dùng `::part(name)`. Để style nội dung được chèn vào Shadow DOM từ Light DOM, Shadow Root CSS sử dụng `::slotted(selector)`. Ngoài ra, CSS Custom Properties cũng là một cầu nối.",
        "Bạn không thể styling Shadow DOM từ Light DOM hoặc ngược lại; chúng hoàn toàn bị cô lập.",
        "Sử dụng `!important` trong CSS để ép buộc style vào Shadow DOM.",
        "Sử dụng JavaScript để thay đổi style trực tiếp cho các phần tử trong Shadow DOM."
      ],
      "correctAnswer": 0
    },
    {
      "id": 198,
      "topicId": 2,
      "question": "Giải thích các khái niệm `fit-content()`, `min-content`, và `max-content` trong CSS sizing và khi nào chúng hữu ích.",
      "options": [
        "`min-content` là kích thước nhỏ nhất mà một phần tử có thể đạt được mà không gây tràn nội dung. `max-content` là kích thước tự nhiên của nội dung mà không có bất kỳ ngắt dòng nào. `fit-content()` tương tự `auto` nhưng có giới hạn tối đa là `max-content` và tối thiểu là `min-content`. Chúng hữu ích để tạo các component tự điều chỉnh kích thước linh hoạt dựa trên nội dung, đặc biệt trong CSS Grid và Flexbox.",
        "Các giá trị này chỉ áp dụng cho các phần tử hình ảnh.",
        "Các giá trị này là thuộc tính JavaScript, không phải CSS.",
        "Các giá trị này chỉ hoạt động với các đơn vị tuyệt đối như `px`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 199,
      "topicId": 2,
      "question": "Mô tả vai trò của `image-set()` trong CSS và cách nó giúp quản lý responsive images trong `background-image` cho các màn hình có mật độ pixel khác nhau.",
      "options": [
        "`image-set()` cho phép bạn cung cấp nhiều phiên bản của một hình ảnh nền (background image) với các độ phân giải khác nhau (ví dụ: 1x, 2x) và/hoặc định dạng khác nhau (ví dụ: WebP, JPEG). Trình duyệt sẽ tự động chọn phiên bản tối ưu nhất dựa trên mật độ pixel của màn hình (device-pixel-ratio) và khả năng hỗ trợ định dạng, tối ưu hóa việc tải ảnh nền cho các thiết bị Retina hoặc có độ phân giải cao.",
        "`image-set()` tự động tạo các hiệu ứng parallax cho hình ảnh nền.",
        "`image-set()` chỉ áp dụng cho các hình ảnh vector, không phải hình ảnh raster.",
        "`image-set()` là một cách để mã hóa hình ảnh để bảo vệ chúng khỏi việc sao chép."
      ],
      "correctAnswer": 0
    },
    {
      "id": 200,
      "topicId": 2,
      "question": "Trong CSS, thuộc tính `will-change` có tác dụng gì và khi nào nên sử dụng nó một cách thận trọng để tối ưu hóa hiệu suất animation?",
      "options": [
        "`will-change` là một thuộc tính gợi ý cho trình duyệt biết rằng một phần tử sẽ thay đổi một hoặc nhiều thuộc tính CSS trong tương lai gần (ví dụ: `transform`, `opacity`). Điều này cho phép trình duyệt tối ưu hóa trước (ví dụ: tạo layer GPU riêng), giúp animation/transition mượt mà hơn. Nên sử dụng thận trọng và chỉ khi cần thiết vì việc lạm dụng có thể gây tốn bộ nhớ hoặc tài nguyên CPU, đôi khi phản tác dụng.",
        "`will-change` buộc trình duyệt phải tải lại toàn bộ trang khi có bất kỳ thay đổi CSS nào.",
        "`will-change` tự động tạo các hiệu ứng chuyển động cho phần tử mà không cần viết keyframes.",
        "`will-change` ngăn chặn các thuộc tính CSS khác ảnh hưởng đến phần tử."
      ],
      "correctAnswer": 0
    },
    {
      "id": 201,
      "topicId": 3,
      "question": "Giải thích khái niệm **Closure** trong JavaScript và đưa ra một ví dụ về cách nó được sử dụng để duy trì quyền truy cập vào biến bên ngoài hàm đã thực thi xong.",
      "options": [
        "Closure là một hàm bên trong có khả năng 'nhớ' và truy cập các biến từ phạm vi (scope) bên ngoài của nó, ngay cả khi hàm bên ngoài đã thực thi xong. Ví dụ: `function makeCounter() { let count = 0; return function() { return count++; }; } const counter = makeCounter();` Ở đây, hàm ẩn danh vẫn truy cập được `count`.",
        "Closure là một loại lỗi trong JavaScript xảy ra khi biến không được khai báo đúng cách.",
        "Closure là một phương pháp để tối ưu hóa hiệu suất của vòng lặp trong JavaScript.",
        "Closure là một cú pháp mới trong ES6 để khai báo hằng số."
      ],
      "correctAnswer": 0
    },
    {
      "id": 202,
      "topicId": 3,
      "question": "Sự khác biệt cốt lõi giữa **`let`**, **`const`** và **`var`** trong JavaScript về phạm vi (scope) và khả năng gán lại giá trị?",
      "options": [
        "`var` có phạm vi hàm (function-scoped) và có thể được khai báo lại, gán lại giá trị. `let` có phạm vi khối (block-scoped) và có thể gán lại giá trị nhưng không thể khai báo lại. `const` có phạm vi khối, không thể khai báo lại và không thể gán lại giá trị sau khi khởi tạo (mặc dù các thuộc tính của đối tượng `const` có thể thay đổi).",
        "`let` và `const` là tương đương nhau, chỉ khác về cú pháp.",
        "`var` an toàn hơn `let` và `const` trong môi trường đa luồng.",
        "Không có sự khác biệt đáng kể giữa ba từ khóa này trong JavaScript hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 203,
      "topicId": 3,
      "question": "Mô tả cơ chế hoạt động của **Event Loop** trong JavaScript và vai trò của nó trong việc xử lý các tác vụ bất đồng bộ (asynchronous tasks) như `setTimeout`, `fetch`, `Promise`.",
      "options": [
        "Event Loop là một cơ chế của JavaScript runtime (không phải JS engine) giúp xử lý các tác vụ bất đồng bộ bằng cách liên tục kiểm tra Call Stack và Callback Queue (hay Task Queue / Microtask Queue). Khi Call Stack trống, Event Loop sẽ đẩy các hàm callback từ hàng đợi vào Call Stack để thực thi, đảm bảo JavaScript là đơn luồng nhưng vẫn có thể xử lý bất đồng bộ.",
        "Event Loop là một vòng lặp vô hạn chạy trong trình duyệt để tạo ra các hiệu ứng động.",
        "Event Loop là một cách để JavaScript thực hiện đa luồng (multi-threading).",
        "Event Loop giúp JavaScript nén mã nguồn để tăng tốc độ tải."
      ],
      "correctAnswer": 0
    },
    {
      "id": 204,
      "topicId": 3,
      "question": "Giải thích sự khác biệt giữa **Microtasks** (ví dụ: `Promise.then()`, `async/await`) và **Macrotasks** (ví dụ: `setTimeout`, `setInterval`, I/O) trong Event Loop và thứ tự ưu tiên thực thi của chúng.",
      "options": [
        "Microtasks có độ ưu tiên cao hơn Macrotasks. Event Loop sẽ thực thi tất cả các Microtasks trong Microtask Queue cho đến khi trống trước khi xử lý một Macrotask duy nhất từ Macrotask Queue (Callback Queue). Điều này có nghĩa là các callback của Promise sẽ được thực thi nhanh hơn và trước các callback của `setTimeout`.",
        "Macrotasks luôn được ưu tiên hơn Microtasks.",
        "Cả hai đều có cùng độ ưu tiên và được thực thi theo thứ tự FIFO (First-In, First-Out).",
        "Microtasks chỉ hoạt động trong Node.js, còn Macrotasks chỉ hoạt động trong trình duyệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 205,
      "topicId": 3,
      "question": "Mô tả cơ chế **Prototype Chain** trong JavaScript và cách nó ảnh hưởng đến việc kế thừa thuộc tính và phương thức trong các đối tượng.",
      "options": [
        "Prototype Chain là một cơ chế kế thừa trong JavaScript, nơi mỗi đối tượng có một thuộc tính nội bộ (`[[Prototype]]` hoặc `__proto__`) trỏ đến một đối tượng khác (prototype của nó). Khi một thuộc tính hoặc phương thức được truy cập trên một đối tượng, nếu không tìm thấy, JavaScript sẽ tìm kiếm nó lên chuỗi prototype cho đến khi tìm thấy hoặc đến cuối chuỗi (null).",
        "Prototype Chain là một cách để tối ưu hóa hiệu suất của các vòng lặp for.",
        "Prototype Chain là một cú pháp mới trong ES6 để khai báo lớp (class).",
        "Prototype Chain giúp JavaScript quản lý bộ nhớ hiệu quả hơn."
      ],
      "correctAnswer": 0
    },
    {
      "id": 206,
      "topicId": 3,
      "question": "Giải thích **Hoisting** trong JavaScript và cách nó ảnh hưởng đến việc khai báo biến và hàm (`var`, `let`, `const`, `function`).",
      "options": [
        "Hoisting là một cơ chế của JavaScript, nơi các khai báo biến và hàm được di chuyển lên đầu phạm vi chứa chúng trong giai đoạn biên dịch (compilation phase), trước khi mã thực sự được thực thi. Với `var` và `function`, chúng được hoisting hoàn toàn. Với `let` và `const`, chúng cũng được hoisting nhưng nằm trong 'Temporal Dead Zone' (TDZ) cho đến khi được khai báo, gây lỗi nếu truy cập sớm.",
        "Hoisting là cách để JavaScript tự động sắp xếp lại các câu lệnh trong code.",
        "Hoisting chỉ xảy ra trong môi trường Node.js, không xảy ra trong trình duyệt.",
        "Hoisting là một loại lỗi cú pháp trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 207,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`call()`**, **`apply()`** và **`bind()`** trong JavaScript về cách chúng thay đổi ngữ cảnh `this` của một hàm?",
      "options": [
        "`call()` và `apply()` gọi hàm ngay lập tức với ngữ cảnh `this` được chỉ định. `call()` nhận các đối số riêng lẻ, còn `apply()` nhận các đối số dưới dạng một mảng. `bind()` trả về một hàm mới với ngữ cảnh `this` được ràng buộc vĩnh viễn, nhưng không thực thi hàm ngay lập tức. `bind()` hữu ích cho việc truyền hàm callback với ngữ cảnh cụ thể.",
        "`call()` và `apply()` chỉ hoạt động với các hàm bất đồng bộ.",
        "`bind()` chỉ dùng để liên kết các sự kiện DOM.",
        "Cả ba phương thức đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 208,
      "topicId": 3,
      "question": "Mô tả cách hoạt động của **`async/await`** trong JavaScript và lợi ích của nó so với việc sử dụng chuỗi `Promise.then().catch()`.",
      "options": [
        "`async/await` là cú pháp 'syntactic sugar' được xây dựng trên Promise, cho phép viết code bất đồng bộ trông giống như đồng bộ và dễ đọc hơn. Một hàm `async` luôn trả về một Promise. Từ khóa `await` chỉ có thể dùng bên trong hàm `async`, nó tạm dừng việc thực thi hàm cho đến khi Promise được giải quyết (resolved) hoặc bị từ chối (rejected), giúp tránh 'callback hell' và quản lý lỗi dễ dàng hơn.",
        "`async/await` là một cách để JavaScript thực hiện đa luồng (multi-threading).",
        "`async/await` chỉ hoạt động với các yêu cầu mạng (fetch API).",
        "`async/await` làm tăng kích thước file JavaScript đáng kể."
      ],
      "correctAnswer": 0
    },
    {
      "id": 209,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích sự khác biệt giữa **Error Handling** bằng `try...catch` và xử lý lỗi trong `Promise.catch()`.",
      "options": [
        "`try...catch` chỉ bắt được các lỗi đồng bộ (synchronous errors) xảy ra trong khối `try`. `Promise.catch()` được dùng để bắt các lỗi bất đồng bộ (asynchronous errors) xảy ra trong Promise. `try...catch` không thể bắt lỗi bên trong callback của `setTimeout` hoặc các Promise không được `await` đúng cách bên ngoài một hàm `async`.",
        "`try...catch` chỉ hoạt động với các lỗi cú pháp, còn `Promise.catch()` với các lỗi runtime.",
        "`Promise.catch()` luôn được ưu tiên hơn `try...catch` trong mọi trường hợp.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 210,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Symbol`** trong ES6 và những trường hợp sử dụng chính của nó để tạo các thuộc tính đối tượng duy nhất.",
      "options": [
        "`Symbol` là một kiểu dữ liệu nguyên thủy mới trong ES6, cho phép tạo ra các giá trị duy nhất và bất biến. Chúng thường được dùng làm khóa thuộc tính cho các đối tượng để tránh xung đột tên (name clashes), đặc biệt khi mở rộng đối tượng từ bên thứ ba hoặc thêm các thuộc tính 'riêng tư' không mong muốn bị liệt kê trong vòng lặp `for...in` hay `Object.keys()`.",
        "`Symbol` là một cách để mã hóa dữ liệu trong JavaScript.",
        "`Symbol` chỉ được dùng để tạo các biểu tượng UI động.",
        "`Symbol` là một hàm để tối ưu hóa hiệu suất của chuỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 211,
      "topicId": 3,
      "question": "Giải thích kỹ thuật **Debouncing** trong JavaScript và khi nào nên sử dụng nó để tối ưu hóa hiệu suất của các sự kiện.",
      "options": [
        "Debouncing là một kỹ thuật tối ưu hóa hiệu suất dùng để hạn chế việc một hàm được gọi quá thường xuyên. Nó trì hoãn việc thực thi hàm cho đến khi một khoảng thời gian nhất định trôi qua kể từ lần cuối cùng sự kiện được kích hoạt. Hữu ích cho các sự kiện như `resize`, `scroll`, `input` trong thanh tìm kiếm, để tránh thực thi logic quá nhiều lần khi người dùng đang thao tác liên tục.",
        "Debouncing là cách để JavaScript tải bất đồng bộ các tài nguyên.",
        "Debouncing là một phương pháp để mã hóa các chuỗi trong JavaScript.",
        "Debouncing chỉ hoạt động trong môi trường Node.js."
      ],
      "correctAnswer": 0
    },
    {
      "id": 212,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`==`** và **`===`** trong JavaScript về so sánh giá trị và kiểu dữ liệu?",
      "options": [
        "`==` (so sánh bằng) thực hiện ép kiểu (type coercion) nếu các toán hạng có kiểu khác nhau trước khi so sánh giá trị. `===` (so sánh bằng nghiêm ngặt) không thực hiện ép kiểu và chỉ trả về `true` nếu cả giá trị và kiểu dữ liệu của các toán hạng đều giống hệt nhau. Luôn ưu tiên dùng `===` để tránh các lỗi không mong muốn do ép kiểu.",
        "`==` so sánh giá trị, còn `===` so sánh địa chỉ bộ nhớ.",
        "`==` chỉ hoạt động với số, còn `===` với chuỗi.",
        "Không có sự khác biệt đáng kể, `==` là phiên bản cũ hơn của `===`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 213,
      "topicId": 3,
      "question": "Mô tả cách hoạt động của **`Proxy`** trong ES6 và các trường hợp sử dụng nâng cao của nó (ví dụ: validation, logging, reactivity).",
      "options": [
        "`Proxy` là một đối tượng cho phép bạn định nghĩa các hành vi tùy chỉnh cho các thao tác cơ bản trên đối tượng (ví dụ: lấy thuộc tính, gán thuộc tính, gọi hàm). Nó được sử dụng để 'đánh chặn' và điều khiển các hoạt động trên một đối tượng mục tiêu. Ứng dụng: validation dữ liệu, logging các truy cập, tạo hệ thống reactivity (như trong Vue 3), hoặc bảo vệ đối tượng.",
        "`Proxy` là một cách để tạo các đối tượng chỉ đọc (immutable objects).",
        "`Proxy` chỉ hoạt động với các lớp (classes) trong JavaScript.",
        "`Proxy` là một công cụ để kiểm tra lỗi cú pháp trong code."
      ],
      "correctAnswer": 0
    },
    {
      "id": 214,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích về **`Generators`** (`function*` và `yield`) và cách chúng khác với các hàm thông thường trong việc xử lý các luồng dữ liệu bất đồng bộ hoặc tạo chuỗi giá trị.",
      "options": [
        "`Generators` là các hàm đặc biệt có thể tạm dừng việc thực thi và tiếp tục lại sau đó, trả về nhiều giá trị theo thời gian. Chúng được định nghĩa bằng `function*` và sử dụng từ khóa `yield` để tạm dừng và trả về một giá trị. Không giống hàm thông thường chỉ trả về một lần, `Generators` có thể tạo ra các chuỗi giá trị theo kiểu 'pull' (người gọi yêu cầu giá trị tiếp theo) và hữu ích cho việc quản lý các luồng bất đồng bộ phức tạp.",
        "`Generators` chỉ dùng để tạo ra các số ngẫu nhiên.",
        "`Generators` là một cách để JavaScript thực hiện đa luồng.",
        "`Generators` làm tăng đáng kể hiệu suất của vòng lặp `for...of`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 215,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Map`** và **`Object`** trong JavaScript về cách lưu trữ dữ liệu và hiệu suất cho các trường hợp sử dụng cụ thể?",
      "options": [
        "`Object` lưu trữ dữ liệu dưới dạng các cặp `key-value` với key là chuỗi hoặc Symbol. `Map` là một tập hợp các cặp `key-value` nơi key có thể là bất kỳ kiểu dữ liệu nào (bao gồm đối tượng, hàm). `Map` duy trì thứ tự chèn, có hiệu suất tốt hơn khi có nhiều thao tác thêm/xóa, và có thuộc tính `size` để lấy số lượng phần tử. `Map` thường ưu tiên hơn khi cần lưu trữ key không phải chuỗi hoặc cần duy trì thứ tự.",
        "`Map` chỉ hoạt động với các số nguyên làm key.",
        "`Object` an toàn hơn `Map` về mặt bảo mật.",
        "`Map` không thể lưu trữ các hàm như giá trị."
      ],
      "correctAnswer": 0
    },
    {
      "id": 216,
      "topicId": 3,
      "question": "Mô tả kỹ thuật **Throttling** trong JavaScript và khi nào nên sử dụng nó để tối ưu hóa hiệu suất của các sự kiện.",
      "options": [
        "Throttling là một kỹ thuật tối ưu hóa hiệu suất để giới hạn việc thực thi một hàm đến một tần suất tối đa nhất định. Nó đảm bảo hàm chỉ được gọi một lần trong mỗi khoảng thời gian đã định, ngay cả khi sự kiện kích hoạt liên tục. Hữu ích cho các sự kiện như `scroll`, `mousemove`, `resize` để đảm bảo hàm không chạy quá nhiều lần nhưng vẫn cung cấp phản hồi liên tục.",
        "Throttling là cách để JavaScript tải bất đồng bộ các tài nguyên.",
        "Throttling là một phương pháp để mã hóa các chuỗi trong JavaScript.",
        "Throttling chỉ hoạt động trong môi trường Node.js."
      ],
      "correctAnswer": 0
    },
    {
      "id": 217,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích **`Rest parameters`** và **`Spread syntax`** trong ES6 và các trường hợp sử dụng chính của chúng.",
      "options": [
        "`Rest parameters` (`...args`) cho phép một hàm chấp nhận một số lượng đối số không xác định dưới dạng một mảng. `Spread syntax` (`...array` hoặc `...object`) dùng để mở rộng (expand) một iterable (ví dụ: mảng, chuỗi) thành các phần tử riêng lẻ, hoặc sao chép thuộc tính của đối tượng. `Rest` dùng trong định nghĩa hàm, `Spread` dùng khi gọi hàm hoặc tạo cấu trúc dữ liệu mới.",
        "`Rest parameters` và `Spread syntax` chỉ hoạt động với các số nguyên.",
        "Cả hai đều là cách để JavaScript tự động xử lý lỗi.",
        "Cả hai đều chỉ dùng để tạo các hàm bất đồng bộ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 218,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WeakMap`** và **`WeakSet`** trong JavaScript và khi nào nên ưu tiên sử dụng chúng so với `Map` và `Set`.",
      "options": [
        "`WeakMap` và `WeakSet` chỉ lưu trữ tham chiếu 'yếu' (weak references) đến các đối tượng (key trong `WeakMap` chỉ có thể là đối tượng). Điều này có nghĩa là nếu không có tham chiếu nào khác đến đối tượng đó, nó có thể bị Garbage Collector xóa khỏi bộ nhớ. Ưu tiên dùng khi bạn muốn liên kết dữ liệu với đối tượng mà không ngăn cản đối tượng đó bị giải phóng bộ nhớ, ví dụ: lưu trữ metadata cho các đối tượng DOM.",
        "`WeakMap` và `WeakSet` có hiệu suất tốt hơn `Map` và `Set` trong mọi trường hợp.",
        "`WeakMap` và `WeakSet` chỉ hoạt động với các kiểu dữ liệu nguyên thủy.",
        "Cả hai đều là cách để JavaScript mã hóa dữ liệu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 219,
      "topicId": 3,
      "question": "Giải thích khái niệm **Immutable Data** trong JavaScript và các lợi ích của việc sử dụng nó trong các ứng dụng web phức tạp.",
      "options": [
        "Immutable Data là dữ liệu không thể thay đổi sau khi được tạo. Thay vì thay đổi trực tiếp dữ liệu, bạn tạo một bản sao mới với các thay đổi. Lợi ích: đơn giản hóa việc quản lý trạng thái, dễ dàng debug hơn (vì trạng thái không thay đổi bất ngờ), giảm lỗi do side-effects, cải thiện hiệu suất trong các thư viện UI (ví dụ: React với `shouldComponentUpdate`), và tăng tính an toàn cho các thao tác đồng thời.",
        "Immutable Data làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Immutable Data chỉ hoạt động với các kiểu dữ liệu nguyên thủy.",
        "Immutable Data là một cách để JavaScript tự động xử lý lỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 220,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`for...in`** và **`for...of`** trong JavaScript và khi nào nên sử dụng từng loại?",
      "options": [
        "`for...in` lặp qua các **tên thuộc tính có thể liệt kê** (enumerable property names) của một đối tượng và chuỗi prototype của nó. `for...of` lặp qua các **giá trị** của các đối tượng iterable (ví dụ: mảng, chuỗi, Map, Set, NodeList). Nên dùng `for...of` để lặp qua mảng hoặc các cấu trúc dữ liệu iterable để lấy giá trị, và tránh dùng `for...in` cho mảng vì nó có thể bao gồm các thuộc tính không phải là chỉ mục.",
        "`for...in` an toàn hơn `for...of` về mặt bảo mật.",
        "`for...of` chỉ hoạt động trong Node.js, còn `for...in` trong trình duyệt.",
        "Cả hai đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 221,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Reflect`** trong ES6 và cách nó cung cấp một cách an toàn và tiện lợi để thực hiện các thao tác trên đối tượng.",
      "options": [
        "`Reflect` là một đối tượng tích hợp sẵn cung cấp các phương thức tĩnh giống như các toán tử JavaScript (ví dụ: `new`, `delete`, `in`, `Function.prototype.apply`). Nó cung cấp một API rõ ràng hơn, hướng đối tượng hơn cho các thao tác trên đối tượng và thường được dùng kết hợp với `Proxy` để đánh chặn các hoạt động này một cách sạch sẽ và đáng tin cậy.",
        "`Reflect` là một cách để mã hóa các chuỗi trong JavaScript.",
        "`Reflect` chỉ dùng để tạo các hiệu ứng phản chiếu trong giao diện người dùng.",
        "`Reflect` là một công cụ để kiểm tra lỗi cú pháp trong code."
      ],
      "correctAnswer": 0
    },
    {
      "id": 222,
      "topicId": 3,
      "question": "Giải thích kỹ thuật **Event Delegation** trong JavaScript và lợi ích của nó trong việc xử lý sự kiện DOM hiệu quả.",
      "options": [
        "Event Delegation là kỹ thuật xử lý sự kiện bằng cách gắn một trình lắng nghe sự kiện (event listener) vào một phần tử cha thay vì gắn vào từng phần tử con riêng lẻ. Khi một sự kiện kích hoạt trên phần tử con, nó sẽ nổi bọt (bubble) lên phần tử cha. Lợi ích: giảm số lượng event listeners, tiết kiệm bộ nhớ, cải thiện hiệu suất (đặc biệt với danh sách động), và dễ dàng xử lý các phần tử được thêm/xóa động khỏi DOM.",
        "Event Delegation chỉ hoạt động với các sự kiện click.",
        "Event Delegation làm tăng đáng kể thời gian tải trang.",
        "Event Delegation là một cách để JavaScript giao tiếp với server."
      ],
      "correctAnswer": 0
    },
    {
      "id": 223,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`undefined`** và **`null`** trong JavaScript?",
      "options": [
        "`undefined` là giá trị mặc định của một biến chưa được gán giá trị, một thuộc tính không tồn tại trên đối tượng, hoặc giá trị trả về của một hàm không có câu lệnh `return` rõ ràng. `null` là một giá trị gán rõ ràng, biểu thị sự 'không có giá trị' hoặc 'không có đối tượng'. `null` là một object trong `typeof` (lỗi lịch sử), `undefined` là `undefined`.",
        "`undefined` là một kiểu dữ liệu, còn `null` là một giá trị.",
        "`undefined` và `null` có chức năng tương tự và có thể dùng thay thế cho nhau.",
        "`null` an toàn hơn `undefined` trong các phép tính toán."
      ],
      "correctAnswer": 0
    },
    {
      "id": 224,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Set`** trong ES6 và các trường hợp sử dụng chính của nó so với `Array` truyền thống.",
      "options": [
        "`Set` là một tập hợp các giá trị **duy nhất** (không có phần tử trùng lặp) và có thể chứa bất kỳ kiểu dữ liệu nào. Khác với `Array` cho phép trùng lặp và truy cập theo chỉ mục. `Set` hữu ích cho việc loại bỏ các giá trị trùng lặp khỏi một mảng, quản lý các tập hợp duy nhất, hoặc kiểm tra sự tồn tại của một giá trị một cách hiệu quả hơn so với tìm kiếm trong mảng lớn.",
        "`Set` chỉ có thể lưu trữ các số nguyên.",
        "`Set` không thể lưu trữ các đối tượng.",
        "`Set` là một loại vòng lặp mới trong ES6."
      ],
      "correctAnswer": 0
    },
    {
      "id": 225,
      "topicId": 3,
      "question": "Giải thích khái niệm **Memoization** trong JavaScript và khi nào nên áp dụng nó để tối ưu hóa hiệu suất hàm đệ quy hoặc hàm tính toán nặng.",
      "options": [
        "Memoization là một kỹ thuật tối ưu hóa dùng để lưu trữ (cache) kết quả của các lời gọi hàm đắt tiền (tốn tài nguyên) và trả về kết quả đã lưu trữ nếu các đối số đầu vào tương tự được truyền lại. Nó hữu ích cho các hàm 'pure functions' (hàm thuần khiết) hoặc hàm đệ quy có các lời gọi lặp lại với cùng đầu vào, giúp tránh tính toán lại không cần thiết và tăng hiệu suất.",
        "Memoization là một cách để mã hóa hàm để bảo vệ nó khỏi việc sao chép.",
        "Memoization chỉ hoạt động với các hàm bất đồng bộ.",
        "Memoization làm tăng đáng kể mức tiêu thụ bộ nhớ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 226,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`forEach`**, **`map`**, **`filter`**, và **`reduce`** trên Array trong JavaScript và khi nào nên sử dụng từng phương thức?",
      "options": [
        "`forEach` lặp qua mảng, thực thi callback cho mỗi phần tử, không trả về giá trị. `map` tạo một mảng mới bằng cách áp dụng callback cho mỗi phần tử. `filter` tạo một mảng mới chứa các phần tử thỏa mãn điều kiện callback. `reduce` áp dụng một hàm tích lũy cho mỗi phần tử để rút gọn mảng thành một giá trị duy nhất. Mỗi phương thức có mục đích khác nhau: lặp, biến đổi, lọc, hoặc tổng hợp.",
        "`map` và `filter` thay đổi mảng gốc, còn `forEach` thì không.",
        "`reduce` chỉ dùng cho các số nguyên, không dùng cho chuỗi.",
        "Cả bốn phương thức đều có thể dùng thay thế cho nhau trong mọi trường hợp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 227,
      "topicId": 3,
      "question": "Mô tả cơ chế hoạt động của **Web Workers** trong JavaScript và lợi ích của chúng trong việc thực hiện các tác vụ nặng mà không làm đóng băng UI.",
      "options": [
        "Web Workers cho phép các script chạy trong một luồng nền (background thread) riêng biệt, độc lập với luồng UI chính của trình duyệt. Điều này giúp thực hiện các tác vụ tính toán phức tạp, xử lý dữ liệu lớn, hoặc các thao tác I/O mà không làm chặn giao diện người dùng, duy trì tính phản hồi và mượt mà của ứng dụng web. Chúng giao tiếp với luồng chính qua hệ thống gửi tin nhắn.",
        "Web Workers là một API cho phép lưu trữ dữ liệu cục bộ trên trình duyệt.",
        "Web Workers là các công cụ để kiểm tra lỗi và debug mã JavaScript trên trình duyệt.",
        "Web Workers là các thư viện JavaScript giúp tối ưu hóa việc tải các tài nguyên đa phương tiện."
      ],
      "correctAnswer": 0
    },
    {
      "id": 228,
      "topicId": 3,
      "question": "Giải thích khái niệm **Event Bubbling** và **Event Capturing** (Event Propagation) trong JavaScript và cách chúng ảnh hưởng đến việc xử lý sự kiện.",
      "options": [
        "Event Propagation là quá trình mà một sự kiện đi qua cây DOM. Giai đoạn **Capturing** là khi sự kiện đi từ phần tử gốc (window/document) xuống phần tử đích. Giai đoạn **Bubbling** là khi sự kiện nổi bọt từ phần tử đích trở lại lên phần tử gốc. `addEventListener()` có thể lắng nghe ở cả hai giai đoạn, nhưng mặc định là `bubbling`.",
        "Event Bubbling và Capturing chỉ áp dụng cho các sự kiện click, không áp dụng cho các sự kiện khác.",
        "Event Bubbling và Capturing làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Event Bubbling và Capturing là các lỗi phổ biến trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 229,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Promise.all()`** và **`Promise.race()`** và khi nào nên sử dụng từng phương thức để quản lý nhiều Promises?",
      "options": [
        "`Promise.all()` trả về một Promise sẽ giải quyết (resolve) khi **tất cả** các Promises trong iterable đầu vào đều đã giải quyết, hoặc từ chối (reject) ngay lập tức nếu bất kỳ Promise nào bị từ chối. `Promise.race()` trả về một Promise sẽ giải quyết hoặc từ chối ngay lập tức khi **Promise đầu tiên** trong iterable giải quyết hoặc từ chối. `all()` cho tất cả, `race()` cho cái nhanh nhất.",
        "`Promise.all()` và `Promise.race()` đều có chức năng tương tự, chỉ khác về cú pháp.",
        "`Promise.all()` chỉ hoạt động với các yêu cầu mạng, còn `Promise.race()` với các tác vụ cục bộ.",
        "Cả hai đều chỉ dùng để xử lý lỗi trong Promise."
      ],
      "correctAnswer": 0
    },
    {
      "id": 230,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Proxy`** và **`Reflect`** trong ES6 và cách chúng thường được sử dụng cùng nhau để tạo ra các 'meta-programming' hoặc 'observability' features.",
      "options": [
        "`Proxy` cho phép bạn 'đánh chặn' và tùy chỉnh các thao tác cơ bản trên một đối tượng (ví dụ: `get`, `set`). `Reflect` cung cấp các phương thức tĩnh tương ứng với các thao tác đó, cung cấp một cách an toàn và chuẩn hóa để gọi các hành vi mặc định. Chúng thường được dùng cùng nhau: `Proxy` đánh chặn thao tác, sau đó `Reflect` thực hiện thao tác đó một cách chuẩn hóa, hữu ích cho reactivity (Vue 3), logging, hoặc validation mà không làm bẩn đối tượng gốc.",
        "`Proxy` và `Reflect` là cách để JavaScript thực hiện đa luồng.",
        "`Proxy` và `Reflect` chỉ hoạt động với các kiểu dữ liệu nguyên thủy.",
        "Cả hai đều là cách để JavaScript mã hóa dữ liệu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 231,
      "topicId": 3,
      "question": "Giải thích khái niệm **Module Bundlers** (ví dụ: Webpack, Rollup, Parcel) trong JavaScript và vai trò của chúng trong phát triển frontend hiện đại.",
      "options": [
        "Module Bundlers là các công cụ xử lý các file module JavaScript (và các tài nguyên khác như CSS, hình ảnh) và đóng gói chúng thành một hoặc nhiều file đầu ra có thể triển khai trên trình duyệt. Chúng giải quyết các vấn đề về tương thích trình duyệt (polyfills), tối ưu hóa hiệu suất (tree shaking, code splitting, minification), và quản lý phụ thuộc, là xương sống của hầu hết các dự án frontend phức tạp ngày nay.",
        "Module Bundlers chỉ dùng để mã hóa mã nguồn JavaScript.",
        "Module Bundlers giúp tự động kiểm tra lỗi cú pháp trong JavaScript.",
        "Module Bundlers là các thư viện JavaScript để tạo animation."
      ],
      "correctAnswer": 0
    },
    {
      "id": 232,
      "topicId": 3,
      "question": "Sự khác biệt giữa **Shallow Copy** và **Deep Copy** của đối tượng/mảng trong JavaScript và các phương pháp thực hiện từng loại?",
      "options": [
        "Shallow copy tạo một bản sao mới của đối tượng/mảng, nhưng các đối tượng lồng nhau bên trong vẫn tham chiếu đến cùng địa chỉ bộ nhớ. Phương pháp: `...spread` operator, `Object.assign()`. Deep copy tạo một bản sao hoàn chỉnh của đối tượng/mảng và tất cả các đối tượng lồng nhau của nó. Phương pháp: `JSON.parse(JSON.stringify(obj))` (có hạn chế), thư viện như Lodash's `cloneDeep`.",
        "Shallow copy thay đổi đối tượng gốc, còn Deep copy thì không.",
        "Deep copy luôn hiệu quả hơn Shallow copy về mặt hiệu suất.",
        "Không có sự khác biệt đáng kể giữa hai loại sao chép này."
      ],
      "correctAnswer": 0
    },
    {
      "id": 233,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WebAssembly (Wasm)`** trong phát triển web và cách nó tương tác với JavaScript để cải thiện hiệu suất các tác vụ nặng.",
      "options": [
        "WebAssembly là một định dạng mã nhị phân cấp thấp, hiệu suất cao, an toàn được thiết kế để chạy trong trình duyệt web. Nó được biên dịch từ các ngôn ngữ như C, C++, Rust. JavaScript có thể gọi và tương tác với các module Wasm, cho phép thực hiện các tác vụ tính toán chuyên sâu (ví dụ: xử lý ảnh, game, VR) với tốc độ gần như native, trong khi JavaScript vẫn xử lý logic UI.",
        "WebAssembly là một framework JavaScript mới để xây dựng ứng dụng web.",
        "WebAssembly là một cách để mã hóa JavaScript để ngăn chặn việc sao chép.",
        "WebAssembly chỉ hoạt động trong môi trường Node.js."
      ],
      "correctAnswer": 0
    },
    {
      "id": 234,
      "topicId": 3,
      "question": "Giải thích khái niệm **IIFE (Immediately Invoked Function Expression)** trong JavaScript và lợi ích của nó trước khi có Modules.",
      "options": [
        "IIFE là một hàm JavaScript được định nghĩa và thực thi ngay lập tức sau khi được tạo. Cú pháp phổ biến là `(function() { ... })();`. Lợi ích chính là tạo ra một phạm vi biến riêng (private scope) để tránh làm ô nhiễm phạm vi toàn cục (global scope) với các biến và hàm tạm thời, một kỹ thuật rất quan trọng trước khi ES6 Modules ra đời để đạt được tính đóng gói.",
        "IIFE là một cách để JavaScript thực hiện đa luồng.",
        "IIFE làm tăng đáng kể hiệu suất của hàm.",
        "IIFE chỉ dùng để xử lý lỗi trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 235,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Set`** và **`WeakSet`** trong JavaScript về khả năng lưu trữ giá trị và cách chúng bị ảnh hưởng bởi Garbage Collection?",
      "options": [
        "`Set` có thể lưu trữ bất kỳ kiểu dữ liệu nào và giữ tham chiếu mạnh mẽ đến các giá trị của nó, ngăn cản Garbage Collector (GC) thu thập chúng. `WeakSet` chỉ có thể lưu trữ các đối tượng và giữ tham chiếu yếu; nếu không còn tham chiếu nào khác đến đối tượng đó, GC có thể xóa nó khỏi `WeakSet`, giúp quản lý bộ nhớ hiệu quả hơn khi liên kết dữ liệu tạm thời với đối tượng.",
        "`WeakSet` có hiệu suất tốt hơn `Set` trong mọi trường hợp.",
        "`Set` chỉ hoạt động với các kiểu dữ liệu nguyên thủy, còn `WeakSet` với đối tượng.",
        "Cả hai đều là cách để JavaScript mã hóa dữ liệu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 236,
      "topicId": 3,
      "question": "Mô tả cách hoạt động của **`Intersection Observer API`** trong JavaScript và khi nào nó được ưu tiên sử dụng cho Lazy Loading hoặc animation khi cuộn.",
      "options": [
        "`Intersection Observer API` cung cấp một cách hiệu quả để phát hiện khi một phần tử giao cắt (intersec) với viewport của trình duyệt hoặc một phần tử cha cụ thể. Nó được ưu tiên hơn các sự kiện `scroll` truyền thống cho lazy loading hình ảnh/video, tải nội dung vô hạn, hoặc kích hoạt animation khi phần tử vào/ra tầm nhìn, vì nó hiệu suất hơn (không cần lắng nghe sự kiện cuộn liên tục) và hoạt động bất đồng bộ.",
        "`Intersection Observer API` là một cách để JavaScript tự động cuộn trang web.",
        "`Intersection Observer API` chỉ hoạt động trên các thiết bị di động.",
        "`Intersection Observer API` làm tăng đáng kể mức tiêu thụ pin."
      ],
      "correctAnswer": 0
    },
    {
      "id": 237,
      "topicId": 3,
      "question": "Giải thích khái niệm **Event Delegation** trong JavaScript và lợi ích của nó trong việc xử lý sự kiện DOM hiệu quả cho các danh sách lớn hoặc động.",
      "options": [
        "Event Delegation là kỹ thuật gắn một trình lắng nghe sự kiện (event listener) vào một phần tử cha (parent element) thay vì gắn vào từng phần tử con riêng lẻ. Khi một sự kiện kích hoạt trên phần tử con, nó sẽ nổi bọt (bubble) lên phần tử cha, nơi listener được đặt. Lợi ích: giảm số lượng event listeners, tiết kiệm bộ nhớ, cải thiện hiệu suất, và dễ dàng xử lý các phần tử được thêm/xóa động khỏi DOM mà không cần gắn lại listeners.",
        "Event Delegation chỉ hoạt động với các sự kiện click.",
        "Event Delegation làm tăng đáng kể thời gian tải trang.",
        "Event Delegation là một cách để JavaScript giao tiếp với server."
      ],
      "correctAnswer": 0
    },
    {
      "id": 238,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích khái niệm **'Currying'** và lợi ích của nó trong lập trình hàm (functional programming).",
      "options": [
        "Currying là một kỹ thuật biến đổi hàm, nơi một hàm nhận nhiều đối số được chuyển thành một chuỗi các hàm, mỗi hàm chỉ nhận một đối số duy nhất. Lợi ích: giúp tạo các hàm chuyên biệt hơn (partial application), tăng khả năng tái sử dụng, dễ đọc hơn cho các hàm với nhiều đối số, và là một khái niệm cơ bản trong lập trình hàm.",
        "Currying là một cách để tối ưu hóa hiệu suất của vòng lặp `for`.",
        "Currying chỉ hoạt động với các hàm bất đồng bộ.",
        "Currying là một lỗi cú pháp trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 239,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`localStorage`** và **`sessionStorage`** trong Web Storage API và khi nào nên ưu tiên sử dụng từng loại?",
      "options": [
        "`localStorage` lưu trữ dữ liệu vĩnh viễn cho đến khi bị xóa thủ công hoặc bằng script, dữ liệu vẫn tồn tại qua các phiên duyệt web. `sessionStorage` chỉ lưu trữ dữ liệu trong suốt phiên làm việc của trình duyệt hiện tại; dữ liệu sẽ bị xóa khi tab/window bị đóng. Ưu tiên `localStorage` cho dữ liệu cần giữ lại lâu dài, và `sessionStorage` cho dữ liệu tạm thời của phiên.",
        "`localStorage` có giới hạn dung lượng nhỏ hơn `sessionStorage`.",
        "`localStorage` an toàn hơn `sessionStorage` về mặt bảo mật.",
        "Cả hai đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 240,
      "topicId": 3,

      "question": "Mô tả vai trò của **`Web Components`** (Custom Elements, Shadow DOM, HTML Templates) và cách chúng giúp xây dựng các UI component tái sử dụng trong JavaScript.",
      "options": [
        "Web Components là một bộ tiêu chuẩn web cho phép bạn tạo các thành phần UI có thể tái sử dụng, đóng gói, và tương tác độc lập. **Custom Elements** định nghĩa các thẻ HTML mới. **Shadow DOM** cung cấp tính đóng gói CSS và DOM. **HTML Templates** (`<template>`, `<slot>`) cho phép định nghĩa các khối HTML có thể tái sử dụng. Chúng giúp xây dựng các component không phụ thuộc framework và có khả năng tích hợp cao.",
        "Web Components là một framework JavaScript độc quyền của Google.",
        "Web Components chỉ hoạt động trên các trình duyệt cũ.",
        "Web Components là một công cụ để kiểm tra lỗi cú pháp HTML."
      ],
      "correctAnswer": 0
    },
    {
      "id": 241,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Higher-Order Functions'** trong JavaScript và ví dụ về các hàm tích hợp sẵn là HOFs.",
      "options": [
        "Higher-Order Function (HOF) là một hàm nhận một hoặc nhiều hàm làm đối số, hoặc trả về một hàm làm kết quả. Chúng là một khái niệm cốt lõi trong lập trình hàm. Ví dụ về HOFs tích hợp sẵn: `map()`, `filter()`, `reduce()`, `setTimeout()`, `addEventListener()`. HOFs giúp tạo ra code linh hoạt, tái sử dụng và trừu tượng hơn.",
        "HOFs là các hàm được gọi với quyền ưu tiên cao hơn các hàm khác.",
        "HOFs chỉ dùng để xử lý các lỗi bất đồng bộ.",
        "HOFs làm tăng đáng kể mức tiêu thụ bộ nhớ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 242,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`try...catch...finally`** và chỉ **`try...catch`** trong xử lý lỗi JavaScript?",
      "options": [
        "`try...catch` dùng để bắt và xử lý các lỗi xảy ra trong khối `try`. `finally` là một khối code tùy chọn sẽ luôn được thực thi sau `try` và `catch` (cho dù có lỗi xảy ra hay không), thường dùng để thực hiện các công việc dọn dẹp tài nguyên (ví dụ: đóng kết nối, giải phóng bộ nhớ) bất kể kết quả của khối `try`.",
        "`finally` chỉ hoạt động với các lỗi bất đồng bộ.",
        "`finally` sẽ ngừng thực thi code nếu có lỗi xảy ra.",
        "Không có sự khác biệt đáng kể, `finally` chỉ là cú pháp bổ sung không bắt buộc."
      ],
      "correctAnswer": 0
    },
    {
      "id": 243,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WeakRef`** trong JavaScript (ES2021) và khi nào nên sử dụng nó để quản lý bộ nhớ.",
      "options": [
        "`WeakRef` (Weak Reference) cho phép bạn tạo một tham chiếu yếu đến một đối tượng, không ngăn cản đối tượng đó bị Garbage Collector (GC) thu thập nếu không còn tham chiếu mạnh nào khác. Hữu ích cho việc xây dựng cache hoặc bản đồ dữ liệu mà bạn muốn tự động xóa các mục khi đối tượng tương ứng không còn được sử dụng, giúp tránh rò rỉ bộ nhớ trong các hệ thống phức tạp.",
        "`WeakRef` chỉ có thể tham chiếu đến các kiểu dữ liệu nguyên thủy.",
        "`WeakRef` làm tăng đáng kể hiệu suất của ứng dụng.",
        "`WeakRef` là một cách để mã hóa dữ liệu trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 244,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Type Coercion'** trong JavaScript và đưa ra ví dụ về cách nó có thể dẫn đến hành vi không mong muốn.",
      "options": [
        "Type Coercion là quá trình JavaScript tự động chuyển đổi kiểu dữ liệu của một giá trị sang kiểu dữ liệu khác khi cần thiết (ví dụ: trong phép toán, so sánh `==`). Ví dụ: `1 + '2'` sẽ cho kết quả `'12'` (số 1 bị ép thành chuỗi) hoặc `'10' == 10` trả về `true`. Nó có thể dẫn đến các lỗi khó lường nếu không hiểu rõ cách ép kiểu hoạt động.",
        "Type Coercion là một phương pháp để kiểm tra kiểu dữ liệu của biến.",
        "Type Coercion chỉ xảy ra trong các trình duyệt cũ.",
        "Type Coercion là một cách để tối ưu hóa hiệu suất của chuỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 245,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`event.preventDefault()`** và **`event.stopPropagation()`** trong JavaScript Event Handling?",
      "options": [
        "`event.preventDefault()` ngăn chặn hành vi mặc định của trình duyệt đối với sự kiện (ví dụ: ngăn form submit, ngăn link chuyển hướng). `event.stopPropagation()` ngăn chặn sự kiện nổi bọt (bubbling) hoặc đi xuống (capturing) các phần tử cha/con tiếp theo trong cây DOM, ngăn các event listeners khác ở cấp cao hơn nhận sự kiện này. Chúng có mục đích khác nhau: một là kiểm soát hành vi, một là kiểm soát luồng sự kiện.",
        "`event.preventDefault()` chỉ dùng cho các sự kiện click, còn `event.stopPropagation()` cho các sự kiện bàn phím.",
        "Cả hai đều làm cho sự kiện không được thực thi.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 246,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Service Workers`** trong JavaScript và cách chúng cho phép Progressive Web Apps (PWAs) có khả năng offline và hiệu suất cao.",
      "options": [
        "Service Workers là một loại Web Worker đặc biệt, hoạt động như một proxy giữa trình duyệt và mạng. Chúng có thể chặn và quản lý các yêu cầu mạng, lưu trữ tài nguyên vào cache (Cache API), và phục vụ nội dung offline. Điều này cho phép PWAs có khả năng hoạt động ngoại tuyến, tải nhanh hơn (từ cache), và gửi thông báo đẩy (push notifications), mang lại trải nghiệm giống ứng dụng native.",
        "Service Workers là công cụ để kiểm tra lỗi và debug JavaScript trong môi trường offline.",
        "Service Workers là một API cho phép tạo ra các animation phức tạp mà không ảnh hưởng đến hiệu suất.",
        "Service Workers giúp tự động tối ưu hóa hình ảnh và video trên trang web."
      ],
      "correctAnswer": 0
    },
    {
      "id": 247,
      "topicId": 3,
      "question": "Giải thích khái niệm **`Temporal Dead Zone (TDZ)`** trong JavaScript và nó liên quan như thế nào đến `let` và `const`.",
      "options": [
        "Temporal Dead Zone (TDZ) là một khoảng thời gian giữa lúc một biến `let` hoặc `const` được hoisting và thời điểm nó thực sự được khai báo trong code. Nếu bạn cố gắng truy cập biến trong TDZ (trước khi nó được khai báo), JavaScript sẽ báo lỗi `ReferenceError`. Điều này khác với `var` (được hoisting và khởi tạo với `undefined`) và giúp ngăn chặn lỗi truy cập biến trước khi khởi tạo.",
        "TDZ là một khu vực bộ nhớ nơi JavaScript lưu trữ các biến tạm thời.",
        "TDZ chỉ áp dụng cho các biến toàn cục (global variables).",
        "TDZ là một tính năng bảo mật mới trong JavaScript để ngăn chặn mã độc."
      ],
      "correctAnswer": 0
    },
    {
      "id": 248,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`document.getElementById()`**, **`document.querySelector()`**, và **`document.querySelectorAll()`** về cách chọn phần tử DOM và hiệu suất?",
      "options": [
        "`getElementById()` chỉ chọn một phần tử duy nhất bằng ID, là phương thức nhanh nhất. `querySelector()` chọn phần tử đầu tiên khớp với CSS selector đã cho, linh hoạt hơn nhưng chậm hơn `getElementById()`. `querySelectorAll()` chọn tất cả các phần tử khớp với CSS selector và trả về NodeList (tĩnh), chậm nhất nhưng mạnh mẽ nhất cho các lựa chọn phức tạp. Luôn ưu tiên `getElementById()` nếu có thể.",
        "`querySelector()` và `querySelectorAll()` chỉ hoạt động trên các trình duyệt hiện đại.",
        "`getElementById()` có thể chọn nhiều phần tử, còn các phương thức kia chỉ chọn một.",
        "Hiệu suất của cả ba phương thức là như nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 249,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WebSockets`** trong JavaScript và khi nào nên ưu tiên sử dụng chúng thay vì HTTP để giao tiếp client-server.",
      "options": [
        "WebSockets cung cấp một kênh giao tiếp hai chiều (full-duplex), liên tục và duy trì kết nối giữa client và server thông qua một giao thức nâng cấp từ HTTP. Không giống HTTP (request-response không trạng thái), WebSockets cho phép server chủ động đẩy dữ liệu đến client và ngược lại, giảm độ trễ. Ưu tiên WebSockets cho các ứng dụng yêu cầu cập nhật dữ liệu thời gian thực như ứng dụng chat, game trực tuyến, hoặc dashboard live.",
        "WebSockets chỉ hoạt động trên giao thức HTTPS, trong khi HTTP có thể dùng cả HTTP và HTTPS.",
        "WebSockets chỉ cho phép client gửi dữ liệu đến server, không cho phép server đẩy dữ liệu đến client.",
        "WebSockets yêu cầu nhiều tài nguyên server hơn HTTP và chỉ nên dùng cho các ứng dụng có lượng truy cập thấp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 250,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích khái niệm **`Debouncing`** và **`Throttling`** và khi nào nên áp dụng chúng để tối ưu hóa hiệu suất của các sự kiện DOM thường xuyên kích hoạt.",
      "options": [
        "`Debouncing` trì hoãn việc thực thi hàm cho đến khi một khoảng thời gian nhất định trôi qua kể từ lần cuối cùng sự kiện kích hoạt (ví dụ: thanh tìm kiếm). `Throttling` giới hạn tần suất thực thi của hàm đến một mức tối đa nhất định trong một khoảng thời gian (ví dụ: sự kiện cuộn). Cả hai đều được sử dụng để tối ưu hóa hiệu suất, ngăn chặn các hàm được gọi quá nhiều lần bởi các sự kiện như `resize`, `scroll`, `input` và cải thiện tính phản hồi của UI.",
        "`Debouncing` và `Throttling` là các API mới trong ES6 để xử lý bất đồng bộ.",
        "`Debouncing` và `Throttling` chỉ hoạt động trong môi trường Node.js.",
        "`Debouncing` và `Throttling` làm tăng đáng kể mức tiêu thụ bộ nhớ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 251,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích khái niệm **'Memoization'** và khi nào nên áp dụng nó để tối ưu hóa hiệu suất hàm tính toán nặng hoặc hàm đệ quy.",
      "options": [
        "Memoization là một kỹ thuật tối ưu hóa dùng để lưu trữ (cache) kết quả của các lời gọi hàm đắt tiền (tốn tài nguyên) và trả về kết quả đã lưu trữ nếu các đối số đầu vào tương tự được truyền lại. Nó hữu ích cho các hàm 'pure functions' (hàm thuần khiết) hoặc hàm đệ quy có các lời gọi lặp lại với cùng đầu vào, giúp tránh tính toán lại không cần thiết và tăng hiệu suất. Ví dụ: tối ưu hàm Fibonacci.",
        "Memoization là một cách để mã hóa hàm để bảo vệ nó khỏi việc sao chép.",
        "Memoization chỉ hoạt động với các hàm bất đồng bộ.",
        "Memoization làm tăng đáng kể mức tiêu thụ bộ nhớ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 252,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`WeakMap`** và **`Map`** trong JavaScript về khả năng lưu trữ key và ảnh hưởng đến Garbage Collection (GC)?",
      "options": [
        "`Map` có thể sử dụng bất kỳ kiểu dữ liệu nào làm key và giữ tham chiếu mạnh mẽ đến các key đó, ngăn GC thu thập chúng. `WeakMap` chỉ cho phép **đối tượng** làm key và giữ tham chiếu yếu; nếu không còn tham chiếu mạnh nào đến đối tượng key, GC có thể xóa key-value pair đó khỏi `WeakMap`. Ưu tiên `WeakMap` khi cần liên kết dữ liệu với đối tượng mà không muốn ngăn đối tượng đó bị giải phóng bộ nhớ (ví dụ: metadata cho các đối tượng DOM).",
        "`WeakMap` có hiệu suất tốt hơn `Map` trong mọi trường hợp.",
        "`WeakMap` chỉ hoạt động với các kiểu dữ liệu nguyên thủy.",
        "Cả hai đều là cách để JavaScript mã hóa dữ liệu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 253,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Proxy`** trong ES6 và các trường hợp sử dụng nâng cao của nó (ví dụ: validation, logging, reactivity).",
      "options": [
        "`Proxy` là một đối tượng cho phép bạn định nghĩa các hành vi tùy chỉnh cho các thao tác cơ bản trên đối tượng (ví dụ: `get`, `set`, `apply`, `construct`). Nó được sử dụng để 'đánh chặn' và điều khiển các hoạt động trên một đối tượng mục tiêu. Ứng dụng: **validation** dữ liệu, **logging** các truy cập, tạo hệ thống **reactivity** (như trong Vue 3), hoặc bảo vệ đối tượng, mà không cần sửa đổi đối tượng gốc.",
        "`Proxy` là một cách để tạo các đối tượng chỉ đọc (immutable objects).",
        "`Proxy` chỉ hoạt động với các lớp (classes) trong JavaScript.",
        "`Proxy` là một công cụ để kiểm tra lỗi cú pháp trong code."
      ],
      "correctAnswer": 0
    },
    {
      "id": 254,
      "topicId": 3,
      "question": "Giải thích khái niệm **`Generators`** (`function*` và `yield`) trong JavaScript và cách chúng khác với các hàm thông thường trong việc xử lý các luồng dữ liệu bất đồng bộ hoặc tạo chuỗi giá trị.",
      "options": [
        "`Generators` là các hàm đặc biệt có thể tạm dừng việc thực thi và tiếp tục lại sau đó, trả về nhiều giá trị theo thời gian. Chúng được định nghĩa bằng `function*` và sử dụng từ khóa `yield` để tạm dừng và trả về một giá trị. Không giống hàm thông thường chỉ trả về một lần, `Generators` có thể tạo ra các chuỗi giá trị theo kiểu 'pull' (người gọi yêu cầu giá trị tiếp theo) và hữu ích cho việc quản lý các luồng bất đồng bộ phức tạp (kết hợp với `async`/`await` qua `co` library trước khi có native `async`/`await`).",
        "`Generators` chỉ dùng để tạo ra các số ngẫu nhiên.",
        "`Generators` là một cách để JavaScript thực hiện đa luồng.",
        "`Generators` làm tăng đáng kể hiệu suất của vòng lặp `for...of`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 255,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Array.prototype.slice()`** và **`Array.prototype.splice()`** trong JavaScript về cách thao tác với mảng và việc thay đổi mảng gốc?",
      "options": [
        "`slice()` trả về một bản sao nông (shallow copy) của một phần của mảng mà không thay đổi mảng gốc. `splice()` thay đổi (mutates) mảng gốc bằng cách thêm, xóa hoặc thay thế các phần tử tại một vị trí cụ thể. `slice()` dùng để trích xuất, `splice()` dùng để sửa đổi tại chỗ.",
        "`slice()` chỉ hoạt động với chuỗi, còn `splice()` với số.",
        "`slice()` có hiệu suất tốt hơn `splice()` trong mọi trường hợp.",
        "Cả hai đều có chức năng tương tự và có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 256,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WebAssembly (Wasm)`** trong phát triển web và cách nó tương tác với JavaScript để cải thiện hiệu suất các tác vụ nặng (compute-intensive tasks).",
      "options": [
        "WebAssembly là một định dạng mã nhị phân cấp thấp, hiệu suất cao, an toàn được thiết kế để chạy trong trình duyệt web. Nó được biên dịch từ các ngôn ngữ như C, C++, Rust, Go. JavaScript có thể gọi và tương tác với các module Wasm, cho phép thực hiện các tác vụ tính toán chuyên sâu (ví dụ: xử lý ảnh, video, game engine, mô phỏng khoa học) với tốc độ gần như native, giải phóng luồng chính của JavaScript để xử lý UI.",
        "WebAssembly là một framework JavaScript mới để xây dựng ứng dụng web.",
        "WebAssembly là một cách để mã hóa JavaScript để ngăn chặn việc sao chép.",
        "WebAssembly chỉ hoạt động trong môi trường Node.js."
      ],
      "correctAnswer": 0
    },
    {
      "id": 257,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Garbage Collection'** trong JavaScript và cách nó quản lý bộ nhớ để tránh rò rỉ.",
      "options": [
        "Garbage Collection (GC) là một quá trình tự động trong JavaScript engine (và nhiều ngôn ngữ khác) để xác định và thu hồi bộ nhớ không còn được sử dụng bởi chương trình (ví dụ: các biến không còn tham chiếu). Nó giúp ngăn chặn rò rỉ bộ nhớ (memory leaks) và lập trình viên không cần quản lý bộ nhớ thủ công. Cơ chế phổ biến là 'mark-and-sweep'.",
        "Garbage Collection là một công cụ để nén mã nguồn JavaScript.",
        "Garbage Collection chỉ hoạt động trong môi trường Node.js.",
        "Garbage Collection là một loại lỗi trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 258,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích về **`SetTimeout(..., 0)`** và cách nó không thực sự nghĩa là 'thực thi ngay lập tức' mà là 'thực thi càng sớm càng tốt' trong Event Loop.",
      "options": [
        "`setTimeout(callback, 0)` đặt `callback` vào Macrotask Queue (hoặc Task Queue). Mặc dù thời gian chờ là 0, `callback` vẫn phải đợi cho đến khi Call Stack trống và Event Loop đẩy nó vào. Điều này có nghĩa là nó sẽ thực thi sau tất cả các mã đồng bộ hiện tại và tất cả Microtasks (Promise callbacks), không phải ngay lập tức.",
        "`setTimeout(..., 0)` sẽ thực thi callback ngay lập tức, bỏ qua Event Loop.",
        "`setTimeout(..., 0)` chỉ hoạt động với các hàm bất đồng bộ.",
        "`setTimeout(..., 0)` là một lỗi cú pháp trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 259,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Array.from()`** và **`[...arrayLike]`** (Spread syntax) khi chuyển đổi các đối tượng giống mảng (array-like objects) hoặc iterables thành mảng thực sự?",
      "options": [
        "`Array.from()` có thể chuyển đổi bất kỳ iterable (ví dụ: Set, Map, NodeList, String) hoặc array-like object (có `length` property) thành một mảng mới, và có thể nhận một hàm map làm đối số thứ hai. `[...arrayLike]` (Spread syntax) chỉ có thể chuyển đổi các **iterables** thành mảng. `Array.from()` linh hoạt hơn cho các đối tượng giống mảng không phải iterable.",
        "`Array.from()` thay đổi đối tượng gốc, còn Spread syntax thì không.",
        "`Array.from()` chỉ hoạt động với số, còn Spread syntax với chuỗi.",
        "Cả hai đều có chức năng tương tự và có thể dùng thay thế cho nhau trong mọi trường hợp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 260,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Optional Chaining (?.)`** và **`Nullish Coalescing (??)`** trong ES2020 để xử lý giá trị `null`/`undefined` một cách an toàn.",
      "options": [
        "Optional Chaining (`?.`) cho phép bạn truy cập các thuộc tính hoặc gọi phương thức của một đối tượng mà không cần kiểm tra sự tồn tại của từng cấp độ, trả về `undefined` nếu bất kỳ tham chiếu nào trong chuỗi là `null` hoặc `undefined`. Nullish Coalescing (`??`) là toán tử logic trả về toán hạng bên phải nếu toán hạng bên trái là `null` hoặc `undefined`, ngược lại trả về toán hạng bên trái. Cả hai giúp viết code an toàn hơn và ngắn gọn hơn khi làm việc với các giá trị có thể thiếu.",
        "Optional Chaining và Nullish Coalescing chỉ dùng để kiểm tra kiểu dữ liệu.",
        "Optional Chaining và Nullish Coalescing làm tăng đáng kể hiệu suất của hàm.",
        "Cả hai đều là lỗi cú pháp trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 261,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Pure Functions'** (hàm thuần khiết) trong JavaScript và lợi ích của chúng trong việc phát triển và kiểm thử code.",
      "options": [
        "Pure Functions là các hàm tuân thủ hai quy tắc: 1) Luôn trả về cùng một kết quả cho cùng một đầu vào (deterministic). 2) Không gây ra bất kỳ side effects (tác dụng phụ) nào (ví dụ: không thay đổi biến bên ngoài, không thực hiện I/O). Lợi ích: dễ kiểm thử (dự đoán được kết quả), dễ hiểu, dễ dàng song song hóa, và là nền tảng cho các kỹ thuật tối ưu hóa như memoization.",
        "Pure Functions chỉ có thể nhận một đối số duy nhất.",
        "Pure Functions làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Pure Functions chỉ hoạt động với các kiểu dữ liệu nguyên thủy."
      ],
      "correctAnswer": 0
    },
    {
      "id": 262,
      "topicId": 3,
      "question": "Trong JavaScript, sự khác biệt giữa **`const obj = {}; obj.prop = 1;`** và **`obj = {};`** khi dùng `const` với đối tượng?",
      "options": [
        "`const obj = {};` khai báo `obj` là một hằng số tham chiếu (constant reference) đến đối tượng. Điều này có nghĩa là bạn không thể gán lại `obj` cho một đối tượng khác (`obj = {};` sẽ báo lỗi), nhưng bạn **có thể** sửa đổi các thuộc tính bên trong đối tượng mà `obj` đang tham chiếu (`obj.prop = 1;` là hợp lệ).",
        "`const` ngăn chặn mọi thay đổi đối với đối tượng được gán.",
        "`const` chỉ hoạt động với các kiểu dữ liệu nguyên thủy, không hoạt động với đối tượng.",
        "Cả hai đều sẽ gây ra lỗi `TypeError`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 263,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Intl` Object** (Internationalization API) trong JavaScript để định dạng số, ngày tháng, và chuỗi theo ngôn ngữ/vùng miền cụ thể.",
      "options": [
        "Đối tượng `Intl` cung cấp các API để định dạng số, ngày tháng, và chuỗi (ví dụ: so sánh chuỗi, phân loại) theo các quy tắc ngôn ngữ và văn hóa cụ thể. Nó cho phép các ứng dụng hiển thị thông tin một cách phù hợp với người dùng trên toàn thế giới mà không cần phải tự viết logic phức tạp để xử lý các quy tắc địa phương hóa (`new Intl.DateTimeFormat()`, `new Intl.NumberFormat()`).",
        "`Intl` Object là một cách để mã hóa dữ liệu trong JavaScript.",
        "`Intl` Object chỉ hoạt động trong môi trường Node.js.",
        "`Intl` Object là một công cụ để kiểm tra lỗi cú pháp trong code."
      ],
      "correctAnswer": 0
    },
    {
      "id": 264,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Module Pattern'** (hoặc Revealing Module Pattern) trong JavaScript và lợi ích của nó trong việc quản lý private/public members trước ES6 Modules.",
      "options": [
        "Module Pattern là một design pattern sử dụng closures và IIFE để tạo các module đóng gói, cho phép bạn định nghĩa các thuộc tính và phương thức private (không thể truy cập từ bên ngoài) và public (có thể truy cập thông qua một đối tượng trả về). Điều này giúp tránh xung đột biến toàn cục và tổ chức code thành các đơn vị độc lập, dễ quản lý hơn, đặc biệt quan trọng trước khi ES6 Modules ra đời.",
        "Module Pattern chỉ hoạt động với các lớp (classes) trong JavaScript.",
        "Module Pattern làm tăng đáng kể kích thước file JavaScript.",
        "Module Pattern là một cách để JavaScript thực hiện đa luồng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 265,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`null`** và **`undefined`** về mặt kiểu dữ liệu và ý nghĩa trong JavaScript?",
      "options": [
        "`undefined` là một kiểu dữ liệu riêng (primitive type `undefined`) và là giá trị mặc định của một biến chưa được gán, một thuộc tính không tồn tại, hoặc kết quả của một hàm không trả về giá trị. `null` là một giá trị đặc biệt đại diện cho sự vắng mặt có chủ ý của một đối tượng hoặc một giá trị không có ý nghĩa. `typeof null` là 'object' (một lỗi lịch sử), còn `typeof undefined` là 'undefined'.",
        "`null` là một số, còn `undefined` là một chuỗi.",
        "`null` an toàn hơn `undefined` trong các phép tính toán.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 266,
      "topicId": 3,
      "question": "Mô tả vai trò của **`requestAnimationFrame()`** trong JavaScript và khi nào nên sử dụng nó để tạo animation mượt mà và hiệu quả.",
      "options": [
        "`requestAnimationFrame()` là một API của trình duyệt cho phép bạn yêu cầu trình duyệt thực hiện một hàm callback ngay trước lần vẽ lại màn hình tiếp theo (next repaint). Điều này đảm bảo rằng animation được đồng bộ hóa với tốc độ khung hình của trình duyệt (thường là 60fps), tránh giật lag (jank) và tối ưu hóa hiệu suất bằng cách tạm dừng khi trang không hiển thị. Nên dùng cho mọi animation dựa trên JavaScript thay vì `setInterval`.",
        "`requestAnimationFrame()` chỉ hoạt động với các animation 3D.",
        "`requestAnimationFrame()` làm tăng đáng kể mức tiêu thụ pin.",
        "`requestAnimationFrame()` tự động nén hình ảnh cho animation."
      ],
      "correctAnswer": 0
    },
    {
      "id": 267,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Event Delegation'** trong JavaScript và lợi ích của nó trong việc xử lý sự kiện DOM hiệu quả cho các danh sách lớn hoặc động.",
      "options": [
        "Event Delegation là kỹ thuật gắn một trình lắng nghe sự kiện (event listener) vào một phần tử cha (parent element) thay vì gắn vào từng phần tử con riêng lẻ. Khi một sự kiện kích hoạt trên phần tử con, nó sẽ nổi bọt (bubble) lên phần tử cha, nơi listener được đặt. Lợi ích: giảm số lượng event listeners, tiết kiệm bộ nhớ, cải thiện hiệu suất, và dễ dàng xử lý các phần tử được thêm/xóa động khỏi DOM mà không cần gắn lại listeners.",
        "Event Delegation chỉ hoạt động với các sự kiện click.",
        "Event Delegation làm tăng đáng kể thời gian tải trang.",
        "Event Delegation là một cách để JavaScript giao tiếp với server."
      ],
      "correctAnswer": 0
    },
    {
      "id": 268,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích khái niệm **'Functional Programming'** và các nguyên tắc cốt lõi của nó (Pure Functions, Immutability, Higher-Order Functions).",
      "options": [
        "Functional Programming là một phong cách lập trình tập trung vào việc xây dựng phần mềm bằng cách kết hợp các hàm thuần khiết (Pure Functions), tránh thay đổi trạng thái và dữ liệu (Immutability), và sử dụng các hàm bậc cao (Higher-Order Functions). Nó giúp code dễ hiểu, dễ kiểm thử, ít lỗi và dễ dàng song song hóa hơn do không có side effects.",
        "Functional Programming chỉ áp dụng cho các ứng dụng web nhỏ.",
        "Functional Programming làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Functional Programming chỉ hoạt động với các kiểu dữ liệu nguyên thủy."
      ],
      "correctAnswer": 0
    },
    {
      "id": 269,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`let`**, **`const`** và **`var`** về phạm vi (scope), hoisting và tái gán?",
      "options": [
        "`var` là function-scoped, được hoisting và khởi tạo `undefined`. `let` và `const` là block-scoped, được hoisting nhưng nằm trong Temporal Dead Zone (TDZ) cho đến khi khai báo. `var` có thể khai báo lại và gán lại. `let` có thể gán lại nhưng không khai báo lại. `const` không thể khai báo lại và không thể gán lại (đối tượng `const` vẫn có thể thay đổi thuộc tính).",
        "`let` và `const` là tương đương nhau, chỉ khác về cú pháp.",
        "`var` an toàn hơn `let` và `const` trong môi trường đa luồng.",
        "Không có sự khác biệt đáng kể giữa ba từ khóa này trong JavaScript hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 270,
      "topicId": 3,
      "question": "Mô tả cơ chế hoạt động của **'Promises'** trong JavaScript và cách chúng giải quyết vấn đề 'Callback Hell' trong lập trình bất đồng bộ.",
      "options": [
        "Promise là một đối tượng đại diện cho việc hoàn thành (hoặc thất bại) cuối cùng của một thao tác bất đồng bộ. Nó có ba trạng thái: pending, fulfilled, rejected. Promise cho phép xâu chuỗi các thao tác bất đồng bộ một cách rõ ràng và dễ đọc hơn thông qua `.then()` và `.catch()`, tránh tình trạng code lồng nhau phức tạp (callback hell) và giúp quản lý lỗi tốt hơn cho các tác vụ bất đồng bộ.",
        "Promises là một cách để JavaScript thực hiện đa luồng.",
        "Promises chỉ hoạt động với các yêu cầu mạng (fetch API).",
        "Promises làm tăng đáng kể kích thước file JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 271,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Currying'** trong JavaScript và lợi ích của nó trong lập trình hàm (functional programming) và tạo các hàm linh hoạt hơn.",
      "options": [
        "Currying là một kỹ thuật biến đổi hàm, nơi một hàm nhận nhiều đối số được chuyển thành một chuỗi các hàm, mỗi hàm chỉ nhận một đối số duy nhất và trả về một hàm mới cho đối số tiếp theo. Lợi ích: giúp tạo các hàm chuyên biệt hơn (partial application), tăng khả năng tái sử dụng, dễ đọc hơn cho các hàm với nhiều đối số, và là một khái niệm cơ bản trong lập trình hàm, thúc đẩy việc tạo các hàm có thể kết hợp (compose) tốt hơn.",
        "Currying là một cách để tối ưu hóa hiệu suất của vòng lặp `for`.",
        "Currying chỉ hoạt động với các hàm bất đồng bộ.",
        "Currying là một lỗi cú pháp trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 272,
      "topicId": 3,
      "question": "Trong JavaScript, sự khác biệt giữa **`==`** và **`===`** trong việc so sánh giá trị và kiểu dữ liệu, và tại sao luôn ưu tiên `===`?",
      "options": [
        "`==` (so sánh bằng) thực hiện ép kiểu (type coercion) nếu các toán hạng có kiểu khác nhau trước khi so sánh giá trị (ví dụ: `false == 0` là `true`). `===` (so sánh bằng nghiêm ngặt) không thực hiện ép kiểu và chỉ trả về `true` nếu cả giá trị và kiểu dữ liệu của các toán hạng đều giống hệt nhau. Luôn ưu tiên dùng `===` để tránh các lỗi không mong muốn do ép kiểu ngầm định và làm cho code dễ đoán hơn.",
        "`==` so sánh giá trị, còn `===` so sánh địa chỉ bộ nhớ.",
        "`==` chỉ hoạt động với số, còn `===` với chuỗi.",
        "Không có sự khác biệt đáng kể, `==` là phiên bản cũ hơn của `===`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 273,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Symbol.iterator`** trong JavaScript và cách nó cho phép các đối tượng trở thành 'iterable' và sử dụng được với `for...of`.",
      "options": [
        "`Symbol.iterator` là một Symbol tích hợp sẵn, được sử dụng làm khóa cho một phương thức đặc biệt trên một đối tượng. Phương thức này phải trả về một đối tượng 'iterator' có phương thức `next()`. Sự tồn tại của phương thức `Symbol.iterator` giúp đối tượng đó trở thành iterable, cho phép nó được lặp qua bằng vòng lặp `for...of` hoặc Spread syntax (`...`), mở rộng khả năng xử lý dữ liệu của JavaScript.",
        "`Symbol.iterator` là một cách để mã hóa các chuỗi trong JavaScript.",
        "`Symbol.iterator` chỉ dùng để tạo các biểu tượng UI động.",
        "`Symbol.iterator` là một hàm để tối ưu hóa hiệu suất của chuỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 274,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Polyfill'** và **'Transpiler'** (ví dụ: Babel) trong JavaScript và vai trò của chúng trong việc sử dụng các tính năng ES6+.",
      "options": [
        "Polyfill là một đoạn code cung cấp các chức năng của một API hoặc tính năng mới mà trình duyệt cũ không hỗ trợ, để làm cho nó hoạt động trong môi trường cũ (ví dụ: polyfill cho `Promise`). Transpiler (ví dụ: Babel) là một công cụ dịch mã từ một phiên bản ngôn ngữ sang phiên bản khác (ví dụ: ES6+ sang ES5) để mã đó có thể chạy trên các môi trường cũ. Cả hai đều cho phép sử dụng các tính năng hiện đại trong môi trường legacy.",
        "Polyfill và Transpiler đều là các loại lỗi trong JavaScript.",
        "Polyfill chỉ hoạt động trong Node.js, còn Transpiler trong trình duyệt.",
        "Polyfill và Transpiler làm tăng đáng kể kích thước file JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 275,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`setTimeout()`** và **`setInterval()`** trong JavaScript và khi nào nên ưu tiên sử dụng `requestAnimationFrame()` cho animation?",
      "options": [
        "`setTimeout()` thực thi một hàm một lần sau một khoảng thời gian nhất định. `setInterval()` thực thi một hàm lặp đi lặp lại sau mỗi khoảng thời gian nhất định. Cả hai đều không đảm bảo thời gian chính xác và có thể gây jank cho animation. `requestAnimationFrame()` được ưu tiên cho animation vì nó đồng bộ hóa việc thực thi với chu kỳ làm mới màn hình của trình duyệt, đảm bảo animation mượt mà và hiệu quả hơn.",
        "`setTimeout()` và `setInterval()` chỉ dùng cho các tác vụ đồng bộ.",
        "`requestAnimationFrame()` chỉ hoạt động với các animation 3D.",
        "Không có sự khác biệt đáng kể về hiệu suất giữa ba phương pháp này."
      ],
      "correctAnswer": 0
    },
    {
      "id": 276,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WeakRef`** và **`FinalizationRegistry`** trong JavaScript (ES2021) và cách chúng giúp quản lý bộ nhớ phức tạp.",
      "options": [
        "`WeakRef` (Weak Reference) cho phép bạn tạo một tham chiếu yếu đến một đối tượng, không ngăn cản GC thu thập đối tượng đó. `FinalizationRegistry` cho phép bạn đăng ký một callback để được gọi khi một đối tượng được GC thu thập. Chúng được sử dụng để xây dựng cache, bản đồ dữ liệu, hoặc thực hiện các công việc dọn dẹp liên quan đến đối tượng mà không tạo ra rò rỉ bộ nhớ, nhưng cần thận trọng vì hành vi GC là không thể đoán trước.",
        "`WeakRef` và `FinalizationRegistry` chỉ có thể tham chiếu đến các kiểu dữ liệu nguyên thủy.",
        "`WeakRef` và `FinalizationRegistry` làm tăng đáng kể hiệu suất của ứng dụng.",
        "`WeakRef` và `FinalizationRegistry` là một cách để mã hóa dữ liệu trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 277,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Throttling'** trong JavaScript và khi nào nên sử dụng nó để tối ưu hóa hiệu suất của các sự kiện thường xuyên kích hoạt.",
      "options": [
        "Throttling là một kỹ thuật tối ưu hóa hiệu suất để giới hạn việc thực thi một hàm đến một tần suất tối đa nhất định. Nó đảm bảo hàm chỉ được gọi một lần trong mỗi khoảng thời gian đã định, ngay cả khi sự kiện kích hoạt liên tục (ví dụ: `scroll`, `mousemove`). Điều này giúp tránh việc hàm chạy quá nhiều lần, làm giảm tải CPU và duy trì tính phản hồi của ứng dụng, đồng thời vẫn cung cấp phản hồi liên tục cho người dùng.",
        "Throttling là cách để JavaScript tải bất đồng bộ các tài nguyên.",
        "Throttling là một phương pháp để mã hóa các chuỗi trong JavaScript.",
        "Throttling chỉ hoạt động trong môi trường Node.js."
      ],
      "correctAnswer": 0
    },
    {
      "id": 278,
      "topicId": 3,
      "question": "Trong JavaScript, sự khác biệt giữa **`async function`** và một hàm trả về **`Promise`** thông thường?",
      "options": [
        "Một `async function` luôn trả về một `Promise`, tự động bao bọc giá trị trả về trong một `Promise.resolve()` hoặc ném lỗi vào `Promise.reject()`. Nó cũng cho phép sử dụng từ khóa `await` bên trong để tạm dừng việc thực thi cho đến khi Promise được giải quyết. Một hàm trả về `Promise` thông thường yêu cầu bạn tự tạo và trả về một đối tượng `Promise` một cách thủ công. `async/await` là cú pháp gọn gàng hơn.",
        "`async function` luôn chạy song song, còn hàm trả về Promise thì không.",
        "`async function` chỉ hoạt động với các yêu cầu mạng.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 279,
      "topicId": 3,
      "question": "Mô tả vai trò của **`EventTarget`** trong JavaScript và cách nó là cơ sở cho các cơ chế sự kiện trong trình duyệt.",
      "options": [
        "`EventTarget` là một giao diện DOM mà bất kỳ đối tượng nào cũng có thể triển khai để có khả năng gửi, nhận và lắng nghe các sự kiện. Nó cung cấp các phương thức `addEventListener()`, `removeEventListener()`, và `dispatchEvent()`. Các đối tượng phổ biến như `Element`, `Document`, `Window`, và `XMLHttpRequest` đều triển khai `EventTarget`, biến nó thành nền tảng cho việc xử lý sự kiện trong web.",
        "`EventTarget` là một loại sự kiện cụ thể trong JavaScript.",
        "`EventTarget` chỉ áp dụng cho các sự kiện tùy chỉnh (custom events).",
        "`EventTarget` là một cách để mã hóa các sự kiện để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 280,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Module Pattern'** (hoặc Revealing Module Pattern) trong JavaScript và lợi ích của nó trong việc quản lý private/public members và tránh ô nhiễm phạm vi toàn cục.",
      "options": [
        "Module Pattern là một design pattern sử dụng closures và Immediately Invoked Function Expressions (IIFE) để tạo các module đóng gói. Nó cho phép bạn định nghĩa các thuộc tính và phương thức private (không thể truy cập từ bên ngoài) và public (có thể truy cập thông qua một đối tượng trả về). Điều này giúp tránh xung đột biến toàn cục và tổ chức code thành các đơn vị độc lập, dễ quản lý và tái sử dụng hơn, đặc biệt quan trọng trước khi ES6 Modules ra đời.",
        "Module Pattern chỉ hoạt động với các lớp (classes) trong JavaScript.",
        "Module Pattern làm tăng đáng kể kích thước file JavaScript.",
        "Module Pattern là một cách để JavaScript thực hiện đa luồng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 281,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích về **'Temporal Dead Zone (TDZ)'** và nó liên quan như thế nào đến `let` và `const`.",
      "options": [
        "Temporal Dead Zone (TDZ) là một khoảng thời gian giữa lúc một biến `let` hoặc `const` được hoisting và thời điểm nó thực sự được khai báo trong code. Nếu bạn cố gắng truy cập biến trong TDZ (trước khi nó được khai báo), JavaScript sẽ báo lỗi `ReferenceError`. Điều này khác với `var` (được hoisting và khởi tạo với `undefined`) và giúp ngăn chặn lỗi truy cập biến trước khi khởi tạo, làm cho code an toàn hơn.",
        "TDZ là một khu vực bộ nhớ nơi JavaScript lưu trữ các biến tạm thời.",
        "TDZ chỉ áp dụng cho các biến toàn cục (global variables).",
        "TDZ là một tính năng bảo mật mới trong JavaScript để ngăn chặn mã độc."
      ],
      "correctAnswer": 0
    },
    {
      "id": 282,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`document.createElement()`** và **`innerHTML`** khi thao tác DOM về hiệu suất và bảo mật?",
      "options": [
        "`document.createElement()` tạo phần tử DOM một cách an toàn và tường minh, cho phép bạn thêm thuộc tính và con từng bước. `innerHTML` gán một chuỗi HTML vào phần tử, dễ dàng hơn cho nội dung phức tạp nhưng **rủi ro XSS** cao hơn nếu chuỗi không được sanitizing đúng cách. `createElement()` thường an toàn hơn và có thể hiệu quả hơn nếu bạn thao tác với DOM một cách cẩn thận và hiệu quả (ví dụ: dùng `DocumentFragment`), còn `innerHTML` nhanh cho các trường hợp đơn giản nhưng tiềm ẩn rủi ro.",
        "`innerHTML` luôn nhanh hơn `createElement()` trong mọi trường hợp.",
        "`createElement()` chỉ tạo các phần tử HTML cơ bản, còn `innerHTML` tạo các phần tử phức tạp.",
        "Không có sự khác biệt đáng kể về hiệu suất hoặc bảo mật giữa hai phương pháp này."
      ],
      "correctAnswer": 0
    },
    {
      "id": 283,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Mutation Observer API`** trong JavaScript và khi nào nó hữu ích hơn các sự kiện DOM truyền thống để theo dõi thay đổi DOM.",
      "options": [
        "`Mutation Observer API` cung cấp một cách hiệu quả để lắng nghe các thay đổi trong cây DOM (thêm/xóa phần tử, thay đổi thuộc tính, thay đổi nội dung văn bản). Khác với các sự kiện mutation events cũ và không hiệu quả, `Mutation Observer` hoạt động bất đồng bộ và cung cấp thông tin chi tiết về các thay đổi, rất hữu ích cho việc phát hiện chèn quảng cáo, theo dõi nội dung động, hoặc cập nhật UI khi có thay đổi không mong muốn.",
        "`Mutation Observer API` chỉ hoạt động với các sự kiện click.",
        "`Mutation Observer API` làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "`Mutation Observer API` là một cách để JavaScript giao tiếp với server."
      ],
      "correctAnswer": 0
    },
    {
      "id": 284,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Callback Hell'** (hoặc Pyramid of Doom) trong JavaScript và cách **Promises** hoặc **`async/await`** giải quyết nó.",
      "options": [
        "Callback Hell là tình trạng mã bất đồng bộ trở nên khó đọc và khó bảo trì do có quá nhiều hàm callback lồng nhau sâu vào nhau, tạo thành cấu trúc giống kim tự tháp. `Promises` giải quyết điều này bằng cách cho phép xâu chuỗi các tác vụ bất đồng bộ thông qua `.then()` và `.catch()`. `async/await` là cú pháp được xây dựng trên `Promises`, cho phép viết code bất đồng bộ trông giống đồng bộ, giúp làm phẳng cấu trúc và dễ đọc hơn nữa.",
        "Callback Hell là một lỗi cú pháp trong JavaScript.",
        "Callback Hell chỉ xảy ra trong các trình duyệt cũ.",
        "Callback Hell làm tăng đáng kể hiệu suất của ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 285,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Error`**, **`TypeError`**, và **`ReferenceError`** trong JavaScript và khi nào chúng thường xảy ra?",
      "options": [
        "`Error` là đối tượng lỗi cơ bản. `TypeError` xảy ra khi một giá trị không thuộc kiểu mong muốn được sử dụng (ví dụ: gọi một biến không phải là hàm). `ReferenceError` xảy ra khi cố gắng truy cập một biến không được khai báo hoặc nằm trong Temporal Dead Zone (TDZ). Việc hiểu các loại lỗi giúp debug hiệu quả hơn.",
        "Tất cả đều là lỗi cú pháp.",
        "Tất cả đều có thể được bỏ qua bằng `try...catch`.",
        "Chúng chỉ khác nhau về tên gọi, chức năng thì như nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 286,
      "topicId": 3,
      "question": "Mô tả vai trò của **`eval()`** trong JavaScript và tại sao nó thường được coi là một thực hành tồi (bad practice) và rủi ro bảo mật.",
      "options": [
        "`eval()` là một hàm JavaScript thực thi một chuỗi mã dưới dạng mã JavaScript. Nó được coi là một thực hành tồi vì: 1) **Rủi ro bảo mật (XSS):** Nếu chuỗi đầu vào không đáng tin cậy, nó có thể thực thi mã độc. 2) **Hiệu suất kém:** Trình duyệt không thể tối ưu hóa code được thực thi bởi `eval()` vì nó không thể phân tích cú pháp trước. 3) **Khó debug:** Lỗi xảy ra trong `eval()` khó theo dõi. Nên tránh sử dụng và dùng các giải pháp an toàn hơn như JSON parsing hoặc DOM manipulation.",
        "`eval()` giúp tăng đáng kể hiệu suất của ứng dụng JavaScript.",
        "`eval()` chỉ hoạt động trong môi trường Node.js.",
        "`eval()` là một cách để mã hóa mã nguồn JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 287,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Shadow DOM'** trong JavaScript (Web Components) và cách nó cung cấp tính đóng gói cho các UI component.",
      "options": [
        "Shadow DOM là một cây DOM riêng biệt, được gắn vào một phần tử thông thường (host element), hoạt động độc lập và được cách ly hoàn toàn với DOM chính của tài liệu. CSS và JavaScript bên trong Shadow DOM sẽ không bị rò rỉ ra ngoài và style bên ngoài cũng không ảnh hưởng vào trong, tạo ra tính đóng gói mạnh mẽ cho các UI component, giúp tránh xung đột và dễ dàng tái sử dụng.",
        "Shadow DOM chỉ dùng để tạo các hiệu ứng 3D trong giao diện người dùng.",
        "Shadow DOM làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Shadow DOM chỉ hoạt động trên các trình duyệt cũ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 288,
      "topicId": 3,
      "question": "Trong JavaScript, sự khác biệt giữa **`export default`** và **`export named`** trong ES6 Modules?",
      "options": [
        "`export default` cho phép bạn xuất một giá trị duy nhất (hàm, lớp, biến) làm giá trị mặc định của module, và có thể được import với bất kỳ tên nào. `export named` cho phép bạn xuất nhiều giá trị (hàm, lớp, biến) bằng tên của chúng, và chúng phải được import bằng chính tên đó (hoặc dùng alias). Mỗi module chỉ có một `export default`, nhưng có thể có nhiều `export named`.",
        "`export default` chỉ hoạt động với các hàm, còn `export named` với các biến.",
        "`export default` làm tăng đáng kể kích thước module.",
        "Không có sự khác biệt đáng kể, chúng là hai cú pháp tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 289,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Intersection Observer API`** trong JavaScript và khi nào nó được ưu tiên sử dụng cho Lazy Loading hoặc animation khi cuộn.",
      "options": [
        "`Intersection Observer API` cung cấp một cách hiệu quả để phát hiện khi một phần tử giao cắt (intersec) với viewport của trình duyệt hoặc một phần tử cha cụ thể. Nó được ưu tiên hơn các sự kiện `scroll` truyền thống cho lazy loading hình ảnh/video, tải nội dung vô hạn, hoặc kích hoạt animation khi phần tử vào/ra tầm nhìn, vì nó hiệu suất hơn (không cần lắng nghe sự kiện cuộn liên tục) và hoạt động bất đồng bộ, tránh làm đóng băng luồng chính.",
        "`Intersection Observer API` là một cách để JavaScript tự động cuộn trang web.",
        "`Intersection Observer API` chỉ hoạt động trên các thiết bị di động.",
        "`Intersection Observer API` làm tăng đáng kể mức tiêu thụ pin."
      ],
      "correctAnswer": 0
    },
    {
      "id": 290,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Pure Functions'** (hàm thuần khiết) trong JavaScript và lợi ích của chúng trong việc phát triển và kiểm thử code.",
      "options": [
        "Pure Functions là các hàm tuân thủ hai quy tắc: 1) Luôn trả về cùng một kết quả cho cùng một đầu vào (deterministic). 2) Không gây ra bất kỳ side effects (tác dụng phụ) nào (ví dụ: không thay đổi biến bên ngoài, không thực hiện I/O, không gọi API không thuần khiết). Lợi ích: dễ kiểm thử (dự đoán được kết quả), dễ hiểu, dễ dàng song song hóa, và là nền tảng cho các kỹ thuật tối ưu hóa như memoization và lập trình hàm.",
        "Pure Functions chỉ có thể nhận một đối số duy nhất.",
        "Pure Functions làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Pure Functions chỉ hoạt động với các kiểu dữ liệu nguyên thủy."
      ],
      "correctAnswer": 0
    },
    {
      "id": 291,
      "topicId": 3,
      "question": "Trong JavaScript, làm thế nào để xử lý nhiều Promise song song và đợi tất cả chúng hoàn thành trước khi thực hiện hành động tiếp theo?",
      "options": [
        "Sử dụng **`Promise.all()`**. Phương thức này nhận một iterable (thường là mảng) các Promise và trả về một Promise mới. Promise này sẽ `resolve` với một mảng các kết quả khi **tất cả** các Promise đầu vào đều `resolve`, hoặc `reject` ngay lập tức với lỗi của Promise đầu tiên bị `reject`. Đây là cách phổ biến để thực hiện các yêu cầu API đồng thời.",
        "Sử dụng `Promise.race()`.",
        "Sử dụng nhiều `await` liên tiếp mà không có `Promise.all()`.",
        "Không thể xử lý nhiều Promise song song trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 292,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Event Bubbling`** và **`Event Capturing`** trong việc lan truyền sự kiện DOM, và cách `addEventListener()` điều khiển chúng?",
      "options": [
        "Khi một sự kiện xảy ra trên một phần tử DOM, nó sẽ đi qua hai giai đoạn: **Capturing** (từ `window`/`document` đi xuống phần tử đích) và **Bubbling** (từ phần tử đích nổi bọt lên `window`/`document`). `addEventListener(event, handler, useCapture)`: `useCapture` (tham số thứ 3) là `false` mặc định cho giai đoạn `bubbling`, đặt `true` để lắng nghe ở giai đoạn `capturing`.",
        "Event Bubbling và Capturing chỉ áp dụng cho các sự kiện click.",
        "Event Bubbling và Capturing làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Event Bubbling và Capturing là các lỗi phổ biến trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 293,
      "topicId": 3,
      "question": "Mô tả vai trò của **`Symbol`** trong ES6 và các trường hợp sử dụng chính của nó để tạo các thuộc tính đối tượng duy nhất hoặc các 'well-known Symbols'.",
      "options": [
        "`Symbol` là một kiểu dữ liệu nguyên thủy mới trong ES6, cho phép tạo ra các giá trị duy nhất và bất biến. Chúng thường được dùng làm khóa thuộc tính cho các đối tượng để tránh xung đột tên (name clashes), đặc biệt khi mở rộng đối tượng từ bên thứ ba hoặc thêm các thuộc tính 'riêng tư'. Các 'well-known Symbols' như `Symbol.iterator`, `Symbol.hasInstance` được dùng để định nghĩa hành vi đặc biệt của đối tượng.",
        "`Symbol` là một cách để mã hóa dữ liệu trong JavaScript.",
        "`Symbol` chỉ được dùng để tạo các biểu tượng UI động.",
        "`Symbol` là một hàm để tối ưu hóa hiệu suất của chuỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 294,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Immediately Invoked Function Expressions (IIFE)'** và lợi ích của nó trong việc quản lý phạm vi (scope) và tránh xung đột biến toàn cục.",
      "options": [
        "IIFE là một hàm JavaScript được định nghĩa và thực thi ngay lập tức sau khi được tạo. Cú pháp phổ biến là `(function() { ... })();`. Lợi ích chính là tạo ra một phạm vi biến riêng (private scope) cho các biến và hàm bên trong, ngăn chúng làm ô nhiễm phạm vi toàn cục (global scope). Điều này đặc biệt quan trọng trước khi ES6 Modules ra đời để đạt được tính đóng gói và tránh xung đột tên trong các dự án lớn.",
        "IIFE là một cách để JavaScript thực hiện đa luồng.",
        "IIFE làm tăng đáng kể hiệu suất của hàm.",
        "IIFE chỉ dùng để xử lý lỗi trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 295,
      "topicId": 3,
      "question": "Sự khác biệt giữa **`Map`** và **`Object`** trong JavaScript về khả năng sử dụng key, thứ tự phần tử, và hiệu suất cho các trường hợp cụ thể?",
      "options": [
        "`Object` lưu trữ dữ liệu dưới dạng các cặp `key-value` với key là chuỗi hoặc Symbol. `Map` là một tập hợp các cặp `key-value` nơi key có thể là bất kỳ kiểu dữ liệu nào (bao gồm đối tượng, hàm), duy trì thứ tự chèn, có thuộc tính `size` và hiệu suất tốt hơn khi có nhiều thao tác thêm/xóa. `Map` thường ưu tiên hơn khi cần key linh hoạt, thứ tự đảm bảo, hoặc số lượng phần tử lớn cần thao tác thường xuyên.",
        "`Map` chỉ hoạt động với các số nguyên làm key.",
        "`Object` an toàn hơn `Map` về mặt bảo mật.",
        "`Map` không thể lưu trữ các hàm như giá trị."
      ],
      "correctAnswer": 0
    },
    {
      "id": 296,
      "topicId": 3,
      "question": "Mô tả vai trò của **`WeakSet`** trong JavaScript và khi nào nên ưu tiên sử dụng nó so với `Set` truyền thống.",
      "options": [
        "`WeakSet` là một tập hợp các đối tượng **duy nhất** có tham chiếu yếu (weak references). Điều này có nghĩa là nếu không có tham chiếu mạnh nào khác đến một đối tượng trong `WeakSet`, Garbage Collector (GC) có thể thu thập đối tượng đó, và nó sẽ tự động bị xóa khỏi `WeakSet`. Ưu tiên dùng khi bạn muốn theo dõi một tập hợp các đối tượng mà không muốn ngăn cản chúng bị giải phóng bộ nhớ, ví dụ: theo dõi các đối tượng DOM đã được gắn listener.",
        "`WeakSet` có hiệu suất tốt hơn `Set` trong mọi trường hợp.",
        "`WeakSet` chỉ hoạt động với các kiểu dữ liệu nguyên thủy.",
        "Cả hai đều là cách để JavaScript mã hóa dữ liệu."
      ],
      "correctAnswer": 0
    },
    {
      "id": 297,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Polyfill'** và **'Transpiler'** (ví dụ: Babel) trong JavaScript và vai trò của chúng trong việc sử dụng các tính năng ES6+ trong môi trường cũ.",
      "options": [
        "Polyfill là một đoạn code cung cấp các chức năng của một API hoặc tính năng mới (ví dụ: `Promise`, `Array.prototype.includes`) mà trình duyệt cũ không hỗ trợ, để làm cho nó hoạt động trong môi trường đó. Transpiler (ví dụ: Babel) là một công cụ dịch mã từ một phiên bản ngôn ngữ (ví dụ: ES6+ syntax như arrow functions, `let`/`const`) sang một phiên bản cũ hơn (ví dụ: ES5) để mã đó có thể chạy trên các môi trường không hỗ trợ cú pháp mới. Cả hai đều cho phép sử dụng các tính năng hiện đại trong môi trường legacy.",
        "Polyfill và Transpiler đều là các loại lỗi trong JavaScript.",
        "Polyfill chỉ hoạt động trong Node.js, còn Transpiler trong trình duyệt.",
        "Polyfill và Transpiler làm tăng đáng kể kích thước file JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 298,
      "topicId": 3,
      "question": "Trong JavaScript, giải thích về **`Destructuring Assignment`** (ES6) cho mảng và đối tượng và lợi ích của nó.",
      "options": [
        "Destructuring Assignment là một cú pháp trong ES6 cho phép bạn giải nén các giá trị từ mảng hoặc thuộc tính từ đối tượng vào các biến riêng biệt một cách dễ dàng và ngắn gọn. Nó giúp làm cho code rõ ràng hơn, dễ đọc hơn, đặc biệt khi làm việc với cấu trúc dữ liệu lồng nhau, và giảm boilerplate code so với việc truy cập từng thuộc tính một cách thủ công. Ví dụ: `const { name, age } = user;` hoặc `const [first, second] = arr;`.",
        "Destructuring Assignment làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Destructuring Assignment chỉ hoạt động với các số nguyên.",
        "Destructuring Assignment là một lỗi cú pháp trong JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 299,
      "topicId": 3,
      "question": "Mô tả vai trò của **`BigInt`** trong JavaScript (ES2020) và khi nào nên sử dụng nó?",
      "options": [
        "`BigInt` là một kiểu dữ liệu nguyên thủy mới cho phép bạn làm việc với các số nguyên lớn hơn giới hạn an toàn của `Number` (2^53 - 1). Nó hữu ích khi cần thực hiện các phép tính số học với độ chính xác cao trên các số nguyên rất lớn, ví dụ trong mật mã học, ID cơ sở dữ liệu lớn, hoặc các phép tính tài chính. `BigInt` được khai báo bằng cách thêm `n` vào cuối số (ví dụ: `123n`).",
        "`BigInt` dùng để xử lý các số thập phân có độ chính xác cao.",
        "`BigInt` chỉ hoạt động trong môi trường Node.js.",
        "`BigInt` là một cách để mã hóa số học để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 300,
      "topicId": 3,
      "question": "Giải thích khái niệm **'Type Coercion'** trong JavaScript và đưa ra ví dụ về cách nó có thể dẫn đến hành vi không mong muốn.",
      "options": [
        "Type Coercion là quá trình JavaScript tự động chuyển đổi kiểu dữ liệu của một giá trị sang kiểu dữ liệu khác khi cần thiết (ví dụ: trong phép toán, so sánh `==`, hoặc ngữ cảnh Boolean). Ví dụ: `1 + '2'` sẽ cho kết quả `'12'` (số 1 bị ép thành chuỗi) hoặc `Boolean(0)` trả về `false`. Nó có thể dẫn đến các lỗi khó lường và khó debug nếu không hiểu rõ cách ép kiểu hoạt động, đó là lý do nên ưu tiên `===` và kiểm tra kiểu rõ ràng.",
        "Type Coercion là một phương pháp để kiểm tra kiểu dữ liệu của biến.",
        "Type Coercion chỉ xảy ra trong các trình duyệt cũ.",
        "Type Coercion là một cách để tối ưu hóa hiệu suất của chuỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 301,
      "topicId": 4,
      "question": "Trong React, đâu là sự khác biệt chính giữa **`useState`** và **`useReducer`** khi quản lý trạng thái, và khi nào nên ưu tiên `useReducer`?",
      "options": [
        "`useState` được dùng cho các trạng thái đơn giản (primitive values, objects nhỏ), dễ sử dụng hơn. `useReducer` được ưu tiên cho các trạng thái phức tạp có logic cập nhật phức tạp, nhiều hành động (actions), hoặc khi trạng thái tiếp theo phụ thuộc vào trạng thái trước đó, giúp tập trung logic xử lý trạng thái vào một nơi (reducer function).",
        "`useReducer` chỉ dùng cho các trạng thái toàn cục (global state), còn `useState` cho trạng thái cục bộ.",
        "`useState` là phiên bản cũ hơn của `useReducer` và không còn được khuyến khích sử dụng.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau trong mọi trường hợp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 302,
      "topicId": 4,
      "question": "Giải thích vai trò của **`useEffect`** hook trong React và cách bạn sẽ sử dụng nó để thực hiện các side effects (ví dụ: data fetching, DOM manipulation, subscriptions) một cách an toàn và sạch sẽ.",
      "options": [
        "`useEffect` là một React Hook cho phép bạn thực hiện các side effects trong functional components. Nó nhận một hàm callback (effect) và một mảng dependencies. `useEffect` sẽ chạy sau mỗi lần render và chỉ chạy lại nếu các dependencies trong mảng thay đổi. Hàm trả về từ `useEffect` là hàm cleanup, được gọi trước khi effect chạy lại hoặc component unmount, giúp tránh rò rỉ bộ nhớ.",
        "`useEffect` chỉ được dùng để tối ưu hóa hiệu suất của component.",
        "`useEffect` làm cho component trở thành class component thay vì functional component.",
        "`useEffect` là một cách để truyền props giữa các component không liên quan."
      ],
      "correctAnswer": 0
    },
    {
      "id": 303,
      "topicId": 4,
      "question": "Trong React, mục đích của **`useCallback`** hook là gì và khi nào việc sử dụng nó có thể giúp cải thiện hiệu suất?",
      "options": [
        "`useCallback` ghi nhớ (memoizes) một hàm callback, chỉ tạo lại hàm đó khi một trong các dependencies của nó thay đổi. Nó giúp cải thiện hiệu suất bằng cách ngăn chặn các functional component con bị re-render không cần thiết khi hàm prop được truyền xuống, đặc biệt hữu ích khi hàm đó được truyền cho các component con được bọc bởi `React.memo`.",
        "`useCallback` tự động tối ưu hóa mọi hàm trong component mà không cần khai báo dependencies.",
        "`useCallback` là một cách để biến đổi hàm bất đồng bộ thành đồng bộ.",
        "`useCallback` chỉ được dùng để quản lý state phức tạp trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 304,
      "topicId": 4,
      "question": "Giải thích mục đích của **`useMemo`** hook trong React và khi nào việc sử dụng nó có thể giúp cải thiện hiệu suất?",
      "options": [
        "`useMemo` ghi nhớ (memoizes) một giá trị đã được tính toán, chỉ tính toán lại giá trị đó khi một trong các dependencies của nó thay đổi. Nó giúp cải thiện hiệu suất bằng cách tránh các phép tính nặng hoặc tạo các đối tượng/mảng mới không cần thiết trong mỗi lần render, đặc biệt hữu ích khi giá trị đó được sử dụng bởi các component con được bọc bởi `React.memo`.",
        "`useMemo` được dùng để quản lý các side effects tương tự như `useEffect`.",
        "`useMemo` giúp bạn định nghĩa các hàm bất đồng bộ một cách dễ dàng hơn.",
        "`useMemo` là một cách để truy cập trực tiếp DOM trong React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 305,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useRef`** hook trong React và khi nào nên sử dụng nó thay vì state để lưu trữ giá trị hoặc truy cập DOM.",
      "options": [
        "`useRef` trả về một đối tượng ref có thuộc tính `.current` có thể thay đổi và duy trì qua các lần re-render mà không kích hoạt re-render. Nó được dùng để: 1) Lưu trữ các giá trị không cần kích hoạt re-render (ví dụ: timers, ID). 2) Truy cập trực tiếp các phần tử DOM (ví dụ: tập trung vào input, kích hoạt video). Không nên dùng để lưu trữ dữ liệu cần kích hoạt re-render.",
        "`useRef` là một cách để định nghĩa các biến chỉ đọc (read-only variables).",
        "`useRef` tự động kích hoạt re-render khi giá trị `.current` thay đổi.",
        "`useRef` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 306,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Controlled Components'** và **'Uncontrolled Components'** trong form handling và ưu/nhược điểm của từng loại.",
      "options": [
        "Controlled Component là form element mà giá trị của nó được quản lý hoàn toàn bởi state của React. Dữ liệu form được lấy từ state và cập nhật thông qua `onChange`. Ưu điểm: dễ dàng validation, debug, kiểm soát luồng dữ liệu. Uncontrolled Component là form element mà dữ liệu được quản lý bởi chính DOM, truy cập bằng `useRef`. Ưu điểm: đơn giản cho form nhỏ, tích hợp với thư viện không phải React. Nhược điểm: khó kiểm soát validation, đồng bộ hóa.",
        "Controlled Components chỉ dùng cho các form nhỏ, còn Uncontrolled Components cho các form lớn.",
        "Uncontrolled Components cho hiệu suất tốt hơn Controlled Components.",
        "Không có sự khác biệt đáng kể, chúng là hai tên gọi cho cùng một khái niệm."
      ],
      "correctAnswer": 0
    },
    {
      "id": 307,
      "topicId": 4,
      "question": "Mục đích của **Context API** trong React là gì và khi nào nó là lựa chọn phù hợp để truyền dữ liệu so với truyền props (prop drilling)?",
      "options": [
        "Context API cung cấp một cách để truyền dữ liệu 'xuyên qua cây component' mà không cần phải truyền props thủ công qua mọi cấp độ (prop drilling). Nó phù hợp khi dữ liệu cần được truy cập bởi nhiều component ở các cấp độ khác nhau trong cây, đặc biệt cho các giá trị 'global' như theme, ngôn ngữ, hoặc thông tin người dùng xác thực. Tuy nhiên, không nên dùng cho mọi loại state vì có thể gây re-render không cần thiết nếu dữ liệu thay đổi thường xuyên.",
        "Context API là một cách để tối ưu hóa hiệu suất của tất cả các component.",
        "Context API chỉ được dùng để quản lý các side effects.",
        "Context API tự động quản lý tất cả state của ứng dụng mà không cần `useState` hay `useReducer`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 308,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Higher-Order Components (HOCs)'** và khi nào nên sử dụng chúng, cũng như những hạn chế của chúng so với Hooks.",
      "options": [
        "HOC là một hàm nhận một component làm đối số và trả về một component mới với các props bổ sung hoặc hành vi đã thay đổi. Chúng được dùng để tái sử dụng logic component (ví dụ: authentication, data fetching). Hạn chế: khó đọc (wrapper hell), khó truy cập ref, xung đột props. Hooks thường được ưu tiên hơn vì chúng giải quyết nhiều vấn đề của HOCs một cách đơn giản và trực quan hơn trong functional components.",
        "HOCs chỉ hoạt động với class components, không hoạt động với functional components.",
        "HOCs giúp tăng đáng kể hiệu suất của ứng dụng React.",
        "HOCs là một cách để mã hóa logic component để bảo vệ nó."
      ],
      "correctAnswer": 2
    },
    {
      "id": 309,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Error Boundaries`** trong React và cách chúng giúp xử lý lỗi trong cây component một cách graceful.",
      "options": [
        "Error Boundaries là các React components được dùng để bắt lỗi JavaScript xảy ra ở bất kỳ đâu trong cây con của chúng, ghi lại lỗi đó, và hiển thị một UI dự phòng (fallback UI) thay vì làm sập toàn bộ ứng dụng. Chúng được tạo bằng cách định nghĩa `static getDerivedStateFromError()` hoặc `componentDidCatch()` trong class component. Error Boundaries chỉ bắt lỗi trong giai đoạn render, trong lifecycle methods và trong constructors của cây con.",
        "Error Boundaries tự động sửa lỗi JavaScript trong quá trình chạy.",
        "Error Boundaries chỉ hoạt động với các lỗi bất đồng bộ (async errors).",
        "Error Boundaries là một cách để ngăn chặn người dùng truy cập vào các phần tử bị lỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 310,
      "topicId": 4,
      "question": "Trong React, giải thích mục đích của **`React.memo`** và khi nào việc sử dụng nó giúp tối ưu hóa hiệu suất cho functional components.",
      "options": [
        "`React.memo` là một Higher-Order Component ghi nhớ (memoizes) functional component, ngăn nó re-render nếu props của nó không thay đổi. Nó hữu ích để tối ưu hóa hiệu suất bằng cách tránh các re-render không cần thiết của các component con, đặc biệt là khi component con nhận các props là đối tượng/mảng/hàm được tạo mới trong mỗi lần render của component cha.",
        "`React.memo` tự động thêm state vào functional component.",
        "`React.memo` chỉ hoạt động với các class components.",
        "`React.memo` là một cách để chia sẻ logic giữa các component khác nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 311,
      "topicId": 4,
      "question": "Sự khác biệt giữa **Virtual DOM** và **Shadow DOM** là gì, và chúng phục vụ mục đích khác nhau như thế nào trong React và Web Components?",
      "options": [
        "Virtual DOM là một bản sao nhẹ của DOM thực, được React sử dụng để so sánh sự thay đổi và tối ưu hóa việc cập nhật DOM thực (reconciliation), cải thiện hiệu suất của React apps. Shadow DOM là một phần của Web Components, cung cấp tính đóng gói CSS và DOM cho các component, tạo ra các cây DOM riêng biệt và bị cô lập để tránh xung đột style và logic.",
        "Virtual DOM chỉ tồn tại trong bộ nhớ, còn Shadow DOM là một phần của DOM thực.",
        "Cả hai đều là cách để React tạo ra các component có thể tái sử dụng.",
        "Không có sự khác biệt đáng kể, chúng là hai tên gọi cho cùng một khái niệm."
      ],
      "correctAnswer": 0
    },
    {
      "id": 312,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Prop Drilling'** trong React và cách các giải pháp như Context API hoặc composition giúp giải quyết vấn đề này.",
      "options": [
        "Prop Drilling là tình trạng khi một prop phải được truyền từ component cha xuống nhiều cấp độ component con, ngay cả khi các component ở giữa không thực sự sử dụng prop đó. Điều này làm cho code khó đọc, khó bảo trì và dễ gây lỗi. Các giải pháp như **Context API** (truyền dữ liệu trực tiếp đến các component cần nó) hoặc **composition** (truyền các phần của UI dưới dạng `children` hoặc props khác) giúp tránh tình trạng này.",
        "Prop Drilling là một kỹ thuật tối ưu hóa hiệu suất trong React.",
        "Prop Drilling là một lỗi cú pháp trong React.",
        "Prop Drilling là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 313,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Key`** prop trong các danh sách React và tầm quan trọng của nó đối với hiệu suất và tính đúng đắn khi re-render.",
      "options": [
        "Prop `key` là một chuỗi duy nhất mà React yêu cầu khi render danh sách các phần tử. Nó giúp React xác định các item nào đã thay đổi, được thêm vào hoặc bị xóa, từ đó tối ưu hóa quá trình reconciliation bằng cách tái sử dụng hoặc sắp xếp lại các phần tử DOM một cách hiệu quả. Nếu không có key hoặc key không ổn định, React có thể gặp lỗi hoặc re-render không đúng, dẫn đến các vấn đề về hiệu suất và trạng thái của UI.",
        "`Key` prop được dùng để thêm CSS style vào các item trong danh sách.",
        "`Key` prop chỉ hoạt động với các class components.",
        "`Key` prop giúp tự động sắp xếp các item trong danh sách."
      ],
      "correctAnswer": 0
    },
    {
      "id": 314,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Render Props' pattern** và khi nào nên sử dụng nó để chia sẻ logic không liên quan đến UI.",
      "options": [
        "Render Props là một pattern thiết kế nơi một component nhận một hàm làm prop (thường là `render` hoặc `children`) để xác định những gì nó sẽ render. Hàm này thường được gọi với dữ liệu hoặc logic mà component đó muốn chia sẻ. Nó hữu ích để tái sử dụng logic trạng thái hoặc hành vi giữa các component mà không cần HOCs hay Custom Hooks, đặc biệt khi logic đó cần truyền dữ liệu cho phần render của component con.",
        "Render Props chỉ hoạt động với các class components.",
        "Render Props làm tăng đáng kể kích thước file JavaScript.",
        "Render Props là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 315,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`componentDidMount`** và **`useEffect`** (với mảng dependencies rỗng) trong React, và khi nào nên sử dụng từng loại?",
      "options": [
        "`componentDidMount` là lifecycle method trong class component, chạy một lần sau khi component được mount lên DOM. `useEffect` với mảng dependencies rỗng (`[]`) hoạt động tương tự trong functional component, chạy một lần sau lần render đầu tiên. Cả hai đều phù hợp cho các side effects chỉ cần chạy một lần khi component xuất hiện (ví dụ: data fetching ban đầu, thiết lập event listeners). `useEffect` được ưu tiên trong functional component.",
        "`useEffect` có thể chạy nhiều lần, còn `componentDidMount` chỉ chạy một lần.",
        "`componentDidMount` chỉ hoạt động với các lỗi bất đồng bộ.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 3
    },
    {
      "id": 316,
      "topicId": 4,
      "question": "Mô tả cách thức **`Server-Side Rendering (SSR)`** với React hoạt động và lợi ích của nó so với Client-Side Rendering (CSR) trong bối cảnh hiệu suất và SEO.",
      "options": [
        "SSR là quá trình React components được render thành HTML trên server và gửi về cho trình duyệt. Lợi ích: cải thiện **First Contentful Paint (FCP)** và **Largest Contentful Paint (LCP)** vì người dùng thấy nội dung nhanh hơn. Tốt hơn cho **SEO** vì các bot tìm kiếm có thể thu thập dữ liệu HTML đã render. Sau đó, React sẽ 'hydrates' (gắn JavaScript vào) trên client để biến HTML tĩnh thành một ứng dụng tương tác.",
        "SSR chỉ hoạt động với các ứng dụng React nhỏ.",
        "SSR làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "SSR không có lợi ích nào so với CSR trong các ứng dụng hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 317,
      "topicId": 4,
      "question": "Giải thích vai trò của **`useContext`** hook trong React và cách nó giúp tiêu thụ dữ liệu từ Context API.",
      "options": [
        "`useContext` là một Hook cho phép functional component đăng ký và tiêu thụ giá trị từ một Context mà không cần bọc component trong `Context.Consumer` hoặc sử dụng Render Props. Nó đơn giản hóa việc truy cập dữ liệu được cung cấp bởi Context và tự động re-render component khi giá trị context thay đổi.",
        "`useContext` là một cách để tạo ra một Context Provider mới.",
        "`useContext` giúp tối ưu hóa hiệu suất của component bằng cách ghi nhớ giá trị context.",
        "`useContext` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 318,
      "topicId": 4,
      "question": "Trong React, tại sao việc sử dụng **`index` làm key** trong danh sách là một anti-pattern và có thể gây ra lỗi hoặc vấn đề hiệu suất?",
      "options": [
        "Sử dụng `index` làm key là anti-pattern vì khi danh sách thay đổi thứ tự (thêm, xóa, sắp xếp lại), `index` của các phần tử sẽ thay đổi, khiến React không thể xác định đúng phần tử nào đã được thay đổi. Điều này dẫn đến re-render không hiệu quả (hiệu suất kém), hoặc tệ hơn là các lỗi khó debug liên quan đến trạng thái của component con (ví dụ: input field giữ nguyên giá trị sai). Luôn ưu tiên key duy nhất và ổn định từ dữ liệu.",
        "Sử dụng `index` làm key làm tăng kích thước gói ứng dụng React.",
        "Sử dụng `index` làm key chỉ hoạt động trên các trình duyệt cũ.",
        "Sử dụng `index` làm key giúp tăng đáng kể hiệu suất của React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 319,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Fragment`** (`<></>` hoặc `<React.Fragment>`) trong React và khi nào nên sử dụng nó?",
      "options": [
        "Fragment cho phép bạn nhóm nhiều phần tử con lại với nhau mà không cần thêm một node DOM thừa vào cây (không tạo thêm `div` bao bọc). Điều này hữu ích khi bạn muốn trả về nhiều phần tử từ một component hoặc trong các bố cục yêu cầu cấu trúc DOM phẳng (ví dụ: trong CSS Grid/Flexbox), giúp tránh các vấn đề về style hoặc ngữ nghĩa của HTML.",
        "Fragment giúp tối ưu hóa hiệu suất của component bằng cách giảm số lượng re-render.",
        "Fragment là một cách để truyền props giữa các component không liên quan.",
        "Fragment chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 320,
      "topicId": 4,
      "question": "Giải thích cách hoạt động của **'Code Splitting'** trong React (sử dụng `React.lazy` và `Suspense`) và lợi ích của nó đối với hiệu suất tải trang.",
      "options": [
        "Code Splitting là kỹ thuật chia nhỏ bundle JavaScript thành các chunk nhỏ hơn, chỉ tải các phần code cần thiết khi chúng được yêu cầu. `React.lazy` cho phép bạn render động một component được import một cách động. `Suspense` cho phép bạn hiển thị fallback UI trong khi component được tải. Lợi ích: giảm kích thước bundle ban đầu, cải thiện **First Contentful Paint (FCP)** và **Time to Interactive (TTI)**, tối ưu hóa trải nghiệm tải trang.",
        "Code Splitting chỉ hoạt động với các class components.",
        "Code Splitting làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Code Splitting là một cách để mã hóa mã nguồn React để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 321,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`PureComponent`** (class component) và **`React.memo`** (functional component) trong việc tối ưu hóa hiệu suất của component?",
      "options": [
        "`PureComponent` (dành cho class component) và `React.memo` (dành cho functional component) đều thực hiện 'shallow comparison' (so sánh nông) trên props và state (chỉ `PureComponent`) để quyết định có nên re-render hay không. Chúng giúp tránh các re-render không cần thiết nếu props/state không thay đổi. `React.memo` là tương đương `PureComponent` cho functional component.",
        "`PureComponent` và `React.memo` đều thực hiện 'deep comparison' (so sánh sâu).",
        "`PureComponent` có hiệu suất tốt hơn `React.memo`.",
        "Cả hai đều chỉ dùng để quản lý state phức tạp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 322,
      "topicId": 4,
      "question": "Mô tả cách bạn sẽ tạo một **Custom Hook** trong React và khi nào nên sử dụng nó để tái sử dụng logic có trạng thái (stateful logic) giữa các component.",
      "options": [
        "Custom Hook là một hàm JavaScript có tên bắt đầu bằng `use` (ví dụ: `useAuth`, `useForm`) và có thể gọi các React Hooks khác. Nó được dùng để tách biệt và tái sử dụng logic có trạng thái hoặc side effects giữa các functional component mà không cần Higher-Order Components hay Render Props. Custom Hooks không phải là component, chúng chỉ là cách đóng gói logic.",
        "Custom Hook là một cách để biến functional component thành class component.",
        "Custom Hook làm tăng đáng kể kích thước file JavaScript của ứng dụng.",
        "Custom Hook chỉ hoạt động với các thư viện quản lý state bên ngoài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 323,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Reconciliation'** (Đối chiếu) trong React và vai trò của Virtual DOM trong quá trình này.",
      "options": [
        "Reconciliation là quá trình React so sánh Virtual DOM hiện tại với Virtual DOM mới (sau khi state/props thay đổi) để xác định sự khác biệt. Sau đó, nó tính toán các cập nhật tối thiểu cần thiết để áp dụng lên DOM thực, giúp cập nhật giao diện người dùng một cách hiệu quả và nhanh chóng mà không cần thao tác trực tiếp trên DOM thực quá nhiều lần, vốn rất tốn kém về hiệu suất.",
        "Reconciliation là quá trình React gửi dữ liệu đến server.",
        "Reconciliation là cách React quản lý các side effects trong component.",
        "Reconciliation chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 324,
      "topicId": 4,
      "question": "Trong React, sự khác biệt giữa **`props.children`** và các prop truyền thống, và khi nào nên sử dụng `children` để truyền nội dung?",
      "options": [
        "`props.children` là một prop đặc biệt chứa các phần tử con được truyền vào giữa thẻ mở và thẻ đóng của một component. Khác với các prop thông thường truyền dữ liệu, `children` được dùng để truyền các phần tử JSX, văn bản, hoặc các component khác để component cha có thể render chúng bên trong cấu trúc của nó. Hữu ích cho các bố cục wrapper, container hoặc các component như `Modal`, `Card`.",
        "`props.children` chỉ hoạt động với các class components.",
        "`props.children` làm tăng đáng kể hiệu suất của component.",
        "`props.children` là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 325,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Portal`** trong React và khi nào nên sử dụng nó để render nội dung ra ngoài cây DOM của component?",
      "options": [
        "Portal là một tính năng trong React cho phép bạn render children vào một node DOM nằm ngoài cây DOM phân cấp của component cha. Nó được tạo bằng `ReactDOM.createPortal(child, container)`. Hữu ích cho các trường hợp như modal dialog, tooltips, hoặc popovers, nơi nội dung cần phải 'thoát ra' khỏi giới hạn `overflow` hoặc `z-index` của phần tử cha để hiển thị đúng cách trên lớp trên cùng của trang.",
        "Portal giúp tối ưu hóa hiệu suất của component bằng cách giảm số lượng re-render.",
        "Portal chỉ hoạt động với các class components.",
        "Portal là một cách để truyền props giữa các component không liên quan."
      ],
      "correctAnswer": 0
    },
    {
      "id": 326,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Suspense'** (trong React 18+) và vai trò của nó trong việc quản lý trạng thái tải (loading states) của các component được tải động.",
      "options": [
        "Suspense là một cơ chế trong React cho phép các component 'chờ đợi' một thứ gì đó (ví dụ: data fetching, tải code) trước khi render. Nó được sử dụng để hiển thị một UI dự phòng (fallback UI) trong khi dữ liệu hoặc code đang được tải. Cụ thể, nó thường dùng với `React.lazy` để quản lý loading states của các component được tải bất đồng bộ, giúp cải thiện trải nghiệm người dùng bằng cách giảm màn hình trắng hoặc lỗi.",
        "Suspense chỉ hoạt động với các class components.",
        "Suspense tự động tối ưu hóa mọi yêu cầu mạng trong ứng dụng React.",
        "Suspense là một cách để xử lý lỗi JavaScript trong React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 327,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`useCallback`** và **`useMemo`** và khi nào nên sử dụng từng loại?",
      "options": [
        "`useCallback` ghi nhớ (memoizes) một **hàm** (trả về hàm đã ghi nhớ), chỉ tạo lại hàm khi dependencies thay đổi, hữu ích để ngăn re-render không cần thiết của component con nhận hàm prop. `useMemo` ghi nhớ một **giá trị** (trả về giá trị đã ghi nhớ), chỉ tính toán lại khi dependencies thay đổi, hữu ích để tránh tính toán lại nặng hoặc tạo đối tượng/mảng mới. `useCallback(fn, deps)` tương đương `useMemo(() => fn, deps)`.",
        "`useCallback` chỉ dùng cho các hàm bất đồng bộ, còn `useMemo` cho các giá trị đồng bộ.",
        "`useCallback` luôn tối ưu hơn `useMemo` về hiệu suất.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 328,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Forwarding Refs`** trong React và khi nào nó cần thiết để truy cập DOM nodes của component con.",
      "options": [
        "Forwarding Refs là một kỹ thuật trong React cho phép một component cha truyền (forward) một `ref` mà nó nhận được từ một component ông/bà xuống một component con, thường là một phần tử DOM hoặc một instance của class component. Điều này cần thiết khi bạn muốn component cha (hoặc ông/bà) có thể trực tiếp truy cập hoặc thao tác trên DOM node bên trong component con, đặc biệt hữu ích cho các component thư viện hoặc UI wrappers.",
        "Forwarding Refs giúp tối ưu hóa hiệu suất bằng cách tránh re-render không cần thiết.",
        "Forwarding Refs chỉ hoạt động với các functional components.",
        "Forwarding Refs là một cách để truyền props giữa các component không liên quan."
      ],
      "correctAnswer": 0
    },
    {
      "id": 329,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Custom Hooks'** và lợi ích của chúng trong việc tái sử dụng logic có trạng thái (stateful logic) giữa các component mà không cần chia sẻ UI.",
      "options": [
        "Custom Hooks là các hàm JavaScript có tên bắt đầu bằng `use` và có thể gọi các React Hooks khác. Chúng được tạo ra để tách biệt và tái sử dụng logic có trạng thái hoặc side effects (ví dụ: logic form validation, logic data fetching) giữa các functional component mà không cần Higher-Order Components hay Render Props, giúp giữ cho component của bạn sạch sẽ và tập trung vào UI.",
        "Custom Hooks là một cách để biến functional component thành class component.",
        "Custom Hooks làm tăng đáng kể kích thước file JavaScript của ứng dụng.",
        "Custom Hooks chỉ hoạt động với các thư viện quản lý state bên ngoài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 330,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useTransition`** và **`useDeferredValue`** trong React 18+ (Concurrent Features) và cách chúng giúp cải thiện trải nghiệm người dùng với UI chậm phản hồi.",
      "options": [
        "`useTransition` cho phép bạn đánh dấu các cập nhật trạng thái là 'transitions' (không khẩn cấp), giúp React giữ cho UI phản hồi bằng cách ưu tiên các cập nhật khẩn cấp hơn. `useDeferredValue` cho phép bạn 'trì hoãn' việc hiển thị một giá trị cho đến khi phần UI được cập nhật hoàn toàn. Cả hai đều giúp giữ cho UI mượt mà và phản hồi tốt hơn trong các trường hợp có các tác vụ render nặng hoặc cập nhật trạng thái đồng thời.",
        "`useTransition` và `useDeferredValue` chỉ dùng để tối ưu hóa hiệu suất của các animation.",
        "`useTransition` và `useDeferredValue` là một cách để JavaScript giao tiếp với server.",
        "`useTransition` và `useDeferredValue` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 331,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`shouldComponentUpdate`** (class component) và **`React.memo`** (functional component) trong việc kiểm soát re-render?",
      "options": [
        "`shouldComponentUpdate` là một lifecycle method trong class component, cho phép bạn tự định nghĩa logic để quyết định có nên re-render component hay không (trả về `true` hoặc `false`). `React.memo` là một HOC cho functional component, tự động thực hiện 'shallow comparison' trên props để quyết định re-render. Cả hai đều nhằm mục đích tối ưu hóa hiệu suất bằng cách bỏ qua các re-render không cần thiết, nhưng `React.memo` là cách được khuyến nghị hơn cho functional component.",
        "`shouldComponentUpdate` luôn tối ưu hơn `React.memo` về hiệu suất.",
        "`React.memo` chỉ hoạt động với các lỗi bất đồng bộ.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 332,
      "topicId": 4,
      "question": "Giải thích vai trò của **`Lazy Loading Components`** (sử dụng `React.lazy` và `Suspense`) trong React và lợi ích của nó đối với hiệu suất tải trang ban đầu.",
      "options": [
        "Lazy Loading Components là kỹ thuật chỉ tải mã JavaScript của một component khi nó thực sự cần thiết (ví dụ: khi người dùng điều hướng đến một route nhất định). `React.lazy` được dùng để khai báo một component sẽ được tải động, và `Suspense` bọc quanh nó để hiển thị một UI dự phòng trong khi component đang tải. Lợi ích: giảm kích thước bundle JavaScript ban đầu, cải thiện thời gian tải trang và **Time to Interactive (TTI)**, mang lại trải nghiệm nhanh hơn cho người dùng.",
        "Lazy Loading Components chỉ hoạt động với các class components.",
        "Lazy Loading Components làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Lazy Loading Components là một cách để mã hóa mã nguồn React để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 333,
      "topicId": 4,
      "question": "Mô tả cách bạn sẽ sử dụng **Context API** trong React để quản lý trạng thái theme (sáng/tối) trong một ứng dụng lớn.",
      "options": [
        "Bạn sẽ tạo một `ThemeContext` bằng `React.createContext()`. Một `ThemeProvider` component sẽ bọc quanh phần ứng dụng cần truy cập theme, giữ trạng thái theme bằng `useState` và cung cấp giá trị theme (và hàm cập nhật theme) cho `ThemeContext.Provider`. Các component con cần theme sẽ sử dụng `useContext(ThemeContext)` để tiêu thụ giá trị này và re-render khi theme thay đổi, tránh prop drilling cho theme.",
        "Sử dụng Context API để quản lý theme sẽ làm tăng đáng kể số lượng re-render.",
        "Context API không phù hợp để quản lý trạng thái theme.",
        "Cách duy nhất để quản lý theme là sử dụng thư viện quản lý state bên ngoài như Redux."
      ],
      "correctAnswer": 0
    },
    {
      "id": 334,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Hydration'** trong bối cảnh Server-Side Rendering (SSR) và tại sao nó lại quan trọng.",
      "options": [
        "Hydration là quá trình mà React 'gắn' JavaScript vào HTML tĩnh đã được render trên server để biến nó thành một ứng dụng React tương tác đầy đủ trên client. Thay vì tạo lại DOM từ đầu, React chỉ gắn các event listeners và logic vào cây DOM hiện có, giúp ứng dụng nhanh chóng trở nên tương tác (Time to Interactive) mà vẫn giữ được lợi ích về hiệu suất của SSR (First Contentful Paint).",
        "Hydration là quá trình React gửi dữ liệu từ client lên server.",
        "Hydration là cách React nén mã nguồn JavaScript.",
        "Hydration chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 335,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`StrictMode`** và **`Fragment`** trong React?",
      "options": [
        "`StrictMode` là một công cụ giúp phát hiện các vấn đề tiềm ẩn trong ứng dụng React bằng cách bật các cảnh báo và kiểm tra bổ sung trong chế độ phát triển (development mode). Nó không render bất kỳ UI nào. `Fragment` (`<></>`) là một component cho phép bạn nhóm nhiều phần tử con lại với nhau mà không cần thêm node DOM vào cây. Mục đích của chúng khác nhau: một là kiểm tra code, một là cấu trúc DOM.",
        "`StrictMode` giúp tối ưu hóa hiệu suất của component, còn `Fragment` thì không.",
        "`StrictMode` chỉ hoạt động với các class components.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 336,
      "topicId": 4,
      "question": "Mô tả vai trò của thuộc tính **`dangerouslySetInnerHTML`** trong React và tại sao nên sử dụng nó một cách cực kỳ thận trọng.",
      "options": [
        "`dangerouslySetInnerHTML` là một thuộc tính trong React cho phép bạn chèn trực tiếp một chuỗi HTML thô vào DOM. Nó được đặt tên như vậy vì nó tiềm ẩn nguy cơ bảo mật cao (Cross-Site Scripting - XSS) nếu chuỗi HTML không được vệ sinh (sanitized) đúng cách từ nguồn không tin cậy. Chỉ nên sử dụng khi bạn chắc chắn về nguồn gốc của HTML và đã thực hiện các biện pháp phòng ngừa XSS cần thiết.",
        "`dangerouslySetInnerHTML` giúp tối ưu hóa hiệu suất rendering HTML.",
        "`dangerouslySetInnerHTML` chỉ hoạt động với các class components.",
        "`dangerouslySetInnerHTML` tự động mã hóa HTML để tăng cường bảo mật."
      ],
      "correctAnswer": 0
    },
    {
      "id": 337,
      "topicId": 4,
      "question": "Giải thích cách **Context API** có thể gây ra các re-render không mong muốn và cách khắc phục điều đó (ví dụ: chia nhỏ Context, sử dụng `useMemo`).",
      "options": [
        "Khi giá trị của Context Provider thay đổi, tất cả các component con tiêu thụ context đó (dù có sử dụng giá trị thay đổi đó hay không) sẽ re-render. Điều này có thể gây ra hiệu suất kém nếu context chứa dữ liệu thay đổi thường xuyên. Khắc phục: chia nhỏ context thành nhiều context nhỏ hơn (ví dụ: `AuthContext`, `ThemeContext`), hoặc sử dụng `useMemo` để ghi nhớ giá trị của context, chỉ tạo lại khi các dependency thực sự thay đổi.",
        "Context API luôn gây ra re-render không mong muốn và không thể khắc phục.",
        "Context API chỉ hoạt động với các class components.",
        "Context API tự động tối ưu hóa re-render mà không cần can thiệp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 338,
      "topicId": 4,
      "question": "Trong React, sự khác biệt giữa **`useEffect`** với mảng dependencies rỗng (`[]`) và không có mảng dependencies?",
      "options": [
        "`useEffect` với mảng dependencies rỗng (`[]`) chỉ chạy một lần sau lần render đầu tiên (tương tự `componentDidMount` và cleanup của nó tương tự `componentWillUnmount`). `useEffect` không có mảng dependencies sẽ chạy sau **mỗi lần render** của component. Điều này có thể dẫn đến vòng lặp vô hạn hoặc hiệu suất kém nếu không được kiểm soát.",
        "`useEffect` không có mảng dependencies sẽ không bao giờ chạy.",
        "`useEffect` với mảng dependencies rỗng (`[]`) làm tăng đáng kể hiệu suất.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 339,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Concurrent Mode`** (và các tính năng như `useTransition`, `useDeferredValue`) trong React 18+ và cách nó giúp cải thiện trải nghiệm người dùng.",
      "options": [
        "Concurrent Mode (tên cũ, nay là Concurrent Features) cho phép React chuẩn bị các phiên bản UI mới ở chế độ nền mà không chặn luồng chính, giữ cho ứng dụng phản hồi tốt hơn. Các hooks như `useTransition` và `useDeferredValue` giúp bạn đánh dấu các cập nhật trạng thái là 'không khẩn cấp' (transitions) hoặc 'trì hoãn' việc hiển thị một giá trị, cho phép React ưu tiên các tác vụ khẩn cấp (ví dụ: nhập liệu) và cải thiện khả năng tương tác của UI trong các trường hợp tải/cập nhật nặng.",
        "Concurrent Mode tự động tối ưu hóa mọi yêu cầu mạng trong ứng dụng React.",
        "Concurrent Mode chỉ hoạt động với các class components.",
        "Concurrent Mode làm tăng đáng kể kích thước gói ứng dụng JavaScript."
      ],
      "correctAnswer": 0
    },
    {
      "id": 340,
      "topicId": 4,
      "question": "Giải thích cách bạn sẽ tối ưu hóa hiệu suất của một danh sách lớn trong React (ví dụ: 1000+ item) mà không sử dụng Virtualization ngay lập tức.",
      "options": [
        "Bạn sẽ sử dụng `React.memo` (cho functional components) hoặc `PureComponent` (cho class components) cho các item trong danh sách để ngăn chúng re-render nếu props không thay đổi. Đảm bảo sử dụng `key` duy nhất và ổn định. Nếu có các hàm hoặc đối tượng được tạo mới trong mỗi lần render của component cha, hãy sử dụng `useCallback` và `useMemo` để ghi nhớ chúng. Tránh truyền các prop không cần thiết.",
        "Tối ưu hóa danh sách lớn trong React chỉ có thể thực hiện bằng cách sử dụng Virtualization.",
        "Tối ưu hóa danh sách lớn chỉ hiệu quả trên các thiết bị di động.",
        "Việc tối ưu hóa danh sách lớn không cần thiết trong React vì nó tự động xử lý."
      ],
      "correctAnswer": 0
    },
    {
      "id": 341,
      "topicId": 4,
      "question": "Trong React, khi nào nên sử dụng **`useLayoutEffect`** thay vì **`useEffect`**?",
      "options": [
        "`useLayoutEffect` chạy đồng bộ ngay sau khi tất cả các thay đổi DOM đã được áp dụng, nhưng trước khi trình duyệt thực hiện bất kỳ phép vẽ nào. Nó hữu ích khi bạn cần đọc layout của DOM (ví dụ: kích thước, vị trí cuộn) hoặc thực hiện các thay đổi DOM đồng bộ mà có thể ảnh hưởng đến layout trước khi người dùng nhìn thấy. `useEffect` chạy bất đồng bộ sau khi paint, thường được ưu tiên để tránh chặn UI.",
        "`useLayoutEffect` chỉ hoạt động với các yêu cầu mạng.",
        "`useLayoutEffect` làm tăng đáng kể hiệu suất của component.",
        "`useLayoutEffect` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 342,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Error Propagation'** trong React components và cách `Error Boundaries` chặn nó.",
      "options": [
        "Error Propagation trong React là khi một lỗi JavaScript xảy ra trong quá trình render của một component, lỗi đó sẽ lan truyền lên cây component cho đến khi nó được bắt bởi một Error Boundary hoặc đạt đến cấp độ cao nhất và làm sập toàn bộ ứng dụng. Error Boundaries hoạt động giống như một `try...catch` block cho cây component của chúng, bắt lỗi và ngăn chặn sự lan truyền này, cho phép ứng dụng vẫn hoạt động một cách graceful.",
        "Error Propagation chỉ xảy ra với các lỗi bất đồng bộ.",
        "Error Propagation là một kỹ thuật tối ưu hóa hiệu suất trong React.",
        "Error Propagation làm tăng đáng kể kích thước gói ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 343,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useImperativeHandle`** hook trong React và khi nào nên sử dụng nó kết hợp với `forwardRef`.",
      "options": [
        "`useImperativeHandle` được sử dụng bên trong một component được bọc bởi `forwardRef` để tùy chỉnh giá trị được expose bởi `ref` đó cho component cha. Thay vì expose toàn bộ instance của component hoặc DOM node, bạn có thể chỉ expose một tập hợp các phương thức hoặc thuộc tính cụ thể, giúp kiểm soát tốt hơn các tương tác từ bên ngoài và giảm sự phụ thuộc không cần thiết.",
        "`useImperativeHandle` giúp tối ưu hóa hiệu suất của component bằng cách ghi nhớ giá trị ref.",
        "`useImperativeHandle` chỉ hoạt động với các class components.",
        "`useImperativeHandle` là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 344,
      "topicId": 4,
      "question": "Trong React, sự khác biệt giữa **`memo`** và **`pure`** trong bối cảnh tối ưu hóa component?",
      "options": [
        "`memo` là một Higher-Order Component dành cho functional components (từ React 16.6+), thực hiện shallow comparison trên props. `PureComponent` là một class component (trước Hooks), thực hiện shallow comparison trên cả props và state. Cả hai đều có cùng mục tiêu là tránh re-render không cần thiết bằng cách so sánh nông, nhưng `memo` là cách được khuyến nghị cho functional component, còn `PureComponent` cho class component.",
        "`memo` luôn tối ưu hơn `pure` về hiệu suất.",
        "`memo` chỉ hoạt động với các lỗi bất đồng bộ.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 345,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Server Components'** trong React (đang phát triển) và lợi ích tiềm năng của chúng so với Client Components truyền thống.",
      "options": [
        "Server Components là một loại component React mới được render hoàn toàn trên server, không có JavaScript client-side và không gửi về client. Lợi ích: giảm đáng kể kích thước bundle JavaScript (zero-bundle-size), cải thiện hiệu suất tải trang và tương tác ban đầu, tận dụng tài nguyên server để truy cập dữ liệu nhanh hơn. Chúng được thiết kế để kết hợp với Client Components để tạo ra các ứng dụng hiệu quả hơn.",
        "Server Components chỉ hoạt động với các class components.",
        "Server Components làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Server Components là một cách để mã hóa mã nguồn React để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 346,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Profiler`** API trong React Developer Tools và cách nó giúp xác định các vấn đề hiệu suất.",
      "options": [
        "`Profiler` API là một công cụ trong React Developer Tools cho phép bạn ghi lại và phân tích hiệu suất re-render của các component trong ứng dụng. Nó hiển thị thời gian render của từng component, tần suất re-render, và nguyên nhân re-render, giúp bạn xác định các 'bottleneck' hiệu suất và các component nào đang re-render không cần thiết để tối ưu hóa.",
        "`Profiler` API giúp tự động sửa lỗi hiệu suất trong ứng dụng React.",
        "`Profiler` API chỉ hoạt động với các class components.",
        "`Profiler` API là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 347,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Memoization'** và cách `useCallback` và `useMemo` thực hiện nó để tối ưu hóa.",
      "options": [
        "Memoization là kỹ thuật tối ưu hóa bằng cách lưu trữ kết quả của một phép tính hoặc hàm (dựa trên các đầu vào của nó) và trả về kết quả đã lưu trữ nếu cùng đầu vào được cung cấp. Trong React, `useCallback` ghi nhớ một hàm, `useMemo` ghi nhớ một giá trị. Cả hai giúp ngăn chặn các phép tính lại hoặc tạo đối tượng mới không cần thiết trong mỗi lần re-render, cải thiện hiệu suất bằng cách giảm công việc cho React.",
        "Memoization làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Memoization chỉ hoạt động với các hàm bất đồng bộ.",
        "Memoization là một cách để mã hóa mã nguồn React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 348,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`Suspense`** và **`Error Boundaries`** trong việc xử lý các tình huống không mong muốn trong React?",
      "options": [
        "`Suspense` được dùng để quản lý trạng thái tải (loading states) của các component được tải bất đồng bộ (ví dụ: `React.lazy`, data fetching trong Concurrent Mode), hiển thị fallback UI trong khi chờ dữ liệu/code. `Error Boundaries` được dùng để bắt lỗi JavaScript xảy ra trong quá trình render của cây component, hiển thị fallback UI khi có lỗi. `Suspense` là cho 'loading', `Error Boundaries` là cho 'errors'.",
        "`Suspense` chỉ hoạt động với các class components.",
        "`Suspense` tự động sửa lỗi JavaScript, còn `Error Boundaries` thì không.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 349,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useId`** hook trong React 18+ và khi nào nó hữu ích để tạo ID duy nhất cho các phần tử DOM, đặc biệt là cho khả năng truy cập (accessibility).",
      "options": [
        "`useId` là một Hook tạo ra một ID duy nhất và ổn định cho một component trong quá trình render. Nó hữu ích khi bạn cần tạo các ID duy nhất cho các phần tử DOM để liên kết nhãn với input (ví dụ: `htmlFor`, `aria-labelledby`) hoặc các trường hợp cần ID duy nhất để đảm bảo khả năng truy cập mà không lo xung đột ID trong môi trường SSR hoặc với nhiều instance của cùng một component.",
        "`useId` giúp tối ưu hóa hiệu suất bằng cách giảm số lượng re-render.",
        "`useId` chỉ hoạt động với các class components.",
        "`useId` là một cách để truyền props giữa các component không liên quan."
      ],
      "correctAnswer": 0
    },
    {
      "id": 350,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Virtualized Lists'** và khi nào nên sử dụng chúng để tối ưu hóa hiệu suất hiển thị danh sách lớn.",
      "options": [
        "Virtualized Lists (ví dụ: `react-window`, `react-virtualized`) là kỹ thuật chỉ render một tập hợp nhỏ các item trong một danh sách lớn mà hiện đang nằm trong viewport của người dùng. Khi người dùng cuộn, các item mới sẽ được render và các item cũ nằm ngoài viewport sẽ bị unmount. Điều này giúp giảm đáng kể số lượng phần tử DOM được render, cải thiện hiệu suất và mượt mà khi hiển thị danh sách có hàng trăm hoặc hàng nghìn item.",
        "Virtualized Lists làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Virtualized Lists chỉ hoạt động trên các trình duyệt cũ.",
        "Virtualized Lists là một cách để mã hóa dữ liệu danh sách để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 351,
      "topicId": 4,
      "question": "Trong React, đâu là lợi ích chính của việc sử dụng **`Component Composition`** (kết hợp component) so với kế thừa lớp (class inheritance) để tái sử dụng UI và logic?",
      "options": [
        "Component Composition (ví dụ: `props.children`, truyền render props) cho phép bạn kết hợp các component nhỏ hơn để xây dựng các component phức tạp hơn, tạo ra mã linh hoạt và dễ tái sử dụng hơn. Nó tránh được các vấn đề của kế thừa như 'prop drilling' ở một mức độ nào đó, làm cho các mối quan hệ giữa component rõ ràng và ít bị ràng buộc hơn so với kế thừa lớp đơn kế thừa.",
        "Kế thừa lớp cho hiệu suất tốt hơn Component Composition.",
        "Component Composition chỉ hoạt động với functional components, còn kế thừa lớp chỉ với class components.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 352,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Suspense for Data Fetching'** trong React 18+ và cách nó đơn giản hóa việc quản lý trạng thái tải dữ liệu.",
      "options": [
        "Suspense for Data Fetching cho phép component 'tạm dừng' việc render trong khi dữ liệu đang được tải, hiển thị một fallback UI cho đến khi dữ liệu sẵn sàng. Điều này giúp loại bỏ nhu cầu quản lý trạng thái `isLoading`, `isError` trong từng component, làm cho logic fetch data và render UI trở nên sạch sẽ hơn và dễ quản lý hơn, đặc biệt khi có nhiều yêu cầu dữ liệu đồng thời.",
        "Suspense for Data Fetching tự động gửi dữ liệu lên server.",
        "Suspense for Data Fetching chỉ hoạt động với các class components.",
        "Suspense for Data Fetching làm tăng đáng kể kích thước gói ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 353,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useDebugValue`** hook trong React và khi nào nên sử dụng nó để hỗ trợ debug Custom Hooks.",
      "options": [
        "`useDebugValue` cho phép các tác giả của Custom Hooks hiển thị một nhãn tùy chỉnh trong React DevTools cho các Hook đó. Nó hữu ích để debug bằng cách cung cấp thông tin hữu ích về trạng thái nội bộ của một Custom Hook trong quá trình phát triển, giúp bạn dễ dàng theo dõi giá trị của nó mà không cần console.log quá nhiều.",
        "`useDebugValue` giúp tối ưu hóa hiệu suất bằng cách loại bỏ các console.log trong production.",
        "`useDebugValue` chỉ hoạt động với các class components.",
        "`useDebugValue` là một cách để mã hóa logic của Custom Hook."
      ],
      "correctAnswer": 0
    },
    {
      "id": 354,
      "topicId": 4,
      "question": "Trong React, sự khác biệt giữa **`memo()`** và **`useMemo()`** khi tối ưu hóa hiệu suất?",
      "options": [
        "`memo()` là một Higher-Order Component bọc quanh một functional component để ngăn nó re-render nếu props không thay đổi (shallow comparison). `useMemo()` là một hook để ghi nhớ một giá trị đã tính toán (ví dụ: kết quả của một phép tính nặng hoặc một đối tượng/mảng), chỉ tính toán lại khi dependencies thay đổi. `memo()` là cho component, `useMemo()` là cho giá trị.",
        "`memo()` luôn tối ưu hơn `useMemo()` về hiệu suất.",
        "`memo()` chỉ hoạt động với các lỗi bất đồng bộ.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 355,
      "topicId": 4,
      "question": "Giải thích khái niệm **'HOCs (Higher-Order Components)'** và khi nào nên sử dụng chúng, cũng như những hạn chế so với Hooks.",
      "options": [
        "HOC là một hàm nhận một component làm đối số và trả về một component mới với các props bổ sung hoặc hành vi đã thay đổi (ví dụ: `withAuth`, `withData`). Chúng được dùng để tái sử dụng logic component. Hạn chế: tạo ra 'wrapper hell' (nhiều lớp component lồng nhau), khó truy cập ref, xung đột props, không rõ ràng về nguồn gốc props. Hooks thường được ưu tiên hơn vì chúng giải quyết nhiều vấn đề của HOCs một cách đơn giản và trực quan hơn trong functional components.",
        "HOCs chỉ hoạt động với functional components, không hoạt động với class components.",
        "HOCs giúp tăng đáng kể hiệu suất của ứng dụng React.",
        "HOCs là một cách để mã hóa logic component để bảo vệ nó."
      ],
      "correctAnswer": 3
    },
    {
      "id": 356,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useSyncExternalStore`** hook trong React 18+ và khi nào nó được sử dụng để tích hợp với các hệ thống quản lý trạng thái bên ngoài (ví dụ: Redux, Zustand) một cách hiệu quả và tương thích với Concurrent Features.",
      "options": [
        "`useSyncExternalStore` cho phép các component React đăng ký một cách an toàn và đọc từ một nguồn dữ liệu bên ngoài (external store) mà không gặp phải vấn đề 'tearing' (mất đồng bộ trạng thái) trong Concurrent Mode. Nó được dùng để tích hợp các thư viện quản lý trạng thái không phải React (như Redux, Zustand) vào React ứng dụng một cách tương thích với các tính năng đồng thời mới, đảm bảo các cập nhật trạng thái luôn nhất quán.",
        "`useSyncExternalStore` chỉ hoạt động với các class components.",
        "`useSyncExternalStore` giúp tự động đồng bộ hóa dữ liệu với server.",
        "`useSyncExternalStore` làm tăng đáng kể kích thước gói ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 357,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Server-Side Rendering (SSR)'** và lợi ích chính của nó đối với SEO và trải nghiệm người dùng ban đầu so với Client-Side Rendering (CSR).",
      "options": [
        "SSR là quá trình React components được render thành HTML trên server và gửi về cho trình duyệt. Lợi ích: cải thiện **First Contentful Paint (FCP)** và **Largest Contentful Paint (LCP)** vì người dùng thấy nội dung nhanh hơn. Tốt hơn cho **SEO** vì các bot tìm kiếm có thể thu thập dữ liệu HTML đã render một cách dễ dàng. Sau đó, React sẽ 'hydrates' trên client để biến HTML tĩnh thành một ứng dụng tương tác đầy đủ, mang lại trải nghiệm nhanh và đầy đủ tính năng.",
        "SSR chỉ hoạt động với các ứng dụng React nhỏ.",
        "SSR làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "SSR không có lợi ích nào so với CSR trong các ứng dụng hiện đại."
      ],
      "correctAnswer": 0
    },
    {
      "id": 358,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`PureComponent`** (class component) và **`React.memo`** (functional component) trong việc tối ưu hóa hiệu suất của component?",
      "options": [
        "`PureComponent` (dành cho class component) và `React.memo` (dành cho functional component) đều thực hiện 'shallow comparison' (so sánh nông) trên props và state (chỉ `PureComponent`) để quyết định có nên re-render hay không. Chúng giúp tránh các re-render không cần thiết nếu props/state không thay đổi. `React.memo` là tương đương `PureComponent` cho functional component nhưng chỉ so sánh props.",
        "`PureComponent` và `React.memo` đều thực hiện 'deep comparison' (so sánh sâu).",
        "`PureComponent` có hiệu suất tốt hơn `React.memo`.",
        "Cả hai đều chỉ dùng để quản lý state phức tạp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 359,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useImperativeHandle`** hook trong React và khi nào nên sử dụng nó kết hợp với `forwardRef` để tùy chỉnh giá trị `ref`.",
      "options": [
        "`useImperativeHandle` được sử dụng bên trong một functional component được bọc bởi `forwardRef` để tùy chỉnh giá trị được expose bởi `ref` đó cho component cha. Thay vì expose toàn bộ DOM node hoặc instance của component, bạn có thể chỉ expose một tập hợp các phương thức hoặc thuộc tính cụ thể. Điều này giúp kiểm soát tốt hơn các tương tác 'ngoài luồng' từ bên ngoài và giảm sự phụ thuộc không cần thiết vào chi tiết triển khai nội bộ của component con.",
        "`useImperativeHandle` giúp tối ưu hóa hiệu suất của component bằng cách ghi nhớ giá trị ref.",
        "`useImperativeHandle` chỉ hoạt động với các class components.",
        "`useImperativeHandle` là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 360,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Code Splitting'** trong React (sử dụng `React.lazy` và `Suspense`) và lợi ích của nó đối với hiệu suất tải trang.",
      "options": [
        "Code Splitting là kỹ thuật chia nhỏ bundle JavaScript thành các chunk nhỏ hơn, chỉ tải các phần code cần thiết khi chúng được yêu cầu (ví dụ: khi người dùng điều hướng đến một route, mở modal). `React.lazy` cho phép bạn định nghĩa component sẽ được tải động. `Suspense` cho phép bạn hiển thị fallback UI trong khi component đó đang được tải. Lợi ích: giảm kích thước bundle ban đầu, cải thiện **First Contentful Paint (FCP)** và **Time to Interactive (TTI)**, tối ưu hóa trải nghiệm tải trang ban đầu.",
        "Code Splitting chỉ hoạt động với các class components.",
        "Code Splitting làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Code Splitting là một cách để mã hóa mã nguồn React để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 361,
      "topicId": 4,
      "question": "Trong React, đâu là lợi ích chính của việc sử dụng **`useCallback`** hook và khi nào việc sử dụng nó có thể giúp cải thiện hiệu suất, đặc biệt với các component con được memoized?",
      "options": [
        "`useCallback` ghi nhớ (memoizes) một hàm callback, chỉ tạo lại hàm đó khi một trong các dependencies của nó thay đổi. Nó giúp cải thiện hiệu suất bằng cách ngăn chặn các functional component con được bọc bởi `React.memo` bị re-render không cần thiết. Khi một hàm được truyền xuống dưới dạng prop và được tạo lại trong mỗi lần render của component cha, nó sẽ khiến component con re-render ngay cả khi các props khác không đổi. `useCallback` giải quyết vấn đề này.",
        "`useCallback` tự động tối ưu hóa mọi hàm trong component mà không cần khai báo dependencies.",
        "`useCallback` là một cách để biến đổi hàm bất đồng bộ thành đồng bộ.",
        "`useCallback` chỉ được dùng để quản lý state phức tạp trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 362,
      "topicId": 4,
      "question": "Giải thích mục đích của **`useRef`** hook trong React và khi nào nên sử dụng nó thay vì state để lưu trữ giá trị hoặc truy cập DOM mà không kích hoạt re-render.",
      "options": [
        "`useRef` trả về một đối tượng ref có thuộc tính `.current` có thể thay đổi và duy trì qua các lần re-render của component mà không kích hoạt re-render. Nó được dùng để: 1) Lưu trữ các giá trị không cần kích hoạt re-render (ví dụ: ID của timer, giá trị trước đó). 2) Truy cập trực tiếp các phần tử DOM (ví dụ: focus input, cuộn đến phần tử). Không nên dùng để lưu trữ dữ liệu cần hiển thị trên UI và kích hoạt re-render.",
        "`useRef` là một cách để định nghĩa các biến chỉ đọc (read-only variables).",
        "`useRef` tự động kích hoạt re-render khi giá trị `.current` thay đổi.",
        "`useRef` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 363,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Key`** prop trong các danh sách React và tầm quan trọng của nó đối với hiệu suất và tính đúng đắn khi re-render các danh sách động.",
      "options": [
        "Prop `key` là một chuỗi duy nhất mà React yêu cầu khi render danh sách các phần tử. Nó giúp React xác định các item nào đã thay đổi, được thêm vào, bị xóa, hoặc sắp xếp lại trong quá trình reconciliation. Việc sử dụng `key` duy nhất và ổn định cho phép React tối ưu hóa việc cập nhật DOM thực một cách hiệu quả nhất, ngăn chặn các lỗi về trạng thái của component con và đảm bảo UI luôn đúng đắn khi dữ liệu thay đổi.",
        "`Key` prop được dùng để thêm CSS style vào các item trong danh sách.",
        "`Key` prop chỉ hoạt động với các class components.",
        "`Key` prop giúp tự động sắp xếp các item trong danh sách."
      ],
      "correctAnswer": 0
    },
    {
      "id": 364,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Controlled Components'** và **'Uncontrolled Components'** trong form handling, và ưu/nhược điểm của từng loại.",
      "options": [
        "**Controlled Component** là form element mà giá trị của nó được quản lý hoàn toàn bởi state của React (`value` prop được thiết lập và cập nhật bằng `onChange`). Ưu điểm: dễ dàng validation, debug, kiểm soát luồng dữ liệu. **Uncontrolled Component** là form element mà dữ liệu được quản lý bởi chính DOM, truy cập bằng `useRef`. Ưu điểm: đơn giản cho form nhỏ, tích hợp với thư viện không phải React. Nhược điểm: khó kiểm soát validation, đồng bộ hóa giữa DOM và React state.",
        "Controlled Components chỉ dùng cho các form nhỏ, còn Uncontrolled Components cho các form lớn.",
        "Uncontrolled Components cho hiệu suất tốt hơn Controlled Components.",
        "Không có sự khác biệt đáng kể, chúng là hai tên gọi cho cùng một khái niệm."
      ],
      "correctAnswer": 0
    },
    {
      "id": 365,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`useLayoutEffect`** và **`useEffect`** về thời điểm thực thi và khi nào nên ưu tiên `useLayoutEffect`?",
      "options": [
        "`useLayoutEffect` chạy đồng bộ ngay sau khi React đã thực hiện tất cả các thay đổi DOM, nhưng trước khi trình duyệt thực hiện bất kỳ phép vẽ nào (paint). Nó hữu ích khi bạn cần đọc layout của DOM (ví dụ: kích thước, vị trí cuộn) hoặc thực hiện các thay đổi DOM đồng bộ mà có thể ảnh hưởng đến layout trước khi người dùng nhìn thấy. `useEffect` chạy bất đồng bộ sau khi paint, thường được ưu tiên để tránh chặn UI và giảm thiểu jank, vì vậy `useLayoutEffect` chỉ nên dùng khi thực sự cần thiết.",
        "`useLayoutEffect` chỉ hoạt động với các yêu cầu mạng.",
        "`useLayoutEffect` làm tăng đáng kể hiệu suất của component.",
        "`useLayoutEffect` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 366,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Portal`** trong React và khi nào nên sử dụng nó để render nội dung ra ngoài cây DOM của component (ví dụ: modal, tooltip).",
      "options": [
        "Portal là một tính năng trong React cho phép bạn render children của một component vào một node DOM nằm ngoài cây DOM phân cấp của component cha. Nó được tạo bằng `ReactDOM.createPortal(child, container)`. Hữu ích cho các trường hợp như modal dialog, tooltips, popovers, context menus, nơi nội dung cần phải 'thoát ra' khỏi giới hạn `overflow`, `z-index`, hoặc vị trí của phần tử cha để hiển thị đúng cách trên lớp trên cùng của trang hoặc tại một vị trí cụ thể trong DOM.",
        "Portal giúp tối ưu hóa hiệu suất của component bằng cách giảm số lượng re-render.",
        "Portal chỉ hoạt động với các class components.",
        "Portal là một cách để truyền props giữa các component không liên quan."
      ],
      "correctAnswer": 0
    },
    {
      "id": 367,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Custom Hooks'** và lợi ích của chúng trong việc tái sử dụng logic có trạng thái (stateful logic) giữa các functional components mà không cần chia sẻ UI.",
      "options": [
        "Custom Hooks là các hàm JavaScript có tên bắt đầu bằng `use` và có thể gọi các React Hooks khác (ví dụ: `useState`, `useEffect`). Chúng được tạo ra để tách biệt và tái sử dụng logic có trạng thái hoặc side effects (ví dụ: logic form validation, logic data fetching, logic debounce) giữa các functional component. Điều này giúp giữ cho component của bạn 'thin' và tập trung vào việc render UI, trong khi logic được tái sử dụng được đóng gói riêng biệt, cải thiện khả năng đọc và bảo trì code.",
        "Custom Hooks là một cách để biến functional component thành class component.",
        "Custom Hooks làm tăng đáng kể kích thước file JavaScript của ứng dụng.",
        "Custom Hooks chỉ hoạt động với các thư viện quản lý state bên ngoài."
      ],
      "correctAnswer": 0
    },
    {
      "id": 368,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`Suspense`** và **`Error Boundaries`** trong việc xử lý các tình huống không mong muốn trong React, và mục đích chính của từng loại?",
      "options": [
        "`Suspense` được dùng để quản lý trạng thái tải (loading states) của các component được tải bất đồng bộ (ví dụ: `React.lazy`, data fetching trong Concurrent Mode), hiển thị fallback UI trong khi chờ dữ liệu/code. `Error Boundaries` được dùng để bắt lỗi JavaScript xảy ra trong quá trình render của cây component, ghi lại lỗi và hiển thị fallback UI khi có lỗi. `Suspense` là cho 'loading', `Error Boundaries` là cho 'errors'.",
        "`Suspense` chỉ hoạt động với các class components.",
        "`Suspense` tự động sửa lỗi JavaScript, còn `Error Boundaries` thì không.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 369,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useTransition`** và **`useDeferredValue`** trong React 18+ (Concurrent Features) và cách chúng giúp cải thiện trải nghiệm người dùng với UI chậm phản hồi.",
      "options": [
        "`useTransition` cho phép bạn đánh dấu các cập nhật trạng thái là 'transitions' (không khẩn cấp), giúp React giữ cho UI phản hồi bằng cách ưu tiên các cập nhật khẩn cấp hơn (ví dụ: nhập liệu). `useDeferredValue` cho phép bạn 'trì hoãn' việc hiển thị một giá trị cho đến khi phần UI được cập nhật hoàn toàn. Cả hai đều giúp giữ cho UI mượt mà và phản hồi tốt hơn trong các trường hợp có các tác vụ render nặng hoặc cập nhật trạng thái đồng thời, giảm thiểu hiện tượng jank.",
        "`useTransition` và `useDeferredValue` chỉ dùng để tối ưu hóa hiệu suất của các animation.",
        "`useTransition` và `useDeferredValue` là một cách để JavaScript giao tiếp với server.",
        "`useTransition` và `useDeferredValue` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 370,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Virtualized Lists'** trong React và khi nào nên sử dụng chúng để tối ưu hóa hiệu suất hiển thị danh sách lớn (hàng ngàn item).",
      "options": [
        "Virtualized Lists (còn gọi là windowing, ví dụ: thư viện `react-window`, `react-virtualized`) là kỹ thuật chỉ render một tập hợp nhỏ các item trong một danh sách lớn mà hiện đang nằm trong viewport của người dùng. Khi người dùng cuộn, các item mới sẽ được render vào viewport và các item cũ nằm ngoài viewport sẽ bị unmount. Điều này giúp giảm đáng kể số lượng phần tử DOM được render, cải thiện hiệu suất và mượt mà khi hiển thị danh sách có hàng trăm hoặc hàng nghìn item mà không làm đóng băng trình duyệt.",
        "Virtualized Lists làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Virtualized Lists chỉ hoạt động trên các trình duyệt cũ.",
        "Virtualized Lists là một cách để mã hóa dữ liệu danh sách để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 371,
      "topicId": 4,
      "question": "Trong React, đâu là cách tốt nhất để quản lý **state của form** trong một ứng dụng lớn, có nhiều trường phức tạp, ngoài việc sử dụng `useState` cho từng trường?",
      "options": [
        "Sử dụng `useReducer` cho các form có logic phức tạp hoặc nhiều trường phụ thuộc lẫn nhau, giúp tập trung logic xử lý state form vào một reducer duy nhất. Hoặc sử dụng các thư viện quản lý form chuyên dụng như `Formik` hoặc `React Hook Form`, chúng cung cấp các hook và component để xử lý validation, submission, và state của form một cách hiệu quả hơn, ít boilerplate hơn.",
        "Sử dụng `useRef` cho tất cả các trường form để tránh re-render.",
        "Tạo một Context API cho mỗi trường form riêng biệt.",
        "Không cần quản lý state cho form; React tự động xử lý."
      ],
      "correctAnswer": 0
    },
    {
      "id": 372,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useId`** hook trong React 18+ và khi nào nó hữu ích để tạo ID duy nhất cho các phần tử DOM, đặc biệt là cho khả năng truy cập (accessibility) trong môi trường SSR.",
      "options": [
        "`useId` là một Hook tạo ra một ID duy nhất và ổn định cho một component trong quá trình render. Nó hữu ích khi bạn cần tạo các ID duy nhất cho các phần tử DOM để liên kết nhãn với input (`htmlFor`, `aria-labelledby`) hoặc các trường hợp cần ID duy nhất để đảm bảo khả năng truy cập. Đặc biệt quan trọng trong môi trường SSR để tránh xung đột ID khi hydration, vì ID được tạo ra có tính đồng nhất giữa server và client.",
        "`useId` giúp tối ưu hóa hiệu suất bằng cách giảm số lượng re-render.",
        "`useId` chỉ hoạt động với các class components.",
        "`useId` là một cách để truyền props giữa các component không liên quan."
      ],
      "correctAnswer": 0
    },
    {
      "id": 373,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Lifting State Up'** và khi nào nên áp dụng nó để chia sẻ trạng thái giữa các component ngang cấp hoặc không trực tiếp liên quan.",
      "options": [
        "Lifting State Up là một kỹ thuật trong React nơi trạng thái được chia sẻ giữa các component con được di chuyển (lifted) lên component cha chung gần nhất của chúng. Khi trạng thái được đặt ở component cha, nó có thể được truyền xuống các component con như props. Điều này đảm bảo rằng trạng thái là nguồn duy nhất của sự thật và các component ngang cấp có thể được đồng bộ hóa thông qua cha chung.",
        "Lifting State Up làm tăng đáng kể số lượng re-render không cần thiết.",
        "Lifting State Up chỉ hoạt động với các class components.",
        "Lifting State Up là một cách để mã hóa state để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 374,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`memo`** và **`pure`** trong bối cảnh tối ưu hóa component trong React?",
      "options": [
        "`memo` là một Higher-Order Component dành cho functional components (từ React 16.6+), thực hiện shallow comparison trên props để quyết định có re-render hay không. `PureComponent` là một class component (trước Hooks), thực hiện shallow comparison trên cả props và state để tối ưu re-render. Cả hai đều có cùng mục tiêu là tránh re-render không cần thiết bằng cách so sánh nông, nhưng được sử dụng cho các loại component khác nhau.",
        "`memo` luôn tối ưu hơn `pure` về hiệu suất.",
        "`memo` chỉ hoạt động với các lỗi bất đồng bộ.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau."
      ],
      "correctAnswer": 0
    },
    {
      "id": 375,
      "topicId": 4,
      "question": "Mô tả vai trò của **`Server Components`** trong React (đang phát triển) và lợi ích tiềm năng của chúng so với Client Components truyền thống trong việc tối ưu hóa hiệu suất.",
      "options": [
        "Server Components là một loại component React mới được render hoàn toàn trên server, không có JavaScript client-side và không gửi về client. Lợi ích: giảm đáng kể kích thước bundle JavaScript (zero-bundle-size), cải thiện hiệu suất tải trang và tương tác ban đầu, tận dụng tài nguyên server để truy cập dữ liệu nhanh hơn và gần database hơn. Chúng được thiết kế để kết hợp với Client Components để tạo ra các ứng dụng hiệu quả hơn bằng cách chuyển logic từ client sang server khi có thể.",
        "Server Components chỉ hoạt động với các class components.",
        "Server Components làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "Server Components là một cách để mã hóa mã nguồn React để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 376,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Throttling'** và **'Debouncing'** và khi nào nên sử dụng chúng để tối ưu hóa hiệu suất của các sự kiện trong component (ví dụ: `onChange`, `onScroll`).",
      "options": [
        "Debouncing trì hoãn việc thực thi hàm cho đến khi một khoảng thời gian nhất định trôi qua kể từ lần cuối cùng sự kiện kích hoạt (ví dụ: tìm kiếm tự động hoàn thành). Throttling giới hạn tần suất thực thi của hàm đến một mức tối đa nhất định trong một khoảng thời gian (ví dụ: sự kiện cuộn). Cả hai đều được sử dụng để tối ưu hóa hiệu suất, ngăn chặn các hàm được gọi quá nhiều lần bởi các sự kiện DOM thường xuyên kích hoạt và cải thiện tính phản hồi của UI.",
        "Throttling và Debouncing là các API mới trong ES6 để xử lý bất đồng bộ.",
        "Throttling và Debouncing chỉ hoạt động trong môi trường Node.js.",
        "Throttling và Debouncing làm tăng đáng kể mức tiêu thụ bộ nhớ."
      ],
      "correctAnswer": 0
    },
    {
      "id": 377,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`setState`** (trong class component) và **cập nhật state với hàm trong `useState`** (functional component) về tính bất đồng bộ?",
      "options": [
        "Cả `setState` và hàm cập nhật từ `useState` (`setXxx`) đều là bất đồng bộ và React có thể batch các cập nhật này để tối ưu hóa hiệu suất. Tuy nhiên, khi `setState` trong class component, bạn có thể truyền một hàm callback để truy cập `prevState` an toàn. Với `useState`, bạn nên truyền một hàm callback vào `setXxx` khi state mới phụ thuộc vào state cũ (ví dụ: `setCount(prevCount => prevCount + 1)`), đảm bảo bạn luôn làm việc với trạng thái mới nhất.",
        "`setState` là đồng bộ, còn hàm cập nhật của `useState` là bất đồng bộ.",
        "`setState` chỉ hoạt động với các giá trị nguyên thủy, còn `useState` với đối tượng.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 378,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useSyncExternalStore`** hook trong React 18+ và khi nào nó được sử dụng để tích hợp với các hệ thống quản lý trạng thái bên ngoài (ví dụ: Redux, Zustand) một cách hiệu quả và tương thích với Concurrent Features.",
      "options": [
        "`useSyncExternalStore` cho phép các component React đăng ký một cách an toàn và đọc từ một nguồn dữ liệu bên ngoài (external store) mà không gặp phải vấn đề 'tearing' (mất đồng bộ trạng thái) trong Concurrent Mode. Nó cung cấp ba hàm: `subscribe`, `getSnapshot`, `getServerSnapshot`. Hook này giúp tích hợp các thư viện quản lý trạng thái không phải React vào React ứng dụng một cách tương thích với các tính năng đồng thời mới, đảm bảo các cập nhật trạng thái luôn nhất quán và không bị lỗi hình ảnh.",
        "`useSyncExternalStore` chỉ hoạt động với các class components.",
        "`useSyncExternalStore` giúp tự động đồng bộ hóa dữ liệu với server.",
        "`useSyncExternalStore` làm tăng đáng kể kích thước gói ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 379,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Context Value Immutability'** và tại sao việc đảm bảo giá trị context không thay đổi giữa các renders (nếu không cần thiết) lại quan trọng để tối ưu hóa hiệu suất.",
      "options": [
        "Context Value Immutability nghĩa là giá trị bạn cung cấp cho `Context.Provider` nên là bất biến (immutable) giữa các lần render nếu giá trị thực sự không thay đổi. Nếu bạn tạo một đối tượng hoặc mảng mới trong mỗi lần render cho giá trị context (ngay cả khi nội dung giống nhau), tất cả các component con tiêu thụ context đó sẽ re-render, gây ra hiệu suất kém. Sử dụng `useMemo` để ghi nhớ giá trị context là cách khắc phục.",
        "Context Value Immutability giúp tự động mã hóa dữ liệu context.",
        "Context Value Immutability chỉ hoạt động với các class components.",
        "Context Value Immutability là một tính năng bảo mật mới của Context API."
      ],
      "correctAnswer": 0
    },
    {
      "id": 380,
      "topicId": 4,
      "question": "Mô tả vai trò của **`React DevTools Profiler`** và cách nó giúp xác định các vấn đề hiệu suất và re-render không cần thiết trong ứng dụng React.",
      "options": [
        "`React DevTools Profiler` là một công cụ trong React Developer Tools cho phép bạn ghi lại và phân tích hiệu suất re-render của các component trong ứng dụng. Nó hiển thị 'Flame Graph' và 'Ranked Chart' để hình dung thời gian render của từng component, tần suất re-render, và nguyên nhân re-render. Điều này giúp bạn xác định các 'bottleneck' hiệu suất và các component nào đang re-render không cần thiết để tối ưu hóa, ví dụ bằng `React.memo`, `useCallback`, `useMemo`.",
        "`React DevTools Profiler` giúp tự động sửa lỗi hiệu suất trong ứng dụng React.",
        "`React DevTools Profiler` chỉ hoạt động với các class components.",
        "`React DevTools Profiler` là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 381,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Memoization'** và cách `useCallback` và `useMemo` thực hiện nó để tối ưu hóa hiệu suất.",
      "options": [
        "Memoization là kỹ thuật tối ưu hóa bằng cách lưu trữ kết quả của một phép tính hoặc hàm (dựa trên các đầu vào của nó) và trả về kết quả đã lưu trữ nếu cùng đầu vào được cung cấp. Trong React, `useCallback` ghi nhớ một hàm, `useMemo` ghi nhớ một giá trị. Cả hai giúp ngăn chặn các phép tính lại hoặc tạo đối tượng/hàm mới không cần thiết trong mỗi lần re-render, cải thiện hiệu suất bằng cách giảm công việc cho React và ngăn chặn re-render của component con được memoized.",
        "Memoization làm tăng đáng kể mức tiêu thụ bộ nhớ.",
        "Memoization chỉ hoạt động với các hàm bất đồng bộ.",
        "Memoization là một cách để mã hóa mã nguồn React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 382,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`SSR (Server-Side Rendering)`** và **`SSG (Static Site Generation)`** trong React (ví dụ: Next.js) về thời điểm render và lợi ích của chúng?",
      "options": [
        "SSR render trang trên server tại thời điểm yêu cầu (on-demand), phù hợp cho nội dung động hoặc thường xuyên thay đổi (ví dụ: trang hồ sơ người dùng). SSG render trang thành HTML tĩnh tại thời điểm build, phù hợp cho nội dung ít thay đổi (blog, tài liệu). Lợi ích của SSG: hiệu suất cao nhất (không cần server-side processing cho mỗi request), SEO tuyệt vời, dễ dàng deploy lên CDN. SSR linh hoạt hơn nhưng tốn tài nguyên server hơn.",
        "SSR chỉ hoạt động với functional components, còn SSG với class components.",
        "SSG làm tăng đáng kể thời gian tải trang ban đầu.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 383,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useDeferredValue`** hook trong React 18+ (Concurrent Features) và cách nó giúp cải thiện trải nghiệm người dùng với các cập nhật UI tốn kém.",
      "options": [
        "`useDeferredValue` cho phép bạn 'trì hoãn' việc cập nhật một phần của UI khi dữ liệu nền đang thay đổi. Nó trả về một giá trị 'trì hoãn' của state hoặc prop, giúp React ưu tiên các cập nhật khẩn cấp (ví dụ: nhập liệu) trên UI và thực hiện các cập nhật tốn kém (ví dụ: lọc danh sách lớn) ở chế độ nền. Điều này giữ cho ứng dụng phản hồi tốt, tránh hiện tượng jank khi có các tác vụ tính toán nặng.",
        "`useDeferredValue` chỉ dùng để tối ưu hóa hiệu suất của các animation.",
        "`useDeferredValue` là một cách để JavaScript giao tiếp với server.",
        "`useDeferredValue` chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 384,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Batching'** của State Updates và cách nó ảnh hưởng đến số lần component re-render.",
      "options": [
        "Batching là quá trình React nhóm nhiều cập nhật trạng thái (`setState`, hàm `setXxx` từ `useState`) lại thành một lần re-render duy nhất để tối ưu hóa hiệu suất. Thay vì re-render cho mỗi cập nhật, React sẽ chờ đợi một chút và thực hiện tất cả các cập nhật trong một lần. Điều này giảm thiểu số lần thay đổi DOM thực và làm cho ứng dụng nhanh hơn. Trong React 18+, batching tự động xảy ra cho các cập nhật trong callbacks của event handlers, Promises, `setTimeout`, v.v.",
        "Batching làm tăng đáng kể số lượng re-render không cần thiết.",
        "Batching chỉ hoạt động với các class components.",
        "Batching là một tính năng bảo mật mới của React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 385,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`Context API`** và các thư viện quản lý trạng thái toàn cục bên thứ ba (ví dụ: Redux, Zustand) trong React và khi nào nên ưu tiên từng loại?",
      "options": [
        "Context API là giải pháp tích hợp của React để truyền dữ liệu 'ít thay đổi' và 'không thường xuyên cập nhật' xuống cây component (theme, user info), tránh prop drilling. Các thư viện quản lý trạng thái bên thứ ba (Redux, Zustand) phù hợp hơn cho các ứng dụng lớn với trạng thái phức tạp, logic cập nhật phức tạp, hoặc khi cần các tính năng như middleware, devtools, và khả năng mở rộng mạnh mẽ. Context đơn giản cho case nhỏ, thư viện bên ngoài cho case lớn.",
        "Context API luôn cho hiệu suất tốt hơn các thư viện bên thứ ba.",
        "Các thư viện bên thứ ba không thể tích hợp với React Hooks.",
        "Context API chỉ hoạt động với các class components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 386,
      "topicId": 4,
      "question": "Mô tả cách bạn sẽ xử lý việc **`ref`** được gán cho một component con mà nó là một functional component và không có **`forwardRef`**.",
      "options": [
        "Bạn không thể gán một `ref` trực tiếp cho một functional component trừ khi nó được bọc bởi `React.forwardRef()`. Nếu cố gắng, React sẽ báo lỗi. Để khắc phục, bạn cần bọc functional component đó trong `forwardRef` và truyền `ref` vào bên trong để gán cho một phần tử DOM hoặc class component bên trong functional component đó.",
        "Sử dụng `useRef` bên trong functional component con.",
        "Chuyển functional component đó thành class component.",
        "Không cần làm gì, React tự động xử lý `ref` cho functional components."
      ],
      "correctAnswer": 0
    },
    {
      "id": 387,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Error Boundaries'** và cách chúng giúp xử lý lỗi trong cây component một cách graceful.",
      "options": [
        "Error Boundaries là các React components (phải là class component) được dùng để bắt lỗi JavaScript xảy ra ở bất kỳ đâu trong cây con của chúng, ghi lại lỗi đó, và hiển thị một UI dự phòng (fallback UI) thay vì làm sập toàn bộ ứng dụng. Chúng được tạo bằng cách định nghĩa `static getDerivedStateFromError()` hoặc `componentDidCatch()` trong class component. Error Boundaries chỉ bắt lỗi trong giai đoạn render, trong lifecycle methods và trong constructors của cây con của chúng, không bắt lỗi trong event handlers hoặc async code.",
        "Error Boundaries tự động sửa lỗi JavaScript trong quá trình chạy.",
        "Error Boundaries chỉ hoạt động với các lỗi bất đồng bộ (async errors).",
        "Error Boundaries là một cách để ngăn chặn người dùng truy cập vào các phần tử bị lỗi."
      ],
      "correctAnswer": 0
    },
    {
      "id": 388,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`Component Lifecycle Methods`** (trong class component) và **`Hooks`** (trong functional component) trong việc quản lý side effects và vòng đời component?",
      "options": [
        "Lifecycle methods (ví dụ: `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`) là các hàm được gọi tại các thời điểm cụ thể trong vòng đời của class component. Hooks (ví dụ: `useEffect`, `useState`) cho phép functional components 'móc nối' vào các tính năng state và lifecycle của React mà không cần viết class. Hooks cung cấp một API linh hoạt hơn, dễ tái sử dụng logic và tránh các vấn đề liên quan đến `this` trong class component.",
        "Lifecycle methods luôn tốt hơn Hooks về hiệu suất.",
        "Hooks chỉ hoạt động với các lỗi bất đồng bộ.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 389,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useReducer`** hook trong React và khi nào nên ưu tiên nó so với `useState` để quản lý trạng thái phức tạp.",
      "options": [
        "`useReducer` là một Hook thay thế `useState` cho các trường hợp quản lý trạng thái phức tạp hơn. Nó nhận một reducer function (giống như trong Redux) và trạng thái ban đầu, trả về trạng thái hiện tại và một hàm `dispatch` để gửi các hành động. Ưu tiên `useReducer` khi trạng thái có logic cập nhật phức tạp, nhiều hành động, hoặc khi state tiếp theo phụ thuộc vào state trước đó, giúp tập trung logic xử lý trạng thái vào một nơi và dễ kiểm thử hơn.",
        "`useReducer` chỉ dùng cho các trạng thái toàn cục (global state), còn `useState` cho trạng thái cục bộ.",
        "`useReducer` là phiên bản cũ hơn của `useState` và không còn được khuyến khích sử dụng.",
        "Không có sự khác biệt đáng kể, chúng có thể dùng thay thế cho nhau trong mọi trường hợp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 390,
      "topicId": 4,
      "question": "Trong React, giải thích khái niệm **'Composition vs Inheritance'** và tại sao React khuyến khích sử dụng composition để xây dựng component.",
      "options": [
        "React khuyến khích 'Composition' (kết hợp component) thay vì 'Inheritance' (kế thừa lớp) để tái sử dụng UI và logic. Composition có nghĩa là xây dựng các component phức tạp bằng cách kết hợp các component nhỏ, chuyên biệt hơn (ví dụ: thông qua `props.children`, truyền props). Điều này tạo ra các component linh hoạt, dễ bảo trì, và ít bị ràng buộc hơn so với cấu trúc kế thừa cứng nhắc, giải quyết vấn đề 'wrapper hell' hay 'prop drilling' một cách hiệu quả hơn.",
        "Kế thừa lớp cho hiệu suất tốt hơn Component Composition.",
        "Composition chỉ hoạt động với functional components, còn Inheritance chỉ với class components.",
        "Không có sự khác biệt đáng kể, chúng là hai cách viết tương đương."
      ],
      "correctAnswer": 0
    },
    {
      "id": 391,
      "topicId": 4,
      "question": "Mô tả vai trò của **`React.lazy`** và **`Suspense`** trong việc triển khai **Code Splitting** (chia tách mã) trong các ứng dụng React và lợi ích của chúng đối với hiệu suất tải trang ban đầu.",
      "options": [
        "`React.lazy` cho phép bạn định nghĩa một component sẽ được tải động (lazy-loaded) khi nó lần đầu tiên được render. `Suspense` là một component React được dùng để 'bao bọc' các component được tải động, hiển thị một fallback UI (ví dụ: spinner) trong khi component đang tải. Lợi ích: giảm kích thước bundle JavaScript ban đầu, cải thiện **First Contentful Paint (FCP)** và **Time to Interactive (TTI)**, tối ưu hóa trải nghiệm tải trang bằng cách chỉ tải code khi cần thiết.",
        "`React.lazy` và `Suspense` chỉ hoạt động với các class components.",
        "`React.lazy` và `Suspense` làm tăng đáng kể kích thước gói ứng dụng JavaScript.",
        "`React.lazy` và `Suspense` là một cách để mã hóa mã nguồn React để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 392,
      "topicId": 4,
      "question": "Trong React, giải thích cách **`Context API`** có thể gây ra các re-render không mong muốn và các chiến lược để tối ưu hóa điều đó.",
      "options": [
        "Khi giá trị của `Context.Provider` thay đổi, **tất cả** các component con tiêu thụ context đó (dù có sử dụng giá trị thay đổi đó hay không) sẽ re-render. Điều này có thể gây ra hiệu suất kém nếu context chứa dữ liệu thay đổi thường xuyên hoặc lớn. Chiến lược khắc phục: 1) Chia nhỏ context thành nhiều context nhỏ hơn (ví dụ: `UserContext`, `ThemeContext`). 2) Sử dụng `useMemo` trên giá trị của context để đảm bảo nó chỉ thay đổi khi các dependencies thực sự thay đổi. 3) Sử dụng thư viện quản lý trạng thái bên thứ ba (ví dụ: Redux, Zustand) cho trạng thái phức tạp.",
        "Context API luôn gây ra re-render không mong muốn và không thể khắc phục.",
        "Context API chỉ hoạt động với các class components.",
        "Context API tự động tối ưu hóa re-render mà không cần can thiệp."
      ],
      "correctAnswer": 0
    },
    {
      "id": 393,
      "topicId": 4,
      "question": "Sự khác biệt giữa **`SyntheticEvent`** và Native DOM Event trong React?",
      "options": [
        "`SyntheticEvent` là một wrapper đa trình duyệt của React quanh các native DOM events. Nó cung cấp một API sự kiện nhất quán trên các trình duyệt khác nhau và được 'pooled' (tái sử dụng) để tối ưu hóa hiệu suất. Sau khi callback sự kiện chạy, các thuộc tính của `SyntheticEvent` bị nullified, vì vậy bạn cần truy cập chúng trong callback hoặc sử dụng `event.persist()` nếu muốn giữ chúng bất đồng bộ. Native DOM Event là sự kiện gốc của trình duyệt.",
        "`SyntheticEvent` luôn chậm hơn Native DOM Event.",
        "`SyntheticEvent` chỉ hoạt động với các class components.",
        "`SyntheticEvent` không thể được `preventDefault()` hoặc `stopPropagation()`."
      ],
      "correctAnswer": 0
    },
    {
      "id": 394,
      "topicId": 4,
      "question": "Mô tả vai trò của **`StrictMode`** trong React và lợi ích của nó trong việc phát hiện các vấn đề tiềm ẩn trong ứng dụng.",
      "options": [
        "`StrictMode` là một công cụ trong React được sử dụng để phát hiện các vấn đề và cảnh báo tiềm ẩn trong ứng dụng trong chế độ phát triển (development mode). Nó không render bất kỳ UI nào, nhưng nó bật các kiểm tra bổ sung, ví dụ: phát hiện side effects không mong muốn, sử dụng lifecycle methods không an toàn (đã bị deprecate), hoặc cảnh báo về việc sử dụng String ref cũ. Nó giúp đảm bảo code tuân thủ các best practices của React và chuẩn bị cho các tính năng Concurrent Mode trong tương lai.",
        "`StrictMode` giúp tối ưu hóa hiệu suất của component trong production.",
        "`StrictMode` chỉ hoạt động với các class components.",
        "`StrictMode` là một tính năng bảo mật mới của React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 395,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Render Props' pattern** và khi nào nên sử dụng nó để chia sẻ logic không liên quan đến UI giữa các component, và so sánh với Custom Hooks.",
      "options": [
        "Render Props là một pattern thiết kế nơi một component nhận một hàm làm prop (thường là `render` hoặc `children`) để xác định những gì nó sẽ render. Hàm này thường được gọi với dữ liệu hoặc logic mà component đó muốn chia sẻ. Nó hữu ích để tái sử dụng logic trạng thái hoặc hành vi giữa các component. Tuy nhiên, Custom Hooks thường được ưu tiên hơn trong functional component vì chúng đơn giản hóa việc tái sử dụng logic mà không cần lồng ghép component hoặc quản lý prop hàm phức tạp.",
        "Render Props chỉ hoạt động với các class components.",
        "Render Props làm tăng đáng kể kích thước file JavaScript.",
        "Render Props là một cách để quản lý state toàn cục trong ứng dụng."
      ],
      "correctAnswer": 0
    },
    {
      "id": 396,
      "topicId": 4,
      "question": "Trong React, đâu là cách tốt nhất để xử lý các **form phức tạp với nhiều trường và validation** mà không gây ra re-render không cần thiết và vẫn giữ được hiệu suất?",
      "options": [
        "Sử dụng các thư viện quản lý form chuyên dụng như `React Hook Form` hoặc `Formik`. Các thư viện này được tối ưu hóa để xử lý form phức tạp bằng cách giảm số lượng re-render không cần thiết (ví dụ: `React Hook Form` chỉ re-render khi có thay đổi thực sự cần thiết), cung cấp API dễ sử dụng cho validation, xử lý submit, và quản lý trạng thái form một cách hiệu quả, giúp code sạch sẽ và dễ bảo trì.",
        "Sử dụng `useState` cho mỗi trường form riêng lẻ và viết validation thủ công.",
        "Sử dụng `useRef` cho tất cả các trường form để tránh re-render hoàn toàn.",
        "Tạo một Context API cho mỗi trường form riêng biệt."
      ],
      "correctAnswer": 0
    },
    {
      "id": 397,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useInsertionEffect`** hook trong React 18+ và khi nào nó được sử dụng để xử lý các injection của CSS-in-JS libraries.",
      "options": [
        "`useInsertionEffect` là một hook đặc biệt (chủ yếu dùng cho các thư viện) chạy đồng bộ sau khi DOM được cập nhật nhưng trước khi layout và paint. Nó được thiết kế để các thư viện CSS-in-JS (như Emotion, styled-components) có thể inject các style mới vào DOM tại thời điểm tối ưu, giúp ngăn chặn hiện tượng **Flash of Unstyled Content (FOUC)** và tối ưu hóa hiệu suất styling động mà không chặn quá trình render chính của React.",
        "`useInsertionEffect` giúp tối ưu hóa hiệu suất bằng cách ghi nhớ các style CSS.",
        "`useInsertionEffect` chỉ hoạt động với các class components.",
        "`useInsertionEffect` là một cách để mã hóa style CSS để bảo vệ nó."
      ],
      "correctAnswer": 0
    },
    {
      "id": 398,
      "topicId": 4,
      "question": "Giải thích khái niệm **'Suspense'** (trong React 18+) và vai trò của nó trong việc quản lý trạng thái tải (loading states) của các component được tải động hoặc fetching data.",
      "options": [
        "Suspense là một cơ chế trong React cho phép component 'chờ đợi' một thứ gì đó (ví dụ: data fetching, tải code của `React.lazy`) trước khi render. Nó được sử dụng để hiển thị một UI dự phòng (fallback UI) trong khi dữ liệu hoặc code đang được tải. Điều này giúp loại bỏ boilerplate code cho việc quản lý trạng thái tải (`isLoading`), làm cho code sạch sẽ hơn và cải thiện trải nghiệm người dùng bằng cách hiển thị các trạng thái chờ đồng bộ trên UI.",
        "Suspense chỉ hoạt động với các class components.",
        "Suspense tự động tối ưu hóa mọi yêu cầu mạng trong ứng dụng React.",
        "Suspense là một cách để xử lý lỗi JavaScript trong React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 399,
      "topicId": 4,
      "question": "Trong React, đâu là lý do chính khiến việc sử dụng **`index` làm key** trong danh sách là một anti-pattern và có thể gây ra lỗi hoặc vấn đề hiệu suất?",
      "options": [
        "Sử dụng `index` làm key là anti-pattern vì khi danh sách thay đổi thứ tự (thêm, xóa, sắp xếp lại), `index` của các phần tử sẽ thay đổi. Điều này khiến React không thể xác định đúng item nào đã thay đổi, dẫn đến re-render không hiệu quả (hiệu suất kém), hoặc tệ hơn là các lỗi khó debug liên quan đến trạng thái của component con (ví dụ: input field giữ nguyên giá trị sai cho item khác). **Key phải là duy nhất và ổn định** cho mỗi item.",
        "Sử dụng `index` làm key làm tăng kích thước gói ứng dụng React.",
        "Sử dụng `index` làm key chỉ hoạt động trên các trình duyệt cũ.",
        "Sử dụng `index` làm key giúp tăng đáng kể hiệu suất của React."
      ],
      "correctAnswer": 0
    },
    {
      "id": 400,
      "topicId": 4,
      "question": "Mô tả vai trò của **`useCallback`** và **`useMemo`** trong việc tối ưu hóa hiệu suất của các component con trong React, đặc biệt khi kết hợp với `React.memo`.",
      "options": [
        "`useCallback` ghi nhớ một hàm, ngăn hàm đó được tạo lại trong mỗi lần re-render của component cha. `useMemo` ghi nhớ một giá trị (bao gồm đối tượng/mảng), ngăn giá trị đó được tính toán lại. Khi được truyền làm props cho một component con được bọc bởi `React.memo`, chúng giúp đảm bảo rằng component con đó chỉ re-render khi các props *thực sự* thay đổi (shallow comparison pass), tránh re-render không cần thiết và cải thiện hiệu suất.",
        "`useCallback` và `useMemo` tự động tối ưu hóa mọi hàm trong component mà không cần khai báo dependencies.",
        "`useCallback` và `useMemo` là một cách để biến đổi hàm bất đồng bộ thành đồng bộ.",
        "`useCallback` và `useMemo` chỉ được dùng để quản lý state phức tạp trong ứng dụng."
      ],
      "correctAnswer": 0
    }
  ]
}